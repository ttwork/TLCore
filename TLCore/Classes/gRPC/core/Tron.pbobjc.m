// Generated by the protocol buffer compiler.  DO NOT EDIT!
// clang-format off
// source: core/Tron.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
#define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
#import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
#import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#if GOOGLE_PROTOBUF_OBJC_VERSION < 30007
#error This file was generated by a newer version of protoc which is incompatible with your Protocol Buffer library sources.
#endif
#if 30007 < GOOGLE_PROTOBUF_OBJC_MIN_SUPPORTED_VERSION
#error This file was generated by an older version of protoc which is incompatible with your Protocol Buffer library sources.
#endif

#import <stdatomic.h>

#import "Tron.pbobjc.h"
#import "Discover.pbobjc.h"
#import "Common.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective-C Class declarations
// Forward declarations of Objective-C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(TronAccount);
GPBObjCClassDeclaration(AccountId);
GPBObjCClassDeclaration(Account_AccountResource);
GPBObjCClassDeclaration(Account_FreezeV2);
GPBObjCClassDeclaration(Account_Frozen);
GPBObjCClassDeclaration(Account_UnFreezeV2);
GPBObjCClassDeclaration(Block);
GPBObjCClassDeclaration(BlockHeader);
GPBObjCClassDeclaration(BlockHeader_raw);
GPBObjCClassDeclaration(BlockInventory);
GPBObjCClassDeclaration(BlockInventory_BlockId);
GPBObjCClassDeclaration(ChainInventory);
GPBObjCClassDeclaration(ChainInventory_BlockId);
GPBObjCClassDeclaration(ChainParameters);
GPBObjCClassDeclaration(ChainParameters_ChainParameter);
GPBObjCClassDeclaration(DelegatedResource);
GPBObjCClassDeclaration(DelegatedResourceAccountIndex);
GPBObjCClassDeclaration(DisconnectMessage);
GPBObjCClassDeclaration(DynamicProperties);
GPBObjCClassDeclaration(Endpoint);
GPBObjCClassDeclaration(Exchange);
GPBObjCClassDeclaration(GPBAny);
GPBObjCClassDeclaration(HelloMessage);
GPBObjCClassDeclaration(HelloMessage_BlockId);
GPBObjCClassDeclaration(InternalTransaction);
GPBObjCClassDeclaration(InternalTransaction_CallValueInfo);
GPBObjCClassDeclaration(Inventory);
GPBObjCClassDeclaration(Items);
GPBObjCClassDeclaration(Key);
GPBObjCClassDeclaration(MarketAccountOrder);
GPBObjCClassDeclaration(MarketOrder);
GPBObjCClassDeclaration(MarketOrderDetail);
GPBObjCClassDeclaration(MarketOrderIdList);
GPBObjCClassDeclaration(MarketOrderList);
GPBObjCClassDeclaration(MarketOrderPair);
GPBObjCClassDeclaration(MarketOrderPairList);
GPBObjCClassDeclaration(MarketPrice);
GPBObjCClassDeclaration(MarketPriceList);
GPBObjCClassDeclaration(MetricsInfo);
GPBObjCClassDeclaration(MetricsInfo_BlockChainInfo);
GPBObjCClassDeclaration(MetricsInfo_BlockChainInfo_DupWitness);
GPBObjCClassDeclaration(MetricsInfo_BlockChainInfo_Witness);
GPBObjCClassDeclaration(MetricsInfo_NetInfo);
GPBObjCClassDeclaration(MetricsInfo_NetInfo_ApiInfo);
GPBObjCClassDeclaration(MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo);
GPBObjCClassDeclaration(MetricsInfo_NetInfo_DisconnectionDetailInfo);
GPBObjCClassDeclaration(MetricsInfo_NetInfo_LatencyInfo);
GPBObjCClassDeclaration(MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo);
GPBObjCClassDeclaration(MetricsInfo_NodeInfo);
GPBObjCClassDeclaration(MetricsInfo_RateInfo);
GPBObjCClassDeclaration(NodeInfo);
GPBObjCClassDeclaration(NodeInfo_ConfigNodeInfo);
GPBObjCClassDeclaration(NodeInfo_MachineInfo);
GPBObjCClassDeclaration(NodeInfo_MachineInfo_DeadLockThreadInfo);
GPBObjCClassDeclaration(NodeInfo_MachineInfo_MemoryDescInfo);
GPBObjCClassDeclaration(NodeInfo_PeerInfo);
GPBObjCClassDeclaration(PBFTCommitResult);
GPBObjCClassDeclaration(PBFTMessage);
GPBObjCClassDeclaration(PBFTMessage_Raw);
GPBObjCClassDeclaration(Permission);
GPBObjCClassDeclaration(Proposal);
GPBObjCClassDeclaration(ResourceReceipt);
GPBObjCClassDeclaration(SRL);
GPBObjCClassDeclaration(TXInput);
GPBObjCClassDeclaration(TXInput_raw);
GPBObjCClassDeclaration(TXOutput);
GPBObjCClassDeclaration(TXOutputs);
GPBObjCClassDeclaration(TronTransaction);
GPBObjCClassDeclaration(TransactionInfo);
GPBObjCClassDeclaration(TransactionInfo_Log);
GPBObjCClassDeclaration(TransactionRet);
GPBObjCClassDeclaration(Transaction_Contract);
GPBObjCClassDeclaration(Transaction_Result);
GPBObjCClassDeclaration(Transaction_raw);
GPBObjCClassDeclaration(Transactions);
GPBObjCClassDeclaration(Vote);
GPBObjCClassDeclaration(Votes);
GPBObjCClassDeclaration(Witness);
GPBObjCClassDeclaration(authority);

#pragma mark - TronRoot

@implementation TronRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

static GPBFileDescription TronRoot_FileDescription = {
    .package = "protocol",
    .prefix = NULL,
    .syntax = GPBFileSyntaxProto3
};

#pragma mark - Enum AccountType

GPBEnumDescriptor *AccountType_EnumDescriptor(void) {
    static _Atomic(GPBEnumDescriptor*) descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static const char *valueNames =
        "Normal\000AssetIssue\000Contract\000";
        static const int32_t values[] = {
            AccountType_Normal,
            AccountType_AssetIssue,
            AccountType_Contract,
        };
        static const char *extraTextFormatInfo = "\003\000\006\000\001\n\000\002\010\000";
        GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(AccountType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:AccountType_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None
                              extraTextFormatInfo:extraTextFormatInfo];
        GPBEnumDescriptor *expected = nil;
        if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
            [worker release];
        }
    }
    return descriptor;
}

BOOL AccountType_IsValidValue(int32_t value__) {
    switch (value__) {
        case AccountType_Normal:
        case AccountType_AssetIssue:
        case AccountType_Contract:
            return YES;
        default:
            return NO;
    }
}

#pragma mark - Enum ReasonCode

GPBEnumDescriptor *ReasonCode_EnumDescriptor(void) {
    static _Atomic(GPBEnumDescriptor*) descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static const char *valueNames =
        "Requested\000BadProtocol\000TooManyPeers\000Dupli"
        "catePeer\000IncompatibleProtocol\000RandomElim"
        "ination\000PeerQuiting\000UnexpectedIdentity\000L"
        "ocalIdentity\000PingTimeout\000UserReason\000Rese"
        "t\000SyncFail\000FetchFail\000BadTx\000BadBlock\000Fork"
        "ed\000Unlinkable\000IncompatibleVersion\000Incomp"
        "atibleChain\000TimeOut\000ConnectFail\000TooManyP"
        "eersWithSameIp\000LightNodeSyncFail\000BelowTh"
        "anMe\000Unknown\000";
        static const int32_t values[] = {
            ReasonCode_Requested,
            ReasonCode_BadProtocol,
            ReasonCode_TooManyPeers,
            ReasonCode_DuplicatePeer,
            ReasonCode_IncompatibleProtocol,
            ReasonCode_RandomElimination,
            ReasonCode_PeerQuiting,
            ReasonCode_UnexpectedIdentity,
            ReasonCode_LocalIdentity,
            ReasonCode_PingTimeout,
            ReasonCode_UserReason,
            ReasonCode_Reset,
            ReasonCode_SyncFail,
            ReasonCode_FetchFail,
            ReasonCode_BadTx,
            ReasonCode_BadBlock,
            ReasonCode_Forked,
            ReasonCode_Unlinkable,
            ReasonCode_IncompatibleVersion,
            ReasonCode_IncompatibleChain,
            ReasonCode_TimeOut,
            ReasonCode_ConnectFail,
            ReasonCode_TooManyPeersWithSameIp,
            ReasonCode_LightNodeSyncFail,
            ReasonCode_BelowThanMe,
            ReasonCode_Unknown,
        };
        GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ReasonCode)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ReasonCode_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None];
        GPBEnumDescriptor *expected = nil;
        if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
            [worker release];
        }
    }
    return descriptor;
}

BOOL ReasonCode_IsValidValue(int32_t value__) {
    switch (value__) {
        case ReasonCode_Requested:
        case ReasonCode_BadProtocol:
        case ReasonCode_TooManyPeers:
        case ReasonCode_DuplicatePeer:
        case ReasonCode_IncompatibleProtocol:
        case ReasonCode_RandomElimination:
        case ReasonCode_PeerQuiting:
        case ReasonCode_UnexpectedIdentity:
        case ReasonCode_LocalIdentity:
        case ReasonCode_PingTimeout:
        case ReasonCode_UserReason:
        case ReasonCode_Reset:
        case ReasonCode_SyncFail:
        case ReasonCode_FetchFail:
        case ReasonCode_BadTx:
        case ReasonCode_BadBlock:
        case ReasonCode_Forked:
        case ReasonCode_Unlinkable:
        case ReasonCode_IncompatibleVersion:
        case ReasonCode_IncompatibleChain:
        case ReasonCode_TimeOut:
        case ReasonCode_ConnectFail:
        case ReasonCode_TooManyPeersWithSameIp:
        case ReasonCode_LightNodeSyncFail:
        case ReasonCode_BelowThanMe:
        case ReasonCode_Unknown:
            return YES;
        default:
            return NO;
    }
}

#pragma mark - Enum Proposal_State

GPBEnumDescriptor *Proposal_State_EnumDescriptor(void) {
    static _Atomic(GPBEnumDescriptor*) descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static const char *valueNames =
        "Pending\000Disapproved\000Approved\000Canceled\000";
        static const int32_t values[] = {
            Proposal_State_Pending,
            Proposal_State_Disapproved,
            Proposal_State_Approved,
            Proposal_State_Canceled,
        };
        GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Proposal_State)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Proposal_State_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None];
        GPBEnumDescriptor *expected = nil;
        if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
            [worker release];
        }
    }
    return descriptor;
}

BOOL Proposal_State_IsValidValue(int32_t value__) {
    switch (value__) {
        case Proposal_State_Pending:
        case Proposal_State_Disapproved:
        case Proposal_State_Approved:
        case Proposal_State_Canceled:
            return YES;
        default:
            return NO;
    }
}

#pragma mark - Enum MarketOrder_State

GPBEnumDescriptor *MarketOrder_State_EnumDescriptor(void) {
    static _Atomic(GPBEnumDescriptor*) descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static const char *valueNames =
        "Active\000Inactive\000Canceled\000";
        static const int32_t values[] = {
            MarketOrder_State_Active,
            MarketOrder_State_Inactive,
            MarketOrder_State_Canceled,
        };
        GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(MarketOrder_State)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:MarketOrder_State_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None];
        GPBEnumDescriptor *expected = nil;
        if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
            [worker release];
        }
    }
    return descriptor;
}

BOOL MarketOrder_State_IsValidValue(int32_t value__) {
    switch (value__) {
        case MarketOrder_State_Active:
        case MarketOrder_State_Inactive:
        case MarketOrder_State_Canceled:
            return YES;
        default:
            return NO;
    }
}

#pragma mark - Enum Permission_PermissionType

GPBEnumDescriptor *Permission_PermissionType_EnumDescriptor(void) {
    static _Atomic(GPBEnumDescriptor*) descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static const char *valueNames =
        "Owner\000Witness\000Active\000";
        static const int32_t values[] = {
            Permission_PermissionType_Owner,
            Permission_PermissionType_Witness,
            Permission_PermissionType_Active,
        };
        static const char *extraTextFormatInfo = "\003\000\005\000\001\007\000\002\006\000";
        GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Permission_PermissionType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Permission_PermissionType_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None
                              extraTextFormatInfo:extraTextFormatInfo];
        GPBEnumDescriptor *expected = nil;
        if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
            [worker release];
        }
    }
    return descriptor;
}

BOOL Permission_PermissionType_IsValidValue(int32_t value__) {
    switch (value__) {
        case Permission_PermissionType_Owner:
        case Permission_PermissionType_Witness:
        case Permission_PermissionType_Active:
            return YES;
        default:
            return NO;
    }
}

#pragma mark - Enum Transaction_Contract_ContractType

GPBEnumDescriptor *Transaction_Contract_ContractType_EnumDescriptor(void) {
    static _Atomic(GPBEnumDescriptor*) descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static const char *valueNames =
        "AccountCreateContract\000TransferContract\000T"
        "ransferAssetContract\000VoteAssetContract\000V"
        "oteWitnessContract\000WitnessCreateContract"
        "\000AssetIssueContract\000WitnessUpdateContrac"
        "t\000ParticipateAssetIssueContract\000AccountU"
        "pdateContract\000FreezeBalanceContract\000Unfr"
        "eezeBalanceContract\000WithdrawBalanceContr"
        "act\000UnfreezeAssetContract\000UpdateAssetCon"
        "tract\000ProposalCreateContract\000ProposalApp"
        "roveContract\000ProposalDeleteContract\000SetA"
        "ccountIdContract\000CustomContract\000CreateSm"
        "artContract\000TriggerSmartContract\000GetCont"
        "ract\000UpdateSettingContract\000ExchangeCreat"
        "eContract\000ExchangeInjectContract\000Exchang"
        "eWithdrawContract\000ExchangeTransactionCon"
        "tract\000UpdateEnergyLimitContract\000AccountP"
        "ermissionUpdateContract\000ClearAbicontract"
        "\000UpdateBrokerageContract\000ShieldedTransfe"
        "rContract\000MarketSellAssetContract\000Market"
        "CancelOrderContract\000FreezeBalanceV2Contr"
        "act\000UnfreezeBalanceV2Contract\000WithdrawEx"
        "pireUnfreezeContract\000DelegateResourceCon"
        "tract\000UnDelegateResourceContract\000CancelA"
        "llUnfreezeV2Contract\000";
        static const int32_t values[] = {
            Transaction_Contract_ContractType_AccountCreateContract,
            Transaction_Contract_ContractType_TransferContract,
            Transaction_Contract_ContractType_TransferAssetContract,
            Transaction_Contract_ContractType_VoteAssetContract,
            Transaction_Contract_ContractType_VoteWitnessContract,
            Transaction_Contract_ContractType_WitnessCreateContract,
            Transaction_Contract_ContractType_AssetIssueContract,
            Transaction_Contract_ContractType_WitnessUpdateContract,
            Transaction_Contract_ContractType_ParticipateAssetIssueContract,
            Transaction_Contract_ContractType_AccountUpdateContract,
            Transaction_Contract_ContractType_FreezeBalanceContract,
            Transaction_Contract_ContractType_UnfreezeBalanceContract,
            Transaction_Contract_ContractType_WithdrawBalanceContract,
            Transaction_Contract_ContractType_UnfreezeAssetContract,
            Transaction_Contract_ContractType_UpdateAssetContract,
            Transaction_Contract_ContractType_ProposalCreateContract,
            Transaction_Contract_ContractType_ProposalApproveContract,
            Transaction_Contract_ContractType_ProposalDeleteContract,
            Transaction_Contract_ContractType_SetAccountIdContract,
            Transaction_Contract_ContractType_CustomContract,
            Transaction_Contract_ContractType_CreateSmartContract,
            Transaction_Contract_ContractType_TriggerSmartContract,
            Transaction_Contract_ContractType_GetContract,
            Transaction_Contract_ContractType_UpdateSettingContract,
            Transaction_Contract_ContractType_ExchangeCreateContract,
            Transaction_Contract_ContractType_ExchangeInjectContract,
            Transaction_Contract_ContractType_ExchangeWithdrawContract,
            Transaction_Contract_ContractType_ExchangeTransactionContract,
            Transaction_Contract_ContractType_UpdateEnergyLimitContract,
            Transaction_Contract_ContractType_AccountPermissionUpdateContract,
            Transaction_Contract_ContractType_ClearAbicontract,
            Transaction_Contract_ContractType_UpdateBrokerageContract,
            Transaction_Contract_ContractType_ShieldedTransferContract,
            Transaction_Contract_ContractType_MarketSellAssetContract,
            Transaction_Contract_ContractType_MarketCancelOrderContract,
            Transaction_Contract_ContractType_FreezeBalanceV2Contract,
            Transaction_Contract_ContractType_UnfreezeBalanceV2Contract,
            Transaction_Contract_ContractType_WithdrawExpireUnfreezeContract,
            Transaction_Contract_ContractType_DelegateResourceContract,
            Transaction_Contract_ContractType_UnDelegateResourceContract,
            Transaction_Contract_ContractType_CancelAllUnfreezeV2Contract,
        };
        static const char *extraTextFormatInfo = ")\000\025\000\001\020\000\002\025\000\003\021\000\004\023\000\005\025\000\006\022\000\007\025\000\010\035\000\t\025\000\n\025\000\013\027\000\014\027\000\r\025\000\016\023\000\017\026\000\020\027\000\021\026\000\022\024\000\023\016\000\024\023\000\025\024\000\026\013\000\027\025\000\030\026\000\031\026\000\032\030\000\033\033\000\034\031\000\035\037\000\036\006c\007\000\037\027\000 \030\000!\027\000\"\031\000#\027\000$\031\000%\036\000&\030\000\'\032\000(\033\000";
        GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Transaction_Contract_ContractType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Transaction_Contract_ContractType_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None
                              extraTextFormatInfo:extraTextFormatInfo];
        GPBEnumDescriptor *expected = nil;
        if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
            [worker release];
        }
    }
    return descriptor;
}

BOOL Transaction_Contract_ContractType_IsValidValue(int32_t value__) {
    switch (value__) {
        case Transaction_Contract_ContractType_AccountCreateContract:
        case Transaction_Contract_ContractType_TransferContract:
        case Transaction_Contract_ContractType_TransferAssetContract:
        case Transaction_Contract_ContractType_VoteAssetContract:
        case Transaction_Contract_ContractType_VoteWitnessContract:
        case Transaction_Contract_ContractType_WitnessCreateContract:
        case Transaction_Contract_ContractType_AssetIssueContract:
        case Transaction_Contract_ContractType_WitnessUpdateContract:
        case Transaction_Contract_ContractType_ParticipateAssetIssueContract:
        case Transaction_Contract_ContractType_AccountUpdateContract:
        case Transaction_Contract_ContractType_FreezeBalanceContract:
        case Transaction_Contract_ContractType_UnfreezeBalanceContract:
        case Transaction_Contract_ContractType_WithdrawBalanceContract:
        case Transaction_Contract_ContractType_UnfreezeAssetContract:
        case Transaction_Contract_ContractType_UpdateAssetContract:
        case Transaction_Contract_ContractType_ProposalCreateContract:
        case Transaction_Contract_ContractType_ProposalApproveContract:
        case Transaction_Contract_ContractType_ProposalDeleteContract:
        case Transaction_Contract_ContractType_SetAccountIdContract:
        case Transaction_Contract_ContractType_CustomContract:
        case Transaction_Contract_ContractType_CreateSmartContract:
        case Transaction_Contract_ContractType_TriggerSmartContract:
        case Transaction_Contract_ContractType_GetContract:
        case Transaction_Contract_ContractType_UpdateSettingContract:
        case Transaction_Contract_ContractType_ExchangeCreateContract:
        case Transaction_Contract_ContractType_ExchangeInjectContract:
        case Transaction_Contract_ContractType_ExchangeWithdrawContract:
        case Transaction_Contract_ContractType_ExchangeTransactionContract:
        case Transaction_Contract_ContractType_UpdateEnergyLimitContract:
        case Transaction_Contract_ContractType_AccountPermissionUpdateContract:
        case Transaction_Contract_ContractType_ClearAbicontract:
        case Transaction_Contract_ContractType_UpdateBrokerageContract:
        case Transaction_Contract_ContractType_ShieldedTransferContract:
        case Transaction_Contract_ContractType_MarketSellAssetContract:
        case Transaction_Contract_ContractType_MarketCancelOrderContract:
        case Transaction_Contract_ContractType_FreezeBalanceV2Contract:
        case Transaction_Contract_ContractType_UnfreezeBalanceV2Contract:
        case Transaction_Contract_ContractType_WithdrawExpireUnfreezeContract:
        case Transaction_Contract_ContractType_DelegateResourceContract:
        case Transaction_Contract_ContractType_UnDelegateResourceContract:
        case Transaction_Contract_ContractType_CancelAllUnfreezeV2Contract:
            return YES;
        default:
            return NO;
    }
}

#pragma mark - Enum Transaction_Result_code

GPBEnumDescriptor *Transaction_Result_code_EnumDescriptor(void) {
    static _Atomic(GPBEnumDescriptor*) descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static const char *valueNames =
        "Sucess\000Failed\000";
        static const int32_t values[] = {
            Transaction_Result_code_Sucess,
            Transaction_Result_code_Failed,
        };
        GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Transaction_Result_code)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Transaction_Result_code_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None];
        GPBEnumDescriptor *expected = nil;
        if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
            [worker release];
        }
    }
    return descriptor;
}

BOOL Transaction_Result_code_IsValidValue(int32_t value__) {
    switch (value__) {
        case Transaction_Result_code_Sucess:
        case Transaction_Result_code_Failed:
            return YES;
        default:
            return NO;
    }
}

#pragma mark - Enum Transaction_Result_contractResult

GPBEnumDescriptor *Transaction_Result_contractResult_EnumDescriptor(void) {
    static _Atomic(GPBEnumDescriptor*) descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static const char *valueNames =
        "Default\000Success\000Revert\000BadJumpDestinatio"
        "n\000OutOfMemory\000PrecompiledContract\000StackT"
        "ooSmall\000StackTooLarge\000IllegalOperation\000S"
        "tackOverflow\000OutOfEnergy\000OutOfTime\000JvmSt"
        "ackOverFlow\000Unknown\000TransferFailed\000Inval"
        "idCode\000";
        static const int32_t values[] = {
            Transaction_Result_contractResult_Default,
            Transaction_Result_contractResult_Success,
            Transaction_Result_contractResult_Revert,
            Transaction_Result_contractResult_BadJumpDestination,
            Transaction_Result_contractResult_OutOfMemory,
            Transaction_Result_contractResult_PrecompiledContract,
            Transaction_Result_contractResult_StackTooSmall,
            Transaction_Result_contractResult_StackTooLarge,
            Transaction_Result_contractResult_IllegalOperation,
            Transaction_Result_contractResult_StackOverflow,
            Transaction_Result_contractResult_OutOfEnergy,
            Transaction_Result_contractResult_OutOfTime,
            Transaction_Result_contractResult_JvmStackOverFlow,
            Transaction_Result_contractResult_Unknown,
            Transaction_Result_contractResult_TransferFailed,
            Transaction_Result_contractResult_InvalidCode,
        };
        GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Transaction_Result_contractResult)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Transaction_Result_contractResult_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None];
        GPBEnumDescriptor *expected = nil;
        if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
            [worker release];
        }
    }
    return descriptor;
}

BOOL Transaction_Result_contractResult_IsValidValue(int32_t value__) {
    switch (value__) {
        case Transaction_Result_contractResult_Default:
        case Transaction_Result_contractResult_Success:
        case Transaction_Result_contractResult_Revert:
        case Transaction_Result_contractResult_BadJumpDestination:
        case Transaction_Result_contractResult_OutOfMemory:
        case Transaction_Result_contractResult_PrecompiledContract:
        case Transaction_Result_contractResult_StackTooSmall:
        case Transaction_Result_contractResult_StackTooLarge:
        case Transaction_Result_contractResult_IllegalOperation:
        case Transaction_Result_contractResult_StackOverflow:
        case Transaction_Result_contractResult_OutOfEnergy:
        case Transaction_Result_contractResult_OutOfTime:
        case Transaction_Result_contractResult_JvmStackOverFlow:
        case Transaction_Result_contractResult_Unknown:
        case Transaction_Result_contractResult_TransferFailed:
        case Transaction_Result_contractResult_InvalidCode:
            return YES;
        default:
            return NO;
    }
}

#pragma mark - Enum TransactionInfo_code

GPBEnumDescriptor *TransactionInfo_code_EnumDescriptor(void) {
    static _Atomic(GPBEnumDescriptor*) descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static const char *valueNames =
        "Sucess\000Failed\000";
        static const int32_t values[] = {
            TransactionInfo_code_Sucess,
            TransactionInfo_code_Failed,
        };
        GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(TransactionInfo_code)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:TransactionInfo_code_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None];
        GPBEnumDescriptor *expected = nil;
        if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
            [worker release];
        }
    }
    return descriptor;
}

BOOL TransactionInfo_code_IsValidValue(int32_t value__) {
    switch (value__) {
        case TransactionInfo_code_Sucess:
        case TransactionInfo_code_Failed:
            return YES;
        default:
            return NO;
    }
}

#pragma mark - Enum BlockInventory_Type

GPBEnumDescriptor *BlockInventory_Type_EnumDescriptor(void) {
    static _Atomic(GPBEnumDescriptor*) descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static const char *valueNames =
        "Sync\000Advtise\000Fetch\000";
        static const int32_t values[] = {
            BlockInventory_Type_Sync,
            BlockInventory_Type_Advtise,
            BlockInventory_Type_Fetch,
        };
        GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(BlockInventory_Type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:BlockInventory_Type_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None];
        GPBEnumDescriptor *expected = nil;
        if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
            [worker release];
        }
    }
    return descriptor;
}

BOOL BlockInventory_Type_IsValidValue(int32_t value__) {
    switch (value__) {
        case BlockInventory_Type_Sync:
        case BlockInventory_Type_Advtise:
        case BlockInventory_Type_Fetch:
            return YES;
        default:
            return NO;
    }
}

#pragma mark - Enum Inventory_InventoryType

GPBEnumDescriptor *Inventory_InventoryType_EnumDescriptor(void) {
    static _Atomic(GPBEnumDescriptor*) descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static const char *valueNames =
        "Trx\000Block\000";
        static const int32_t values[] = {
            Inventory_InventoryType_Trx,
            Inventory_InventoryType_Block,
        };
        GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Inventory_InventoryType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Inventory_InventoryType_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None];
        GPBEnumDescriptor *expected = nil;
        if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
            [worker release];
        }
    }
    return descriptor;
}

BOOL Inventory_InventoryType_IsValidValue(int32_t value__) {
    switch (value__) {
        case Inventory_InventoryType_Trx:
        case Inventory_InventoryType_Block:
            return YES;
        default:
            return NO;
    }
}

#pragma mark - Enum Items_ItemType

GPBEnumDescriptor *Items_ItemType_EnumDescriptor(void) {
    static _Atomic(GPBEnumDescriptor*) descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static const char *valueNames =
        "Err\000Trx\000Block\000Blockheader\000";
        static const int32_t values[] = {
            Items_ItemType_Err,
            Items_ItemType_Trx,
            Items_ItemType_Block,
            Items_ItemType_Blockheader,
        };
        GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Items_ItemType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Items_ItemType_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None];
        GPBEnumDescriptor *expected = nil;
        if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
            [worker release];
        }
    }
    return descriptor;
}

BOOL Items_ItemType_IsValidValue(int32_t value__) {
    switch (value__) {
        case Items_ItemType_Err:
        case Items_ItemType_Trx:
        case Items_ItemType_Block:
        case Items_ItemType_Blockheader:
            return YES;
        default:
            return NO;
    }
}

#pragma mark - Enum PBFTMessage_MsgType

GPBEnumDescriptor *PBFTMessage_MsgType_EnumDescriptor(void) {
    static _Atomic(GPBEnumDescriptor*) descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static const char *valueNames =
        "ViewChange\000Request\000Preprepare\000Prepare\000Co"
        "mmit\000";
        static const int32_t values[] = {
            PBFTMessage_MsgType_ViewChange,
            PBFTMessage_MsgType_Request,
            PBFTMessage_MsgType_Preprepare,
            PBFTMessage_MsgType_Prepare,
            PBFTMessage_MsgType_Commit,
        };
        GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PBFTMessage_MsgType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PBFTMessage_MsgType_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None];
        GPBEnumDescriptor *expected = nil;
        if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
            [worker release];
        }
    }
    return descriptor;
}

BOOL PBFTMessage_MsgType_IsValidValue(int32_t value__) {
    switch (value__) {
        case PBFTMessage_MsgType_ViewChange:
        case PBFTMessage_MsgType_Request:
        case PBFTMessage_MsgType_Preprepare:
        case PBFTMessage_MsgType_Prepare:
        case PBFTMessage_MsgType_Commit:
            return YES;
        default:
            return NO;
    }
}

#pragma mark - Enum PBFTMessage_DataType

GPBEnumDescriptor *PBFTMessage_DataType_EnumDescriptor(void) {
    static _Atomic(GPBEnumDescriptor*) descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static const char *valueNames =
        "Block\000Srl\000";
        static const int32_t values[] = {
            PBFTMessage_DataType_Block,
            PBFTMessage_DataType_Srl,
        };
        GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PBFTMessage_DataType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PBFTMessage_DataType_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None];
        GPBEnumDescriptor *expected = nil;
        if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
            [worker release];
        }
    }
    return descriptor;
}

BOOL PBFTMessage_DataType_IsValidValue(int32_t value__) {
    switch (value__) {
        case PBFTMessage_DataType_Block:
        case PBFTMessage_DataType_Srl:
            return YES;
        default:
            return NO;
    }
}

#pragma mark - AccountId

@implementation AccountId

@dynamic name;
@dynamic address;

typedef struct AccountId__storage_ {
    uint32_t _has_storage_[1];
    NSData *name;
    NSData *address;
} AccountId__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "name",
                .dataTypeSpecific.clazz = Nil,
                .number = AccountId_FieldNumber_Name,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(AccountId__storage_, name),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "address",
                .dataTypeSpecific.clazz = Nil,
                .number = AccountId_FieldNumber_Address,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(AccountId__storage_, address),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(AccountId)
                                   messageName:@"AccountId"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AccountId__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - Vote

@implementation Vote

@dynamic voteAddress;
@dynamic voteCount;

typedef struct Vote__storage_ {
    uint32_t _has_storage_[1];
    NSData *voteAddress;
    int64_t voteCount;
} Vote__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "voteAddress",
                .dataTypeSpecific.clazz = Nil,
                .number = Vote_FieldNumber_VoteAddress,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(Vote__storage_, voteAddress),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "voteCount",
                .dataTypeSpecific.clazz = Nil,
                .number = Vote_FieldNumber_VoteCount,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(Vote__storage_, voteCount),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Vote)
                                   messageName:@"Vote"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Vote__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - Proposal

@implementation Proposal

@dynamic proposalId;
@dynamic proposerAddress;
@dynamic parameters, parameters_Count;
@dynamic expirationTime;
@dynamic createTime;
@dynamic approvalsArray, approvalsArray_Count;
@dynamic state;

typedef struct Proposal__storage_ {
    uint32_t _has_storage_[1];
    Proposal_State state;
    NSData *proposerAddress;
    GPBInt64Int64Dictionary *parameters;
    NSMutableArray *approvalsArray;
    int64_t proposalId;
    int64_t expirationTime;
    int64_t createTime;
} Proposal__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "proposalId",
                .dataTypeSpecific.clazz = Nil,
                .number = Proposal_FieldNumber_ProposalId,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(Proposal__storage_, proposalId),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "proposerAddress",
                .dataTypeSpecific.clazz = Nil,
                .number = Proposal_FieldNumber_ProposerAddress,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(Proposal__storage_, proposerAddress),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "parameters",
                .dataTypeSpecific.clazz = Nil,
                .number = Proposal_FieldNumber_Parameters,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(Proposal__storage_, parameters),
                .flags = GPBFieldMapKeyInt64,
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "expirationTime",
                .dataTypeSpecific.clazz = Nil,
                .number = Proposal_FieldNumber_ExpirationTime,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(Proposal__storage_, expirationTime),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "createTime",
                .dataTypeSpecific.clazz = Nil,
                .number = Proposal_FieldNumber_CreateTime,
                .hasIndex = 3,
                .offset = (uint32_t)offsetof(Proposal__storage_, createTime),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "approvalsArray",
                .dataTypeSpecific.clazz = Nil,
                .number = Proposal_FieldNumber_ApprovalsArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(Proposal__storage_, approvalsArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "state",
                .dataTypeSpecific.enumDescFunc = Proposal_State_EnumDescriptor,
                .number = Proposal_FieldNumber_State,
                .hasIndex = 4,
                .offset = (uint32_t)offsetof(Proposal__storage_, state),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeEnum,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Proposal)
                                   messageName:@"Proposal"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Proposal__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

int32_t Proposal_State_RawValue(Proposal *message) {
    GPBDescriptor *descriptor = [Proposal descriptor];
    GPBFieldDescriptor *field = [descriptor fieldWithNumber:Proposal_FieldNumber_State];
    return GPBGetMessageRawEnumField(message, field);
}

void SetProposal_State_RawValue(Proposal *message, int32_t value) {
    GPBDescriptor *descriptor = [Proposal descriptor];
    GPBFieldDescriptor *field = [descriptor fieldWithNumber:Proposal_FieldNumber_State];
    GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Exchange

@implementation Exchange

@dynamic exchangeId;
@dynamic creatorAddress;
@dynamic createTime;
@dynamic firstTokenId;
@dynamic firstTokenBalance;
@dynamic secondTokenId;
@dynamic secondTokenBalance;

typedef struct Exchange__storage_ {
    uint32_t _has_storage_[1];
    NSData *creatorAddress;
    NSData *firstTokenId;
    NSData *secondTokenId;
    int64_t exchangeId;
    int64_t createTime;
    int64_t firstTokenBalance;
    int64_t secondTokenBalance;
} Exchange__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "exchangeId",
                .dataTypeSpecific.clazz = Nil,
                .number = Exchange_FieldNumber_ExchangeId,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(Exchange__storage_, exchangeId),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "creatorAddress",
                .dataTypeSpecific.clazz = Nil,
                .number = Exchange_FieldNumber_CreatorAddress,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(Exchange__storage_, creatorAddress),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "createTime",
                .dataTypeSpecific.clazz = Nil,
                .number = Exchange_FieldNumber_CreateTime,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(Exchange__storage_, createTime),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "firstTokenId",
                .dataTypeSpecific.clazz = Nil,
                .number = Exchange_FieldNumber_FirstTokenId,
                .hasIndex = 3,
                .offset = (uint32_t)offsetof(Exchange__storage_, firstTokenId),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "firstTokenBalance",
                .dataTypeSpecific.clazz = Nil,
                .number = Exchange_FieldNumber_FirstTokenBalance,
                .hasIndex = 4,
                .offset = (uint32_t)offsetof(Exchange__storage_, firstTokenBalance),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "secondTokenId",
                .dataTypeSpecific.clazz = Nil,
                .number = Exchange_FieldNumber_SecondTokenId,
                .hasIndex = 5,
                .offset = (uint32_t)offsetof(Exchange__storage_, secondTokenId),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "secondTokenBalance",
                .dataTypeSpecific.clazz = Nil,
                .number = Exchange_FieldNumber_SecondTokenBalance,
                .hasIndex = 6,
                .offset = (uint32_t)offsetof(Exchange__storage_, secondTokenBalance),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Exchange)
                                   messageName:@"Exchange"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Exchange__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - MarketOrder

@implementation MarketOrder

@dynamic orderId;
@dynamic ownerAddress;
@dynamic createTime;
@dynamic sellTokenId;
@dynamic sellTokenQuantity;
@dynamic buyTokenId;
@dynamic buyTokenQuantity;
@dynamic sellTokenQuantityRemain;
@dynamic sellTokenQuantityReturn;
@dynamic state;
@dynamic prev;
@dynamic next;

typedef struct MarketOrder__storage_ {
    uint32_t _has_storage_[1];
    MarketOrder_State state;
    NSData *orderId;
    NSData *ownerAddress;
    NSData *sellTokenId;
    NSData *buyTokenId;
    NSData *prev;
    NSData *next;
    int64_t createTime;
    int64_t sellTokenQuantity;
    int64_t buyTokenQuantity;
    int64_t sellTokenQuantityRemain;
    int64_t sellTokenQuantityReturn;
} MarketOrder__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "orderId",
                .dataTypeSpecific.clazz = Nil,
                .number = MarketOrder_FieldNumber_OrderId,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(MarketOrder__storage_, orderId),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "ownerAddress",
                .dataTypeSpecific.clazz = Nil,
                .number = MarketOrder_FieldNumber_OwnerAddress,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(MarketOrder__storage_, ownerAddress),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "createTime",
                .dataTypeSpecific.clazz = Nil,
                .number = MarketOrder_FieldNumber_CreateTime,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(MarketOrder__storage_, createTime),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "sellTokenId",
                .dataTypeSpecific.clazz = Nil,
                .number = MarketOrder_FieldNumber_SellTokenId,
                .hasIndex = 3,
                .offset = (uint32_t)offsetof(MarketOrder__storage_, sellTokenId),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "sellTokenQuantity",
                .dataTypeSpecific.clazz = Nil,
                .number = MarketOrder_FieldNumber_SellTokenQuantity,
                .hasIndex = 4,
                .offset = (uint32_t)offsetof(MarketOrder__storage_, sellTokenQuantity),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "buyTokenId",
                .dataTypeSpecific.clazz = Nil,
                .number = MarketOrder_FieldNumber_BuyTokenId,
                .hasIndex = 5,
                .offset = (uint32_t)offsetof(MarketOrder__storage_, buyTokenId),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "buyTokenQuantity",
                .dataTypeSpecific.clazz = Nil,
                .number = MarketOrder_FieldNumber_BuyTokenQuantity,
                .hasIndex = 6,
                .offset = (uint32_t)offsetof(MarketOrder__storage_, buyTokenQuantity),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "sellTokenQuantityRemain",
                .dataTypeSpecific.clazz = Nil,
                .number = MarketOrder_FieldNumber_SellTokenQuantityRemain,
                .hasIndex = 7,
                .offset = (uint32_t)offsetof(MarketOrder__storage_, sellTokenQuantityRemain),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "sellTokenQuantityReturn",
                .dataTypeSpecific.clazz = Nil,
                .number = MarketOrder_FieldNumber_SellTokenQuantityReturn,
                .hasIndex = 8,
                .offset = (uint32_t)offsetof(MarketOrder__storage_, sellTokenQuantityReturn),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "state",
                .dataTypeSpecific.enumDescFunc = MarketOrder_State_EnumDescriptor,
                .number = MarketOrder_FieldNumber_State,
                .hasIndex = 9,
                .offset = (uint32_t)offsetof(MarketOrder__storage_, state),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeEnum,
            },
            {
                .name = "prev",
                .dataTypeSpecific.clazz = Nil,
                .number = MarketOrder_FieldNumber_Prev,
                .hasIndex = 10,
                .offset = (uint32_t)offsetof(MarketOrder__storage_, prev),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "next",
                .dataTypeSpecific.clazz = Nil,
                .number = MarketOrder_FieldNumber_Next,
                .hasIndex = 11,
                .offset = (uint32_t)offsetof(MarketOrder__storage_, next),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(MarketOrder)
                                   messageName:@"MarketOrder"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MarketOrder__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

int32_t MarketOrder_State_RawValue(MarketOrder *message) {
    GPBDescriptor *descriptor = [MarketOrder descriptor];
    GPBFieldDescriptor *field = [descriptor fieldWithNumber:MarketOrder_FieldNumber_State];
    return GPBGetMessageRawEnumField(message, field);
}

void SetMarketOrder_State_RawValue(MarketOrder *message, int32_t value) {
    GPBDescriptor *descriptor = [MarketOrder descriptor];
    GPBFieldDescriptor *field = [descriptor fieldWithNumber:MarketOrder_FieldNumber_State];
    GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - MarketOrderList

@implementation MarketOrderList

@dynamic ordersArray, ordersArray_Count;

typedef struct MarketOrderList__storage_ {
    uint32_t _has_storage_[1];
    NSMutableArray *ordersArray;
} MarketOrderList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "ordersArray",
                .dataTypeSpecific.clazz = GPBObjCClass(MarketOrder),
                .number = MarketOrderList_FieldNumber_OrdersArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(MarketOrderList__storage_, ordersArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeMessage,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(MarketOrderList)
                                   messageName:@"MarketOrderList"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MarketOrderList__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - MarketOrderPairList

@implementation MarketOrderPairList

@dynamic orderPairArray, orderPairArray_Count;

typedef struct MarketOrderPairList__storage_ {
    uint32_t _has_storage_[1];
    NSMutableArray *orderPairArray;
} MarketOrderPairList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "orderPairArray",
                .dataTypeSpecific.clazz = GPBObjCClass(MarketOrderPair),
                .number = MarketOrderPairList_FieldNumber_OrderPairArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(MarketOrderPairList__storage_, orderPairArray),
                .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
                .dataType = GPBDataTypeMessage,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(MarketOrderPairList)
                                   messageName:@"MarketOrderPairList"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MarketOrderPairList__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        static const char *extraTextFormatInfo =
        "\001\001\000orderPair\000";
        [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - MarketOrderPair

@implementation MarketOrderPair

@dynamic sellTokenId;
@dynamic buyTokenId;

typedef struct MarketOrderPair__storage_ {
    uint32_t _has_storage_[1];
    NSData *sellTokenId;
    NSData *buyTokenId;
} MarketOrderPair__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "sellTokenId",
                .dataTypeSpecific.clazz = Nil,
                .number = MarketOrderPair_FieldNumber_SellTokenId,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(MarketOrderPair__storage_, sellTokenId),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "buyTokenId",
                .dataTypeSpecific.clazz = Nil,
                .number = MarketOrderPair_FieldNumber_BuyTokenId,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(MarketOrderPair__storage_, buyTokenId),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(MarketOrderPair)
                                   messageName:@"MarketOrderPair"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MarketOrderPair__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - MarketAccountOrder

@implementation MarketAccountOrder

@dynamic ownerAddress;
@dynamic ordersArray, ordersArray_Count;
@dynamic count;
@dynamic totalCount;

typedef struct MarketAccountOrder__storage_ {
    uint32_t _has_storage_[1];
    NSData *ownerAddress;
    NSMutableArray *ordersArray;
    int64_t count;
    int64_t totalCount;
} MarketAccountOrder__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "ownerAddress",
                .dataTypeSpecific.clazz = Nil,
                .number = MarketAccountOrder_FieldNumber_OwnerAddress,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(MarketAccountOrder__storage_, ownerAddress),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "ordersArray",
                .dataTypeSpecific.clazz = Nil,
                .number = MarketAccountOrder_FieldNumber_OrdersArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(MarketAccountOrder__storage_, ordersArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "count",
                .dataTypeSpecific.clazz = Nil,
                .number = MarketAccountOrder_FieldNumber_Count,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(MarketAccountOrder__storage_, count),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "totalCount",
                .dataTypeSpecific.clazz = Nil,
                .number = MarketAccountOrder_FieldNumber_TotalCount,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(MarketAccountOrder__storage_, totalCount),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(MarketAccountOrder)
                                   messageName:@"MarketAccountOrder"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MarketAccountOrder__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - MarketPrice

@implementation MarketPrice

@dynamic sellTokenQuantity;
@dynamic buyTokenQuantity;

typedef struct MarketPrice__storage_ {
    uint32_t _has_storage_[1];
    int64_t sellTokenQuantity;
    int64_t buyTokenQuantity;
} MarketPrice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "sellTokenQuantity",
                .dataTypeSpecific.clazz = Nil,
                .number = MarketPrice_FieldNumber_SellTokenQuantity,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(MarketPrice__storage_, sellTokenQuantity),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "buyTokenQuantity",
                .dataTypeSpecific.clazz = Nil,
                .number = MarketPrice_FieldNumber_BuyTokenQuantity,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(MarketPrice__storage_, buyTokenQuantity),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(MarketPrice)
                                   messageName:@"MarketPrice"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MarketPrice__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - MarketPriceList

@implementation MarketPriceList

@dynamic sellTokenId;
@dynamic buyTokenId;
@dynamic pricesArray, pricesArray_Count;

typedef struct MarketPriceList__storage_ {
    uint32_t _has_storage_[1];
    NSData *sellTokenId;
    NSData *buyTokenId;
    NSMutableArray *pricesArray;
} MarketPriceList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "sellTokenId",
                .dataTypeSpecific.clazz = Nil,
                .number = MarketPriceList_FieldNumber_SellTokenId,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(MarketPriceList__storage_, sellTokenId),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "buyTokenId",
                .dataTypeSpecific.clazz = Nil,
                .number = MarketPriceList_FieldNumber_BuyTokenId,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(MarketPriceList__storage_, buyTokenId),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "pricesArray",
                .dataTypeSpecific.clazz = GPBObjCClass(MarketPrice),
                .number = MarketPriceList_FieldNumber_PricesArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(MarketPriceList__storage_, pricesArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeMessage,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(MarketPriceList)
                                   messageName:@"MarketPriceList"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MarketPriceList__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - MarketOrderIdList

@implementation MarketOrderIdList

@dynamic head;
@dynamic tail;

typedef struct MarketOrderIdList__storage_ {
    uint32_t _has_storage_[1];
    NSData *head;
    NSData *tail;
} MarketOrderIdList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "head",
                .dataTypeSpecific.clazz = Nil,
                .number = MarketOrderIdList_FieldNumber_Head,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(MarketOrderIdList__storage_, head),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "tail",
                .dataTypeSpecific.clazz = Nil,
                .number = MarketOrderIdList_FieldNumber_Tail,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(MarketOrderIdList__storage_, tail),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(MarketOrderIdList)
                                   messageName:@"MarketOrderIdList"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MarketOrderIdList__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - ChainParameters

@implementation ChainParameters

@dynamic chainParameterArray, chainParameterArray_Count;

typedef struct ChainParameters__storage_ {
    uint32_t _has_storage_[1];
    NSMutableArray *chainParameterArray;
} ChainParameters__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "chainParameterArray",
                .dataTypeSpecific.clazz = GPBObjCClass(ChainParameters_ChainParameter),
                .number = ChainParameters_FieldNumber_ChainParameterArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(ChainParameters__storage_, chainParameterArray),
                .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
                .dataType = GPBDataTypeMessage,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ChainParameters)
                                   messageName:@"ChainParameters"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChainParameters__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        static const char *extraTextFormatInfo =
        "\001\001\000chainParameter\000";
        [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - ChainParameters_ChainParameter

@implementation ChainParameters_ChainParameter

@dynamic key;
@dynamic value;

typedef struct ChainParameters_ChainParameter__storage_ {
    uint32_t _has_storage_[1];
    NSString *key;
    int64_t value;
} ChainParameters_ChainParameter__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "key",
                .dataTypeSpecific.clazz = Nil,
                .number = ChainParameters_ChainParameter_FieldNumber_Key,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(ChainParameters_ChainParameter__storage_, key),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeString,
            },
            {
                .name = "value",
                .dataTypeSpecific.clazz = Nil,
                .number = ChainParameters_ChainParameter_FieldNumber_Value,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(ChainParameters_ChainParameter__storage_, value),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ChainParameters_ChainParameter)
                                   messageName:@"ChainParameter"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChainParameters_ChainParameter__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
        [localDescriptor setupContainingMessageClass:GPBObjCClass(ChainParameters)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - Account

@implementation TronAccount

@dynamic accountName;
@dynamic type;
@dynamic address;
@dynamic balance;
@dynamic votesArray, votesArray_Count;
@dynamic asset, asset_Count;
@dynamic assetV2, assetV2_Count;
@dynamic frozenArray, frozenArray_Count;
@dynamic netUsage;
@dynamic acquiredDelegatedFrozenBalanceForBandwidth;
@dynamic delegatedFrozenBalanceForBandwidth;
@dynamic oldTronPower;
@dynamic hasTronPower, tronPower;
@dynamic assetOptimized;
@dynamic createTime;
@dynamic latestOprationTime;
@dynamic allowance;
@dynamic latestWithdrawTime;
@dynamic code;
@dynamic isWitness;
@dynamic isCommittee;
@dynamic frozenSupplyArray, frozenSupplyArray_Count;
@dynamic assetIssuedName;
@dynamic assetIssuedId;
@dynamic latestAssetOperationTime, latestAssetOperationTime_Count;
@dynamic latestAssetOperationTimeV2, latestAssetOperationTimeV2_Count;
@dynamic freeNetUsage;
@dynamic freeAssetNetUsage, freeAssetNetUsage_Count;
@dynamic freeAssetNetUsageV2, freeAssetNetUsageV2_Count;
@dynamic latestConsumeTime;
@dynamic latestConsumeFreeTime;
@dynamic accountId;
@dynamic netWindowSize;
@dynamic netWindowOptimized;
@dynamic hasAccountResource, accountResource;
@dynamic codeHash;
@dynamic hasOwnerPermission, ownerPermission;
@dynamic hasWitnessPermission, witnessPermission;
@dynamic activePermissionArray, activePermissionArray_Count;
@dynamic frozenV2Array, frozenV2Array_Count;
@dynamic unfrozenV2Array, unfrozenV2Array_Count;
@dynamic delegatedFrozenV2BalanceForBandwidth;
@dynamic acquiredDelegatedFrozenV2BalanceForBandwidth;

typedef struct Account__storage_ {
    uint32_t _has_storage_[2];
    AccountType type;
    NSData *accountName;
    NSData *address;
    NSMutableArray *votesArray;
    GPBStringInt64Dictionary *asset;
    NSMutableArray *frozenArray;
    NSData *code;
    NSMutableArray *frozenSupplyArray;
    NSData *assetIssuedName;
    GPBStringInt64Dictionary *latestAssetOperationTime;
    GPBStringInt64Dictionary *freeAssetNetUsage;
    NSData *accountId;
    Account_AccountResource *accountResource;
    NSData *codeHash;
    Permission *ownerPermission;
    Permission *witnessPermission;
    NSMutableArray *activePermissionArray;
    NSMutableArray *frozenV2Array;
    NSMutableArray *unfrozenV2Array;
    Account_Frozen *tronPower;
    GPBStringInt64Dictionary *assetV2;
    NSData *assetIssuedId;
    GPBStringInt64Dictionary *latestAssetOperationTimeV2;
    GPBStringInt64Dictionary *freeAssetNetUsageV2;
    int64_t balance;
    int64_t netUsage;
    int64_t createTime;
    int64_t latestOprationTime;
    int64_t allowance;
    int64_t latestWithdrawTime;
    int64_t freeNetUsage;
    int64_t latestConsumeTime;
    int64_t latestConsumeFreeTime;
    int64_t netWindowSize;
    int64_t delegatedFrozenV2BalanceForBandwidth;
    int64_t acquiredDelegatedFrozenV2BalanceForBandwidth;
    int64_t acquiredDelegatedFrozenBalanceForBandwidth;
    int64_t delegatedFrozenBalanceForBandwidth;
    int64_t oldTronPower;
} Account__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "accountName",
                .dataTypeSpecific.clazz = Nil,
                .number = Account_FieldNumber_AccountName,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(Account__storage_, accountName),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "type",
                .dataTypeSpecific.enumDescFunc = AccountType_EnumDescriptor,
                .number = Account_FieldNumber_Type,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(Account__storage_, type),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeEnum,
            },
            {
                .name = "address",
                .dataTypeSpecific.clazz = Nil,
                .number = Account_FieldNumber_Address,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(Account__storage_, address),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "balance",
                .dataTypeSpecific.clazz = Nil,
                .number = Account_FieldNumber_Balance,
                .hasIndex = 3,
                .offset = (uint32_t)offsetof(Account__storage_, balance),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "votesArray",
                .dataTypeSpecific.clazz = GPBObjCClass(Vote),
                .number = Account_FieldNumber_VotesArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(Account__storage_, votesArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "asset",
                .dataTypeSpecific.clazz = Nil,
                .number = Account_FieldNumber_Asset,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(Account__storage_, asset),
                .flags = GPBFieldMapKeyString,
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "frozenArray",
                .dataTypeSpecific.clazz = GPBObjCClass(Account_Frozen),
                .number = Account_FieldNumber_FrozenArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(Account__storage_, frozenArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "netUsage",
                .dataTypeSpecific.clazz = Nil,
                .number = Account_FieldNumber_NetUsage,
                .hasIndex = 4,
                .offset = (uint32_t)offsetof(Account__storage_, netUsage),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "createTime",
                .dataTypeSpecific.clazz = Nil,
                .number = Account_FieldNumber_CreateTime,
                .hasIndex = 11,
                .offset = (uint32_t)offsetof(Account__storage_, createTime),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "latestOprationTime",
                .dataTypeSpecific.clazz = Nil,
                .number = Account_FieldNumber_LatestOprationTime,
                .hasIndex = 12,
                .offset = (uint32_t)offsetof(Account__storage_, latestOprationTime),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "allowance",
                .dataTypeSpecific.clazz = Nil,
                .number = Account_FieldNumber_Allowance,
                .hasIndex = 13,
                .offset = (uint32_t)offsetof(Account__storage_, allowance),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "latestWithdrawTime",
                .dataTypeSpecific.clazz = Nil,
                .number = Account_FieldNumber_LatestWithdrawTime,
                .hasIndex = 14,
                .offset = (uint32_t)offsetof(Account__storage_, latestWithdrawTime),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "code",
                .dataTypeSpecific.clazz = Nil,
                .number = Account_FieldNumber_Code,
                .hasIndex = 15,
                .offset = (uint32_t)offsetof(Account__storage_, code),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "isWitness",
                .dataTypeSpecific.clazz = Nil,
                .number = Account_FieldNumber_IsWitness,
                .hasIndex = 16,
                .offset = 17,  // Stored in _has_storage_ to save space.
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBool,
            },
            {
                .name = "isCommittee",
                .dataTypeSpecific.clazz = Nil,
                .number = Account_FieldNumber_IsCommittee,
                .hasIndex = 18,
                .offset = 19,  // Stored in _has_storage_ to save space.
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBool,
            },
            {
                .name = "frozenSupplyArray",
                .dataTypeSpecific.clazz = GPBObjCClass(Account_Frozen),
                .number = Account_FieldNumber_FrozenSupplyArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(Account__storage_, frozenSupplyArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "assetIssuedName",
                .dataTypeSpecific.clazz = Nil,
                .number = Account_FieldNumber_AssetIssuedName,
                .hasIndex = 20,
                .offset = (uint32_t)offsetof(Account__storage_, assetIssuedName),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "latestAssetOperationTime",
                .dataTypeSpecific.clazz = Nil,
                .number = Account_FieldNumber_LatestAssetOperationTime,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(Account__storage_, latestAssetOperationTime),
                .flags = GPBFieldMapKeyString,
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "freeNetUsage",
                .dataTypeSpecific.clazz = Nil,
                .number = Account_FieldNumber_FreeNetUsage,
                .hasIndex = 22,
                .offset = (uint32_t)offsetof(Account__storage_, freeNetUsage),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "freeAssetNetUsage",
                .dataTypeSpecific.clazz = Nil,
                .number = Account_FieldNumber_FreeAssetNetUsage,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(Account__storage_, freeAssetNetUsage),
                .flags = GPBFieldMapKeyString,
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "latestConsumeTime",
                .dataTypeSpecific.clazz = Nil,
                .number = Account_FieldNumber_LatestConsumeTime,
                .hasIndex = 23,
                .offset = (uint32_t)offsetof(Account__storage_, latestConsumeTime),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "latestConsumeFreeTime",
                .dataTypeSpecific.clazz = Nil,
                .number = Account_FieldNumber_LatestConsumeFreeTime,
                .hasIndex = 24,
                .offset = (uint32_t)offsetof(Account__storage_, latestConsumeFreeTime),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "accountId",
                .dataTypeSpecific.clazz = Nil,
                .number = Account_FieldNumber_AccountId,
                .hasIndex = 25,
                .offset = (uint32_t)offsetof(Account__storage_, accountId),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "netWindowSize",
                .dataTypeSpecific.clazz = Nil,
                .number = Account_FieldNumber_NetWindowSize,
                .hasIndex = 26,
                .offset = (uint32_t)offsetof(Account__storage_, netWindowSize),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "netWindowOptimized",
                .dataTypeSpecific.clazz = Nil,
                .number = Account_FieldNumber_NetWindowOptimized,
                .hasIndex = 27,
                .offset = 28,  // Stored in _has_storage_ to save space.
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBool,
            },
            {
                .name = "accountResource",
                .dataTypeSpecific.clazz = GPBObjCClass(Account_AccountResource),
                .number = Account_FieldNumber_AccountResource,
                .hasIndex = 29,
                .offset = (uint32_t)offsetof(Account__storage_, accountResource),
                .flags = GPBFieldOptional,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "codeHash",
                .dataTypeSpecific.clazz = Nil,
                .number = Account_FieldNumber_CodeHash,
                .hasIndex = 30,
                .offset = (uint32_t)offsetof(Account__storage_, codeHash),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "ownerPermission",
                .dataTypeSpecific.clazz = GPBObjCClass(Permission),
                .number = Account_FieldNumber_OwnerPermission,
                .hasIndex = 31,
                .offset = (uint32_t)offsetof(Account__storage_, ownerPermission),
                .flags = GPBFieldOptional,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "witnessPermission",
                .dataTypeSpecific.clazz = GPBObjCClass(Permission),
                .number = Account_FieldNumber_WitnessPermission,
                .hasIndex = 32,
                .offset = (uint32_t)offsetof(Account__storage_, witnessPermission),
                .flags = GPBFieldOptional,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "activePermissionArray",
                .dataTypeSpecific.clazz = GPBObjCClass(Permission),
                .number = Account_FieldNumber_ActivePermissionArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(Account__storage_, activePermissionArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "frozenV2Array",
                .dataTypeSpecific.clazz = GPBObjCClass(Account_FreezeV2),
                .number = Account_FieldNumber_FrozenV2Array,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(Account__storage_, frozenV2Array),
                .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "unfrozenV2Array",
                .dataTypeSpecific.clazz = GPBObjCClass(Account_UnFreezeV2),
                .number = Account_FieldNumber_UnfrozenV2Array,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(Account__storage_, unfrozenV2Array),
                .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "delegatedFrozenV2BalanceForBandwidth",
                .dataTypeSpecific.clazz = Nil,
                .number = Account_FieldNumber_DelegatedFrozenV2BalanceForBandwidth,
                .hasIndex = 33,
                .offset = (uint32_t)offsetof(Account__storage_, delegatedFrozenV2BalanceForBandwidth),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "acquiredDelegatedFrozenV2BalanceForBandwidth",
                .dataTypeSpecific.clazz = Nil,
                .number = Account_FieldNumber_AcquiredDelegatedFrozenV2BalanceForBandwidth,
                .hasIndex = 34,
                .offset = (uint32_t)offsetof(Account__storage_, acquiredDelegatedFrozenV2BalanceForBandwidth),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "acquiredDelegatedFrozenBalanceForBandwidth",
                .dataTypeSpecific.clazz = Nil,
                .number = Account_FieldNumber_AcquiredDelegatedFrozenBalanceForBandwidth,
                .hasIndex = 5,
                .offset = (uint32_t)offsetof(Account__storage_, acquiredDelegatedFrozenBalanceForBandwidth),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "delegatedFrozenBalanceForBandwidth",
                .dataTypeSpecific.clazz = Nil,
                .number = Account_FieldNumber_DelegatedFrozenBalanceForBandwidth,
                .hasIndex = 6,
                .offset = (uint32_t)offsetof(Account__storage_, delegatedFrozenBalanceForBandwidth),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "oldTronPower",
                .dataTypeSpecific.clazz = Nil,
                .number = Account_FieldNumber_OldTronPower,
                .hasIndex = 7,
                .offset = (uint32_t)offsetof(Account__storage_, oldTronPower),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "tronPower",
                .dataTypeSpecific.clazz = GPBObjCClass(Account_Frozen),
                .number = Account_FieldNumber_TronPower,
                .hasIndex = 8,
                .offset = (uint32_t)offsetof(Account__storage_, tronPower),
                .flags = GPBFieldOptional,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "assetV2",
                .dataTypeSpecific.clazz = Nil,
                .number = Account_FieldNumber_AssetV2,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(Account__storage_, assetV2),
                .flags = (GPBFieldFlags)(GPBFieldMapKeyString | GPBFieldTextFormatNameCustom),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "assetIssuedId",
                .dataTypeSpecific.clazz = Nil,
                .number = Account_FieldNumber_AssetIssuedId,
                .hasIndex = 21,
                .offset = (uint32_t)offsetof(Account__storage_, assetIssuedId),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "latestAssetOperationTimeV2",
                .dataTypeSpecific.clazz = Nil,
                .number = Account_FieldNumber_LatestAssetOperationTimeV2,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(Account__storage_, latestAssetOperationTimeV2),
                .flags = (GPBFieldFlags)(GPBFieldMapKeyString | GPBFieldTextFormatNameCustom),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "freeAssetNetUsageV2",
                .dataTypeSpecific.clazz = Nil,
                .number = Account_FieldNumber_FreeAssetNetUsageV2,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(Account__storage_, freeAssetNetUsageV2),
                .flags = (GPBFieldFlags)(GPBFieldMapKeyString | GPBFieldTextFormatNameCustom),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "assetOptimized",
                .dataTypeSpecific.clazz = Nil,
                .number = Account_FieldNumber_AssetOptimized,
                .hasIndex = 9,
                .offset = 10,  // Stored in _has_storage_ to save space.
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBool,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(TronAccount)
                                   messageName:@"Account"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Account__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        static const char *extraTextFormatInfo =
        "\t\036\010\000\"\000frozenV2\000#\000unfrozenV2\000$\t\250\247\243\251\000%\010\251\250\247"
        "\243\251\0008\007\0009\005\246\342\000:\006\245\251\246\000;\004\245\243\247\000";
        [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

int32_t Account_Type_RawValue(TronAccount *message) {
    GPBDescriptor *descriptor = [TronAccount descriptor];
    GPBFieldDescriptor *field = [descriptor fieldWithNumber:Account_FieldNumber_Type];
    return GPBGetMessageRawEnumField(message, field);
}

void SetAccount_Type_RawValue(TronAccount *message, int32_t value) {
    GPBDescriptor *descriptor = [TronAccount descriptor];
    GPBFieldDescriptor *field = [descriptor fieldWithNumber:Account_FieldNumber_Type];
    GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Account_Frozen

@implementation Account_Frozen

@dynamic frozenBalance;
@dynamic expireTime;

typedef struct Account_Frozen__storage_ {
    uint32_t _has_storage_[1];
    int64_t frozenBalance;
    int64_t expireTime;
} Account_Frozen__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "frozenBalance",
                .dataTypeSpecific.clazz = Nil,
                .number = Account_Frozen_FieldNumber_FrozenBalance,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(Account_Frozen__storage_, frozenBalance),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "expireTime",
                .dataTypeSpecific.clazz = Nil,
                .number = Account_Frozen_FieldNumber_ExpireTime,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(Account_Frozen__storage_, expireTime),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Account_Frozen)
                                   messageName:@"Frozen"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Account_Frozen__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
        [localDescriptor setupContainingMessageClass:GPBObjCClass(TronAccount)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - Account_AccountResource

@implementation Account_AccountResource

@dynamic energyUsage;
@dynamic hasFrozenBalanceForEnergy, frozenBalanceForEnergy;
@dynamic latestConsumeTimeForEnergy;
@dynamic acquiredDelegatedFrozenBalanceForEnergy;
@dynamic delegatedFrozenBalanceForEnergy;
@dynamic storageLimit;
@dynamic storageUsage;
@dynamic latestExchangeStorageTime;
@dynamic energyWindowSize;
@dynamic delegatedFrozenV2BalanceForEnergy;
@dynamic acquiredDelegatedFrozenV2BalanceForEnergy;
@dynamic energyWindowOptimized;

typedef struct Account_AccountResource__storage_ {
    uint32_t _has_storage_[1];
    Account_Frozen *frozenBalanceForEnergy;
    int64_t energyUsage;
    int64_t latestConsumeTimeForEnergy;
    int64_t acquiredDelegatedFrozenBalanceForEnergy;
    int64_t delegatedFrozenBalanceForEnergy;
    int64_t storageLimit;
    int64_t storageUsage;
    int64_t latestExchangeStorageTime;
    int64_t energyWindowSize;
    int64_t delegatedFrozenV2BalanceForEnergy;
    int64_t acquiredDelegatedFrozenV2BalanceForEnergy;
} Account_AccountResource__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "energyUsage",
                .dataTypeSpecific.clazz = Nil,
                .number = Account_AccountResource_FieldNumber_EnergyUsage,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(Account_AccountResource__storage_, energyUsage),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "frozenBalanceForEnergy",
                .dataTypeSpecific.clazz = GPBObjCClass(Account_Frozen),
                .number = Account_AccountResource_FieldNumber_FrozenBalanceForEnergy,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(Account_AccountResource__storage_, frozenBalanceForEnergy),
                .flags = GPBFieldOptional,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "latestConsumeTimeForEnergy",
                .dataTypeSpecific.clazz = Nil,
                .number = Account_AccountResource_FieldNumber_LatestConsumeTimeForEnergy,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(Account_AccountResource__storage_, latestConsumeTimeForEnergy),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "acquiredDelegatedFrozenBalanceForEnergy",
                .dataTypeSpecific.clazz = Nil,
                .number = Account_AccountResource_FieldNumber_AcquiredDelegatedFrozenBalanceForEnergy,
                .hasIndex = 3,
                .offset = (uint32_t)offsetof(Account_AccountResource__storage_, acquiredDelegatedFrozenBalanceForEnergy),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "delegatedFrozenBalanceForEnergy",
                .dataTypeSpecific.clazz = Nil,
                .number = Account_AccountResource_FieldNumber_DelegatedFrozenBalanceForEnergy,
                .hasIndex = 4,
                .offset = (uint32_t)offsetof(Account_AccountResource__storage_, delegatedFrozenBalanceForEnergy),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "storageLimit",
                .dataTypeSpecific.clazz = Nil,
                .number = Account_AccountResource_FieldNumber_StorageLimit,
                .hasIndex = 5,
                .offset = (uint32_t)offsetof(Account_AccountResource__storage_, storageLimit),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "storageUsage",
                .dataTypeSpecific.clazz = Nil,
                .number = Account_AccountResource_FieldNumber_StorageUsage,
                .hasIndex = 6,
                .offset = (uint32_t)offsetof(Account_AccountResource__storage_, storageUsage),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "latestExchangeStorageTime",
                .dataTypeSpecific.clazz = Nil,
                .number = Account_AccountResource_FieldNumber_LatestExchangeStorageTime,
                .hasIndex = 7,
                .offset = (uint32_t)offsetof(Account_AccountResource__storage_, latestExchangeStorageTime),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "energyWindowSize",
                .dataTypeSpecific.clazz = Nil,
                .number = Account_AccountResource_FieldNumber_EnergyWindowSize,
                .hasIndex = 8,
                .offset = (uint32_t)offsetof(Account_AccountResource__storage_, energyWindowSize),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "delegatedFrozenV2BalanceForEnergy",
                .dataTypeSpecific.clazz = Nil,
                .number = Account_AccountResource_FieldNumber_DelegatedFrozenV2BalanceForEnergy,
                .hasIndex = 9,
                .offset = (uint32_t)offsetof(Account_AccountResource__storage_, delegatedFrozenV2BalanceForEnergy),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "acquiredDelegatedFrozenV2BalanceForEnergy",
                .dataTypeSpecific.clazz = Nil,
                .number = Account_AccountResource_FieldNumber_AcquiredDelegatedFrozenV2BalanceForEnergy,
                .hasIndex = 10,
                .offset = (uint32_t)offsetof(Account_AccountResource__storage_, acquiredDelegatedFrozenV2BalanceForEnergy),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "energyWindowOptimized",
                .dataTypeSpecific.clazz = Nil,
                .number = Account_AccountResource_FieldNumber_EnergyWindowOptimized,
                .hasIndex = 11,
                .offset = 12,  // Stored in _has_storage_ to save space.
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBool,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Account_AccountResource)
                                   messageName:@"AccountResource"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Account_AccountResource__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        static const char *extraTextFormatInfo =
        "\002\n\t\250\247\243\246\000\013\010\251\250\247\243\246\000";
        [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        [localDescriptor setupContainingMessageClass:GPBObjCClass(TronAccount)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - Account_FreezeV2

@implementation Account_FreezeV2

@dynamic type;
@dynamic amount;

typedef struct Account_FreezeV2__storage_ {
    uint32_t _has_storage_[1];
    ResourceCode type;
    int64_t amount;
} Account_FreezeV2__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "type",
                .dataTypeSpecific.enumDescFunc = ResourceCode_EnumDescriptor,
                .number = Account_FreezeV2_FieldNumber_Type,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(Account_FreezeV2__storage_, type),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeEnum,
            },
            {
                .name = "amount",
                .dataTypeSpecific.clazz = Nil,
                .number = Account_FreezeV2_FieldNumber_Amount,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(Account_FreezeV2__storage_, amount),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Account_FreezeV2)
                                   messageName:@"FreezeV2"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Account_FreezeV2__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
        [localDescriptor setupContainingMessageClass:GPBObjCClass(TronAccount)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

int32_t Account_FreezeV2_Type_RawValue(Account_FreezeV2 *message) {
    GPBDescriptor *descriptor = [Account_FreezeV2 descriptor];
    GPBFieldDescriptor *field = [descriptor fieldWithNumber:Account_FreezeV2_FieldNumber_Type];
    return GPBGetMessageRawEnumField(message, field);
}

void SetAccount_FreezeV2_Type_RawValue(Account_FreezeV2 *message, int32_t value) {
    GPBDescriptor *descriptor = [Account_FreezeV2 descriptor];
    GPBFieldDescriptor *field = [descriptor fieldWithNumber:Account_FreezeV2_FieldNumber_Type];
    GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Account_UnFreezeV2

@implementation Account_UnFreezeV2

@dynamic type;
@dynamic unfreezeAmount;
@dynamic unfreezeExpireTime;

typedef struct Account_UnFreezeV2__storage_ {
    uint32_t _has_storage_[1];
    ResourceCode type;
    int64_t unfreezeAmount;
    int64_t unfreezeExpireTime;
} Account_UnFreezeV2__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "type",
                .dataTypeSpecific.enumDescFunc = ResourceCode_EnumDescriptor,
                .number = Account_UnFreezeV2_FieldNumber_Type,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(Account_UnFreezeV2__storage_, type),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeEnum,
            },
            {
                .name = "unfreezeAmount",
                .dataTypeSpecific.clazz = Nil,
                .number = Account_UnFreezeV2_FieldNumber_UnfreezeAmount,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(Account_UnFreezeV2__storage_, unfreezeAmount),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "unfreezeExpireTime",
                .dataTypeSpecific.clazz = Nil,
                .number = Account_UnFreezeV2_FieldNumber_UnfreezeExpireTime,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(Account_UnFreezeV2__storage_, unfreezeExpireTime),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Account_UnFreezeV2)
                                   messageName:@"UnFreezeV2"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Account_UnFreezeV2__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
        [localDescriptor setupContainingMessageClass:GPBObjCClass(TronAccount)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

int32_t Account_UnFreezeV2_Type_RawValue(Account_UnFreezeV2 *message) {
    GPBDescriptor *descriptor = [Account_UnFreezeV2 descriptor];
    GPBFieldDescriptor *field = [descriptor fieldWithNumber:Account_UnFreezeV2_FieldNumber_Type];
    return GPBGetMessageRawEnumField(message, field);
}

void SetAccount_UnFreezeV2_Type_RawValue(Account_UnFreezeV2 *message, int32_t value) {
    GPBDescriptor *descriptor = [Account_UnFreezeV2 descriptor];
    GPBFieldDescriptor *field = [descriptor fieldWithNumber:Account_UnFreezeV2_FieldNumber_Type];
    GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Key

@implementation Key

@dynamic address;
@dynamic weight;

typedef struct Key__storage_ {
    uint32_t _has_storage_[1];
    NSData *address;
    int64_t weight;
} Key__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "address",
                .dataTypeSpecific.clazz = Nil,
                .number = Key_FieldNumber_Address,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(Key__storage_, address),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "weight",
                .dataTypeSpecific.clazz = Nil,
                .number = Key_FieldNumber_Weight,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(Key__storage_, weight),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Key)
                                   messageName:@"Key"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Key__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - DelegatedResource

@implementation DelegatedResource

@dynamic from;
@dynamic to;
@dynamic frozenBalanceForBandwidth;
@dynamic frozenBalanceForEnergy;
@dynamic expireTimeForBandwidth;
@dynamic expireTimeForEnergy;

typedef struct DelegatedResource__storage_ {
    uint32_t _has_storage_[1];
    NSData *from;
    NSData *to;
    int64_t frozenBalanceForBandwidth;
    int64_t frozenBalanceForEnergy;
    int64_t expireTimeForBandwidth;
    int64_t expireTimeForEnergy;
} DelegatedResource__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "from",
                .dataTypeSpecific.clazz = Nil,
                .number = DelegatedResource_FieldNumber_From,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(DelegatedResource__storage_, from),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "to",
                .dataTypeSpecific.clazz = Nil,
                .number = DelegatedResource_FieldNumber_To,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(DelegatedResource__storage_, to),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "frozenBalanceForBandwidth",
                .dataTypeSpecific.clazz = Nil,
                .number = DelegatedResource_FieldNumber_FrozenBalanceForBandwidth,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(DelegatedResource__storage_, frozenBalanceForBandwidth),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "frozenBalanceForEnergy",
                .dataTypeSpecific.clazz = Nil,
                .number = DelegatedResource_FieldNumber_FrozenBalanceForEnergy,
                .hasIndex = 3,
                .offset = (uint32_t)offsetof(DelegatedResource__storage_, frozenBalanceForEnergy),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "expireTimeForBandwidth",
                .dataTypeSpecific.clazz = Nil,
                .number = DelegatedResource_FieldNumber_ExpireTimeForBandwidth,
                .hasIndex = 4,
                .offset = (uint32_t)offsetof(DelegatedResource__storage_, expireTimeForBandwidth),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "expireTimeForEnergy",
                .dataTypeSpecific.clazz = Nil,
                .number = DelegatedResource_FieldNumber_ExpireTimeForEnergy,
                .hasIndex = 5,
                .offset = (uint32_t)offsetof(DelegatedResource__storage_, expireTimeForEnergy),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(DelegatedResource)
                                   messageName:@"DelegatedResource"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DelegatedResource__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - authority

@implementation authority

@dynamic hasAccount, account;
@dynamic permissionName;

typedef struct authority__storage_ {
    uint32_t _has_storage_[1];
    AccountId *account;
    NSData *permissionName;
} authority__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "account",
                .dataTypeSpecific.clazz = GPBObjCClass(AccountId),
                .number = authority_FieldNumber_Account,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(authority__storage_, account),
                .flags = GPBFieldOptional,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "permissionName",
                .dataTypeSpecific.clazz = Nil,
                .number = authority_FieldNumber_PermissionName,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(authority__storage_, permissionName),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(authority)
                                   messageName:@"authority"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(authority__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - Permission

@implementation Permission

@dynamic type;
@dynamic id_p;
@dynamic permissionName;
@dynamic threshold;
@dynamic parentId;
@dynamic operations;
@dynamic keysArray, keysArray_Count;

typedef struct Permission__storage_ {
    uint32_t _has_storage_[1];
    Permission_PermissionType type;
    int32_t id_p;
    int32_t parentId;
    NSString *permissionName;
    NSData *operations;
    NSMutableArray *keysArray;
    int64_t threshold;
} Permission__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "type",
                .dataTypeSpecific.enumDescFunc = Permission_PermissionType_EnumDescriptor,
                .number = Permission_FieldNumber_Type,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(Permission__storage_, type),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeEnum,
            },
            {
                .name = "id_p",
                .dataTypeSpecific.clazz = Nil,
                .number = Permission_FieldNumber_Id_p,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(Permission__storage_, id_p),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
            {
                .name = "permissionName",
                .dataTypeSpecific.clazz = Nil,
                .number = Permission_FieldNumber_PermissionName,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(Permission__storage_, permissionName),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeString,
            },
            {
                .name = "threshold",
                .dataTypeSpecific.clazz = Nil,
                .number = Permission_FieldNumber_Threshold,
                .hasIndex = 3,
                .offset = (uint32_t)offsetof(Permission__storage_, threshold),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "parentId",
                .dataTypeSpecific.clazz = Nil,
                .number = Permission_FieldNumber_ParentId,
                .hasIndex = 4,
                .offset = (uint32_t)offsetof(Permission__storage_, parentId),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
            {
                .name = "operations",
                .dataTypeSpecific.clazz = Nil,
                .number = Permission_FieldNumber_Operations,
                .hasIndex = 5,
                .offset = (uint32_t)offsetof(Permission__storage_, operations),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "keysArray",
                .dataTypeSpecific.clazz = GPBObjCClass(Key),
                .number = Permission_FieldNumber_KeysArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(Permission__storage_, keysArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeMessage,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Permission)
                                   messageName:@"Permission"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Permission__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

int32_t Permission_Type_RawValue(Permission *message) {
    GPBDescriptor *descriptor = [Permission descriptor];
    GPBFieldDescriptor *field = [descriptor fieldWithNumber:Permission_FieldNumber_Type];
    return GPBGetMessageRawEnumField(message, field);
}

void SetPermission_Type_RawValue(Permission *message, int32_t value) {
    GPBDescriptor *descriptor = [Permission descriptor];
    GPBFieldDescriptor *field = [descriptor fieldWithNumber:Permission_FieldNumber_Type];
    GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Witness

@implementation Witness

@dynamic address;
@dynamic voteCount;
@dynamic pubKey;
@dynamic URL;
@dynamic totalProduced;
@dynamic totalMissed;
@dynamic latestBlockNum;
@dynamic latestSlotNum;
@dynamic isJobs;

typedef struct Witness__storage_ {
    uint32_t _has_storage_[1];
    NSData *address;
    NSData *pubKey;
    NSString *URL;
    int64_t voteCount;
    int64_t totalProduced;
    int64_t totalMissed;
    int64_t latestBlockNum;
    int64_t latestSlotNum;
} Witness__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "address",
                .dataTypeSpecific.clazz = Nil,
                .number = Witness_FieldNumber_Address,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(Witness__storage_, address),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "voteCount",
                .dataTypeSpecific.clazz = Nil,
                .number = Witness_FieldNumber_VoteCount,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(Witness__storage_, voteCount),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "pubKey",
                .dataTypeSpecific.clazz = Nil,
                .number = Witness_FieldNumber_PubKey,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(Witness__storage_, pubKey),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "URL",
                .dataTypeSpecific.clazz = Nil,
                .number = Witness_FieldNumber_URL,
                .hasIndex = 3,
                .offset = (uint32_t)offsetof(Witness__storage_, URL),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeString,
            },
            {
                .name = "totalProduced",
                .dataTypeSpecific.clazz = Nil,
                .number = Witness_FieldNumber_TotalProduced,
                .hasIndex = 4,
                .offset = (uint32_t)offsetof(Witness__storage_, totalProduced),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "totalMissed",
                .dataTypeSpecific.clazz = Nil,
                .number = Witness_FieldNumber_TotalMissed,
                .hasIndex = 5,
                .offset = (uint32_t)offsetof(Witness__storage_, totalMissed),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "latestBlockNum",
                .dataTypeSpecific.clazz = Nil,
                .number = Witness_FieldNumber_LatestBlockNum,
                .hasIndex = 6,
                .offset = (uint32_t)offsetof(Witness__storage_, latestBlockNum),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "latestSlotNum",
                .dataTypeSpecific.clazz = Nil,
                .number = Witness_FieldNumber_LatestSlotNum,
                .hasIndex = 7,
                .offset = (uint32_t)offsetof(Witness__storage_, latestSlotNum),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "isJobs",
                .dataTypeSpecific.clazz = Nil,
                .number = Witness_FieldNumber_IsJobs,
                .hasIndex = 8,
                .offset = 9,  // Stored in _has_storage_ to save space.
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBool,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Witness)
                                   messageName:@"Witness"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Witness__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        static const char *extraTextFormatInfo =
        "\010\002\t\000\003\006\000\004!!!\000\005\r\000\006\013\000\007\016\000\010\r\000\t\006\000";
        [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - Votes

@implementation Votes

@dynamic address;
@dynamic oldVotesArray, oldVotesArray_Count;
@dynamic newVotesArray, newVotesArray_Count;

typedef struct Votes__storage_ {
    uint32_t _has_storage_[1];
    NSData *address;
    NSMutableArray *oldVotesArray;
    NSMutableArray *newVotesArray;
} Votes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "address",
                .dataTypeSpecific.clazz = Nil,
                .number = Votes_FieldNumber_Address,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(Votes__storage_, address),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "oldVotesArray",
                .dataTypeSpecific.clazz = GPBObjCClass(Vote),
                .number = Votes_FieldNumber_OldVotesArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(Votes__storage_, oldVotesArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "newVotesArray",
                .dataTypeSpecific.clazz = GPBObjCClass(Vote),
                .number = Votes_FieldNumber_NewVotesArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(Votes__storage_, newVotesArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeMessage,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Votes)
                                   messageName:@"Votes"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Votes__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - TXOutput

@implementation TXOutput

@dynamic value;
@dynamic pubKeyHash;

typedef struct TXOutput__storage_ {
    uint32_t _has_storage_[1];
    NSData *pubKeyHash;
    int64_t value;
} TXOutput__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "value",
                .dataTypeSpecific.clazz = Nil,
                .number = TXOutput_FieldNumber_Value,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(TXOutput__storage_, value),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "pubKeyHash",
                .dataTypeSpecific.clazz = Nil,
                .number = TXOutput_FieldNumber_PubKeyHash,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(TXOutput__storage_, pubKeyHash),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(TXOutput)
                                   messageName:@"TXOutput"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TXOutput__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        static const char *extraTextFormatInfo =
        "\001\002\n\000";
        [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - TXInput

@implementation TXInput

@dynamic hasRawData, rawData;
@dynamic signature;

typedef struct TXInput__storage_ {
    uint32_t _has_storage_[1];
    TXInput_raw *rawData;
    NSData *signature;
} TXInput__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "rawData",
                .dataTypeSpecific.clazz = GPBObjCClass(TXInput_raw),
                .number = TXInput_FieldNumber_RawData,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(TXInput__storage_, rawData),
                .flags = GPBFieldOptional,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "signature",
                .dataTypeSpecific.clazz = Nil,
                .number = TXInput_FieldNumber_Signature,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(TXInput__storage_, signature),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(TXInput)
                                   messageName:@"TXInput"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TXInput__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - TXInput_raw

@implementation TXInput_raw

@dynamic txId;
@dynamic vout;
@dynamic pubKey;

typedef struct TXInput_raw__storage_ {
    uint32_t _has_storage_[1];
    NSData *txId;
    NSData *pubKey;
    int64_t vout;
} TXInput_raw__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "txId",
                .dataTypeSpecific.clazz = Nil,
                .number = TXInput_raw_FieldNumber_TxId,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(TXInput_raw__storage_, txId),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "vout",
                .dataTypeSpecific.clazz = Nil,
                .number = TXInput_raw_FieldNumber_Vout,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(TXInput_raw__storage_, vout),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "pubKey",
                .dataTypeSpecific.clazz = Nil,
                .number = TXInput_raw_FieldNumber_PubKey,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(TXInput_raw__storage_, pubKey),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(TXInput_raw)
                                   messageName:@"raw"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TXInput_raw__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        static const char *extraTextFormatInfo =
        "\002\001\003A\000\003\006\000";
        [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        [localDescriptor setupContainingMessageClass:GPBObjCClass(TXInput)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - TXOutputs

@implementation TXOutputs

@dynamic outputsArray, outputsArray_Count;

typedef struct TXOutputs__storage_ {
    uint32_t _has_storage_[1];
    NSMutableArray *outputsArray;
} TXOutputs__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "outputsArray",
                .dataTypeSpecific.clazz = GPBObjCClass(TXOutput),
                .number = TXOutputs_FieldNumber_OutputsArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(TXOutputs__storage_, outputsArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeMessage,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(TXOutputs)
                                   messageName:@"TXOutputs"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TXOutputs__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - ResourceReceipt

@implementation ResourceReceipt

@dynamic energyUsage;
@dynamic energyFee;
@dynamic originEnergyUsage;
@dynamic energyUsageTotal;
@dynamic netUsage;
@dynamic netFee;
@dynamic result;
@dynamic energyPenaltyTotal;

typedef struct ResourceReceipt__storage_ {
    uint32_t _has_storage_[1];
    Transaction_Result_contractResult result;
    int64_t energyUsage;
    int64_t energyFee;
    int64_t originEnergyUsage;
    int64_t energyUsageTotal;
    int64_t netUsage;
    int64_t netFee;
    int64_t energyPenaltyTotal;
} ResourceReceipt__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "energyUsage",
                .dataTypeSpecific.clazz = Nil,
                .number = ResourceReceipt_FieldNumber_EnergyUsage,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(ResourceReceipt__storage_, energyUsage),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "energyFee",
                .dataTypeSpecific.clazz = Nil,
                .number = ResourceReceipt_FieldNumber_EnergyFee,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(ResourceReceipt__storage_, energyFee),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "originEnergyUsage",
                .dataTypeSpecific.clazz = Nil,
                .number = ResourceReceipt_FieldNumber_OriginEnergyUsage,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(ResourceReceipt__storage_, originEnergyUsage),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "energyUsageTotal",
                .dataTypeSpecific.clazz = Nil,
                .number = ResourceReceipt_FieldNumber_EnergyUsageTotal,
                .hasIndex = 3,
                .offset = (uint32_t)offsetof(ResourceReceipt__storage_, energyUsageTotal),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "netUsage",
                .dataTypeSpecific.clazz = Nil,
                .number = ResourceReceipt_FieldNumber_NetUsage,
                .hasIndex = 4,
                .offset = (uint32_t)offsetof(ResourceReceipt__storage_, netUsage),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "netFee",
                .dataTypeSpecific.clazz = Nil,
                .number = ResourceReceipt_FieldNumber_NetFee,
                .hasIndex = 5,
                .offset = (uint32_t)offsetof(ResourceReceipt__storage_, netFee),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "result",
                .dataTypeSpecific.enumDescFunc = Transaction_Result_contractResult_EnumDescriptor,
                .number = ResourceReceipt_FieldNumber_Result,
                .hasIndex = 6,
                .offset = (uint32_t)offsetof(ResourceReceipt__storage_, result),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeEnum,
            },
            {
                .name = "energyPenaltyTotal",
                .dataTypeSpecific.clazz = Nil,
                .number = ResourceReceipt_FieldNumber_EnergyPenaltyTotal,
                .hasIndex = 7,
                .offset = (uint32_t)offsetof(ResourceReceipt__storage_, energyPenaltyTotal),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ResourceReceipt)
                                   messageName:@"ResourceReceipt"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResourceReceipt__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

int32_t ResourceReceipt_Result_RawValue(ResourceReceipt *message) {
    GPBDescriptor *descriptor = [ResourceReceipt descriptor];
    GPBFieldDescriptor *field = [descriptor fieldWithNumber:ResourceReceipt_FieldNumber_Result];
    return GPBGetMessageRawEnumField(message, field);
}

void SetResourceReceipt_Result_RawValue(ResourceReceipt *message, int32_t value) {
    GPBDescriptor *descriptor = [ResourceReceipt descriptor];
    GPBFieldDescriptor *field = [descriptor fieldWithNumber:ResourceReceipt_FieldNumber_Result];
    GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - MarketOrderDetail

@implementation MarketOrderDetail

@dynamic makerOrderId;
@dynamic takerOrderId;
@dynamic fillSellQuantity;
@dynamic fillBuyQuantity;

typedef struct MarketOrderDetail__storage_ {
    uint32_t _has_storage_[1];
    NSData *makerOrderId;
    NSData *takerOrderId;
    int64_t fillSellQuantity;
    int64_t fillBuyQuantity;
} MarketOrderDetail__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "makerOrderId",
                .dataTypeSpecific.clazz = Nil,
                .number = MarketOrderDetail_FieldNumber_MakerOrderId,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(MarketOrderDetail__storage_, makerOrderId),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "takerOrderId",
                .dataTypeSpecific.clazz = Nil,
                .number = MarketOrderDetail_FieldNumber_TakerOrderId,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(MarketOrderDetail__storage_, takerOrderId),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "fillSellQuantity",
                .dataTypeSpecific.clazz = Nil,
                .number = MarketOrderDetail_FieldNumber_FillSellQuantity,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(MarketOrderDetail__storage_, fillSellQuantity),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "fillBuyQuantity",
                .dataTypeSpecific.clazz = Nil,
                .number = MarketOrderDetail_FieldNumber_FillBuyQuantity,
                .hasIndex = 3,
                .offset = (uint32_t)offsetof(MarketOrderDetail__storage_, fillBuyQuantity),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(MarketOrderDetail)
                                   messageName:@"MarketOrderDetail"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MarketOrderDetail__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        static const char *extraTextFormatInfo =
        "\004\001\014\000\002\014\000\003\020\000\004\017\000";
        [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - Transaction

@implementation TronTransaction

@dynamic hasRawData, rawData;
@dynamic signatureArray, signatureArray_Count;
@dynamic retArray, retArray_Count;

typedef struct Transaction__storage_ {
    uint32_t _has_storage_[1];
    Transaction_raw *rawData;
    NSMutableArray *signatureArray;
    NSMutableArray *retArray;
} Transaction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "rawData",
                .dataTypeSpecific.clazz = GPBObjCClass(Transaction_raw),
                .number = Transaction_FieldNumber_RawData,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(Transaction__storage_, rawData),
                .flags = GPBFieldOptional,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "signatureArray",
                .dataTypeSpecific.clazz = Nil,
                .number = Transaction_FieldNumber_SignatureArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(Transaction__storage_, signatureArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "retArray",
                .dataTypeSpecific.clazz = GPBObjCClass(Transaction_Result),
                .number = Transaction_FieldNumber_RetArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(Transaction__storage_, retArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeMessage,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(TronTransaction)
                                   messageName:@"Transaction"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - Transaction_Contract

@implementation Transaction_Contract

@dynamic type;
@dynamic hasParameter, parameter;
@dynamic provider;
@dynamic contractName;
@dynamic permissionId;

typedef struct Transaction_Contract__storage_ {
    uint32_t _has_storage_[1];
    Transaction_Contract_ContractType type;
    int32_t permissionId;
    GPBAny *parameter;
    NSData *provider;
    NSData *contractName;
} Transaction_Contract__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "type",
                .dataTypeSpecific.enumDescFunc = Transaction_Contract_ContractType_EnumDescriptor,
                .number = Transaction_Contract_FieldNumber_Type,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(Transaction_Contract__storage_, type),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeEnum,
            },
            {
                .name = "parameter",
                .dataTypeSpecific.clazz = GPBObjCClass(GPBAny),
                .number = Transaction_Contract_FieldNumber_Parameter,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(Transaction_Contract__storage_, parameter),
                .flags = GPBFieldOptional,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "provider",
                .dataTypeSpecific.clazz = Nil,
                .number = Transaction_Contract_FieldNumber_Provider,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(Transaction_Contract__storage_, provider),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "contractName",
                .dataTypeSpecific.clazz = Nil,
                .number = Transaction_Contract_FieldNumber_ContractName,
                .hasIndex = 3,
                .offset = (uint32_t)offsetof(Transaction_Contract__storage_, contractName),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "permissionId",
                .dataTypeSpecific.clazz = Nil,
                .number = Transaction_Contract_FieldNumber_PermissionId,
                .hasIndex = 4,
                .offset = (uint32_t)offsetof(Transaction_Contract__storage_, permissionId),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Transaction_Contract)
                                   messageName:@"Contract"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction_Contract__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        static const char *extraTextFormatInfo =
        "\002\004L\000\005J\242\000";
        [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        [localDescriptor setupContainingMessageClass:GPBObjCClass(TronTransaction)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

int32_t Transaction_Contract_Type_RawValue(Transaction_Contract *message) {
    GPBDescriptor *descriptor = [Transaction_Contract descriptor];
    GPBFieldDescriptor *field = [descriptor fieldWithNumber:Transaction_Contract_FieldNumber_Type];
    return GPBGetMessageRawEnumField(message, field);
}

void SetTransaction_Contract_Type_RawValue(Transaction_Contract *message, int32_t value) {
    GPBDescriptor *descriptor = [Transaction_Contract descriptor];
    GPBFieldDescriptor *field = [descriptor fieldWithNumber:Transaction_Contract_FieldNumber_Type];
    GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Transaction_Result

@implementation Transaction_Result

@dynamic fee;
@dynamic ret;
@dynamic contractRet;
@dynamic assetIssueId;
@dynamic withdrawAmount;
@dynamic unfreezeAmount;
@dynamic exchangeReceivedAmount;
@dynamic exchangeInjectAnotherAmount;
@dynamic exchangeWithdrawAnotherAmount;
@dynamic exchangeId;
@dynamic shieldedTransactionFee;
@dynamic orderId;
@dynamic orderDetailsArray, orderDetailsArray_Count;
@dynamic withdrawExpireAmount;
@dynamic cancelUnfreezeV2Amount, cancelUnfreezeV2Amount_Count;

typedef struct Transaction_Result__storage_ {
    uint32_t _has_storage_[1];
    Transaction_Result_code ret;
    Transaction_Result_contractResult contractRet;
    NSString *assetIssueId;
    NSData *orderId;
    NSMutableArray *orderDetailsArray;
    GPBStringInt64Dictionary *cancelUnfreezeV2Amount;
    int64_t fee;
    int64_t withdrawAmount;
    int64_t unfreezeAmount;
    int64_t exchangeReceivedAmount;
    int64_t exchangeInjectAnotherAmount;
    int64_t exchangeWithdrawAnotherAmount;
    int64_t exchangeId;
    int64_t shieldedTransactionFee;
    int64_t withdrawExpireAmount;
} Transaction_Result__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "fee",
                .dataTypeSpecific.clazz = Nil,
                .number = Transaction_Result_FieldNumber_Fee,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(Transaction_Result__storage_, fee),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "ret",
                .dataTypeSpecific.enumDescFunc = Transaction_Result_code_EnumDescriptor,
                .number = Transaction_Result_FieldNumber_Ret,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(Transaction_Result__storage_, ret),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeEnum,
            },
            {
                .name = "contractRet",
                .dataTypeSpecific.enumDescFunc = Transaction_Result_contractResult_EnumDescriptor,
                .number = Transaction_Result_FieldNumber_ContractRet,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(Transaction_Result__storage_, contractRet),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeEnum,
            },
            {
                .name = "assetIssueId",
                .dataTypeSpecific.clazz = Nil,
                .number = Transaction_Result_FieldNumber_AssetIssueId,
                .hasIndex = 3,
                .offset = (uint32_t)offsetof(Transaction_Result__storage_, assetIssueId),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeString,
            },
            {
                .name = "withdrawAmount",
                .dataTypeSpecific.clazz = Nil,
                .number = Transaction_Result_FieldNumber_WithdrawAmount,
                .hasIndex = 4,
                .offset = (uint32_t)offsetof(Transaction_Result__storage_, withdrawAmount),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "unfreezeAmount",
                .dataTypeSpecific.clazz = Nil,
                .number = Transaction_Result_FieldNumber_UnfreezeAmount,
                .hasIndex = 5,
                .offset = (uint32_t)offsetof(Transaction_Result__storage_, unfreezeAmount),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "exchangeReceivedAmount",
                .dataTypeSpecific.clazz = Nil,
                .number = Transaction_Result_FieldNumber_ExchangeReceivedAmount,
                .hasIndex = 6,
                .offset = (uint32_t)offsetof(Transaction_Result__storage_, exchangeReceivedAmount),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "exchangeInjectAnotherAmount",
                .dataTypeSpecific.clazz = Nil,
                .number = Transaction_Result_FieldNumber_ExchangeInjectAnotherAmount,
                .hasIndex = 7,
                .offset = (uint32_t)offsetof(Transaction_Result__storage_, exchangeInjectAnotherAmount),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "exchangeWithdrawAnotherAmount",
                .dataTypeSpecific.clazz = Nil,
                .number = Transaction_Result_FieldNumber_ExchangeWithdrawAnotherAmount,
                .hasIndex = 8,
                .offset = (uint32_t)offsetof(Transaction_Result__storage_, exchangeWithdrawAnotherAmount),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "exchangeId",
                .dataTypeSpecific.clazz = Nil,
                .number = Transaction_Result_FieldNumber_ExchangeId,
                .hasIndex = 9,
                .offset = (uint32_t)offsetof(Transaction_Result__storage_, exchangeId),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "shieldedTransactionFee",
                .dataTypeSpecific.clazz = Nil,
                .number = Transaction_Result_FieldNumber_ShieldedTransactionFee,
                .hasIndex = 10,
                .offset = (uint32_t)offsetof(Transaction_Result__storage_, shieldedTransactionFee),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "orderId",
                .dataTypeSpecific.clazz = Nil,
                .number = Transaction_Result_FieldNumber_OrderId,
                .hasIndex = 11,
                .offset = (uint32_t)offsetof(Transaction_Result__storage_, orderId),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "orderDetailsArray",
                .dataTypeSpecific.clazz = GPBObjCClass(MarketOrderDetail),
                .number = Transaction_Result_FieldNumber_OrderDetailsArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(Transaction_Result__storage_, orderDetailsArray),
                .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "withdrawExpireAmount",
                .dataTypeSpecific.clazz = Nil,
                .number = Transaction_Result_FieldNumber_WithdrawExpireAmount,
                .hasIndex = 12,
                .offset = (uint32_t)offsetof(Transaction_Result__storage_, withdrawExpireAmount),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "cancelUnfreezeV2Amount",
                .dataTypeSpecific.clazz = Nil,
                .number = Transaction_Result_FieldNumber_CancelUnfreezeV2Amount,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(Transaction_Result__storage_, cancelUnfreezeV2Amount),
                .flags = (GPBFieldFlags)(GPBFieldMapKeyString | GPBFieldTextFormatNameCustom),
                .dataType = GPBDataTypeInt64,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Transaction_Result)
                                   messageName:@"Result"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction_Result__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        static const char *extraTextFormatInfo =
        "\005\003\013\000\016\013A\000\031\007\000\032\000orderDetails\000\034\006\252\246\000";
        [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        [localDescriptor setupContainingMessageClass:GPBObjCClass(TronTransaction)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

int32_t Transaction_Result_Ret_RawValue(Transaction_Result *message) {
    GPBDescriptor *descriptor = [Transaction_Result descriptor];
    GPBFieldDescriptor *field = [descriptor fieldWithNumber:Transaction_Result_FieldNumber_Ret];
    return GPBGetMessageRawEnumField(message, field);
}

void SetTransaction_Result_Ret_RawValue(Transaction_Result *message, int32_t value) {
    GPBDescriptor *descriptor = [Transaction_Result descriptor];
    GPBFieldDescriptor *field = [descriptor fieldWithNumber:Transaction_Result_FieldNumber_Ret];
    GPBSetMessageRawEnumField(message, field, value);
}

int32_t Transaction_Result_ContractRet_RawValue(Transaction_Result *message) {
    GPBDescriptor *descriptor = [Transaction_Result descriptor];
    GPBFieldDescriptor *field = [descriptor fieldWithNumber:Transaction_Result_FieldNumber_ContractRet];
    return GPBGetMessageRawEnumField(message, field);
}

void SetTransaction_Result_ContractRet_RawValue(Transaction_Result *message, int32_t value) {
    GPBDescriptor *descriptor = [Transaction_Result descriptor];
    GPBFieldDescriptor *field = [descriptor fieldWithNumber:Transaction_Result_FieldNumber_ContractRet];
    GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Transaction_raw

@implementation Transaction_raw

@dynamic refBlockBytes;
@dynamic refBlockNum;
@dynamic refBlockHash;
@dynamic expiration;
@dynamic authsArray, authsArray_Count;
@dynamic data_p;
@dynamic contractArray, contractArray_Count;
@dynamic scripts;
@dynamic timestamp;
@dynamic feeLimit;

typedef struct Transaction_raw__storage_ {
    uint32_t _has_storage_[1];
    NSData *refBlockBytes;
    NSData *refBlockHash;
    NSMutableArray *authsArray;
    NSData *data_p;
    NSMutableArray *contractArray;
    NSData *scripts;
    int64_t refBlockNum;
    int64_t expiration;
    int64_t timestamp;
    int64_t feeLimit;
} Transaction_raw__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "refBlockBytes",
                .dataTypeSpecific.clazz = Nil,
                .number = Transaction_raw_FieldNumber_RefBlockBytes,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(Transaction_raw__storage_, refBlockBytes),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "refBlockNum",
                .dataTypeSpecific.clazz = Nil,
                .number = Transaction_raw_FieldNumber_RefBlockNum,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(Transaction_raw__storage_, refBlockNum),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "refBlockHash",
                .dataTypeSpecific.clazz = Nil,
                .number = Transaction_raw_FieldNumber_RefBlockHash,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(Transaction_raw__storage_, refBlockHash),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "expiration",
                .dataTypeSpecific.clazz = Nil,
                .number = Transaction_raw_FieldNumber_Expiration,
                .hasIndex = 3,
                .offset = (uint32_t)offsetof(Transaction_raw__storage_, expiration),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "authsArray",
                .dataTypeSpecific.clazz = GPBObjCClass(authority),
                .number = Transaction_raw_FieldNumber_AuthsArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(Transaction_raw__storage_, authsArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "data_p",
                .dataTypeSpecific.clazz = Nil,
                .number = Transaction_raw_FieldNumber_Data_p,
                .hasIndex = 4,
                .offset = (uint32_t)offsetof(Transaction_raw__storage_, data_p),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "contractArray",
                .dataTypeSpecific.clazz = GPBObjCClass(Transaction_Contract),
                .number = Transaction_raw_FieldNumber_ContractArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(Transaction_raw__storage_, contractArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "scripts",
                .dataTypeSpecific.clazz = Nil,
                .number = Transaction_raw_FieldNumber_Scripts,
                .hasIndex = 5,
                .offset = (uint32_t)offsetof(Transaction_raw__storage_, scripts),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "timestamp",
                .dataTypeSpecific.clazz = Nil,
                .number = Transaction_raw_FieldNumber_Timestamp,
                .hasIndex = 6,
                .offset = (uint32_t)offsetof(Transaction_raw__storage_, timestamp),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "feeLimit",
                .dataTypeSpecific.clazz = Nil,
                .number = Transaction_raw_FieldNumber_FeeLimit,
                .hasIndex = 7,
                .offset = (uint32_t)offsetof(Transaction_raw__storage_, feeLimit),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Transaction_raw)
                                   messageName:@"raw"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction_raw__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
        [localDescriptor setupContainingMessageClass:GPBObjCClass(TronTransaction)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - TransactionInfo

@implementation TransactionInfo

@dynamic id_p;
@dynamic fee;
@dynamic blockNumber;
@dynamic blockTimeStamp;
@dynamic contractResultArray, contractResultArray_Count;
@dynamic contractAddress;
@dynamic hasReceipt, receipt;
@dynamic logArray, logArray_Count;
@dynamic result;
@dynamic resMessage;
@dynamic assetIssueId;
@dynamic withdrawAmount;
@dynamic unfreezeAmount;
@dynamic internalTransactionsArray, internalTransactionsArray_Count;
@dynamic exchangeReceivedAmount;
@dynamic exchangeInjectAnotherAmount;
@dynamic exchangeWithdrawAnotherAmount;
@dynamic exchangeId;
@dynamic shieldedTransactionFee;
@dynamic orderId;
@dynamic orderDetailsArray, orderDetailsArray_Count;
@dynamic packingFee;
@dynamic withdrawExpireAmount;
@dynamic cancelUnfreezeV2Amount, cancelUnfreezeV2Amount_Count;

typedef struct TransactionInfo__storage_ {
    uint32_t _has_storage_[1];
    TransactionInfo_code result;
    NSData *id_p;
    NSMutableArray *contractResultArray;
    NSData *contractAddress;
    ResourceReceipt *receipt;
    NSMutableArray *logArray;
    NSData *resMessage;
    NSString *assetIssueId;
    NSMutableArray *internalTransactionsArray;
    NSData *orderId;
    NSMutableArray *orderDetailsArray;
    GPBStringInt64Dictionary *cancelUnfreezeV2Amount;
    int64_t fee;
    int64_t blockNumber;
    int64_t blockTimeStamp;
    int64_t withdrawAmount;
    int64_t unfreezeAmount;
    int64_t exchangeReceivedAmount;
    int64_t exchangeInjectAnotherAmount;
    int64_t exchangeWithdrawAnotherAmount;
    int64_t exchangeId;
    int64_t shieldedTransactionFee;
    int64_t packingFee;
    int64_t withdrawExpireAmount;
} TransactionInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "id_p",
                .dataTypeSpecific.clazz = Nil,
                .number = TransactionInfo_FieldNumber_Id_p,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(TransactionInfo__storage_, id_p),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "fee",
                .dataTypeSpecific.clazz = Nil,
                .number = TransactionInfo_FieldNumber_Fee,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(TransactionInfo__storage_, fee),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "blockNumber",
                .dataTypeSpecific.clazz = Nil,
                .number = TransactionInfo_FieldNumber_BlockNumber,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(TransactionInfo__storage_, blockNumber),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "blockTimeStamp",
                .dataTypeSpecific.clazz = Nil,
                .number = TransactionInfo_FieldNumber_BlockTimeStamp,
                .hasIndex = 3,
                .offset = (uint32_t)offsetof(TransactionInfo__storage_, blockTimeStamp),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "contractResultArray",
                .dataTypeSpecific.clazz = Nil,
                .number = TransactionInfo_FieldNumber_ContractResultArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(TransactionInfo__storage_, contractResultArray),
                .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "contractAddress",
                .dataTypeSpecific.clazz = Nil,
                .number = TransactionInfo_FieldNumber_ContractAddress,
                .hasIndex = 4,
                .offset = (uint32_t)offsetof(TransactionInfo__storage_, contractAddress),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "receipt",
                .dataTypeSpecific.clazz = GPBObjCClass(ResourceReceipt),
                .number = TransactionInfo_FieldNumber_Receipt,
                .hasIndex = 5,
                .offset = (uint32_t)offsetof(TransactionInfo__storage_, receipt),
                .flags = GPBFieldOptional,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "logArray",
                .dataTypeSpecific.clazz = GPBObjCClass(TransactionInfo_Log),
                .number = TransactionInfo_FieldNumber_LogArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(TransactionInfo__storage_, logArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "result",
                .dataTypeSpecific.enumDescFunc = TransactionInfo_code_EnumDescriptor,
                .number = TransactionInfo_FieldNumber_Result,
                .hasIndex = 6,
                .offset = (uint32_t)offsetof(TransactionInfo__storage_, result),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeEnum,
            },
            {
                .name = "resMessage",
                .dataTypeSpecific.clazz = Nil,
                .number = TransactionInfo_FieldNumber_ResMessage,
                .hasIndex = 7,
                .offset = (uint32_t)offsetof(TransactionInfo__storage_, resMessage),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "assetIssueId",
                .dataTypeSpecific.clazz = Nil,
                .number = TransactionInfo_FieldNumber_AssetIssueId,
                .hasIndex = 8,
                .offset = (uint32_t)offsetof(TransactionInfo__storage_, assetIssueId),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeString,
            },
            {
                .name = "withdrawAmount",
                .dataTypeSpecific.clazz = Nil,
                .number = TransactionInfo_FieldNumber_WithdrawAmount,
                .hasIndex = 9,
                .offset = (uint32_t)offsetof(TransactionInfo__storage_, withdrawAmount),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "unfreezeAmount",
                .dataTypeSpecific.clazz = Nil,
                .number = TransactionInfo_FieldNumber_UnfreezeAmount,
                .hasIndex = 10,
                .offset = (uint32_t)offsetof(TransactionInfo__storage_, unfreezeAmount),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "internalTransactionsArray",
                .dataTypeSpecific.clazz = GPBObjCClass(InternalTransaction),
                .number = TransactionInfo_FieldNumber_InternalTransactionsArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(TransactionInfo__storage_, internalTransactionsArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "exchangeReceivedAmount",
                .dataTypeSpecific.clazz = Nil,
                .number = TransactionInfo_FieldNumber_ExchangeReceivedAmount,
                .hasIndex = 11,
                .offset = (uint32_t)offsetof(TransactionInfo__storage_, exchangeReceivedAmount),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "exchangeInjectAnotherAmount",
                .dataTypeSpecific.clazz = Nil,
                .number = TransactionInfo_FieldNumber_ExchangeInjectAnotherAmount,
                .hasIndex = 12,
                .offset = (uint32_t)offsetof(TransactionInfo__storage_, exchangeInjectAnotherAmount),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "exchangeWithdrawAnotherAmount",
                .dataTypeSpecific.clazz = Nil,
                .number = TransactionInfo_FieldNumber_ExchangeWithdrawAnotherAmount,
                .hasIndex = 13,
                .offset = (uint32_t)offsetof(TransactionInfo__storage_, exchangeWithdrawAnotherAmount),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "exchangeId",
                .dataTypeSpecific.clazz = Nil,
                .number = TransactionInfo_FieldNumber_ExchangeId,
                .hasIndex = 14,
                .offset = (uint32_t)offsetof(TransactionInfo__storage_, exchangeId),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "shieldedTransactionFee",
                .dataTypeSpecific.clazz = Nil,
                .number = TransactionInfo_FieldNumber_ShieldedTransactionFee,
                .hasIndex = 15,
                .offset = (uint32_t)offsetof(TransactionInfo__storage_, shieldedTransactionFee),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "orderId",
                .dataTypeSpecific.clazz = Nil,
                .number = TransactionInfo_FieldNumber_OrderId,
                .hasIndex = 16,
                .offset = (uint32_t)offsetof(TransactionInfo__storage_, orderId),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "orderDetailsArray",
                .dataTypeSpecific.clazz = GPBObjCClass(MarketOrderDetail),
                .number = TransactionInfo_FieldNumber_OrderDetailsArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(TransactionInfo__storage_, orderDetailsArray),
                .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "packingFee",
                .dataTypeSpecific.clazz = Nil,
                .number = TransactionInfo_FieldNumber_PackingFee,
                .hasIndex = 17,
                .offset = (uint32_t)offsetof(TransactionInfo__storage_, packingFee),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "withdrawExpireAmount",
                .dataTypeSpecific.clazz = Nil,
                .number = TransactionInfo_FieldNumber_WithdrawExpireAmount,
                .hasIndex = 18,
                .offset = (uint32_t)offsetof(TransactionInfo__storage_, withdrawExpireAmount),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "cancelUnfreezeV2Amount",
                .dataTypeSpecific.clazz = Nil,
                .number = TransactionInfo_FieldNumber_CancelUnfreezeV2Amount,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(TransactionInfo__storage_, cancelUnfreezeV2Amount),
                .flags = (GPBFieldFlags)(GPBFieldMapKeyString | GPBFieldTextFormatNameCustom),
                .dataType = GPBDataTypeInt64,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(TransactionInfo)
                                   messageName:@"TransactionInfo"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransactionInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        static const char *extraTextFormatInfo =
        "\t\003\013\000\004\016\000\005\000contractResult\000\n\n\000\016\013A\000\031\007\000\032\000orde"
        "rDetails\000\033\n\000\035\006\252\246\000";
        [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

int32_t TransactionInfo_Result_RawValue(TransactionInfo *message) {
    GPBDescriptor *descriptor = [TransactionInfo descriptor];
    GPBFieldDescriptor *field = [descriptor fieldWithNumber:TransactionInfo_FieldNumber_Result];
    return GPBGetMessageRawEnumField(message, field);
}

void SetTransactionInfo_Result_RawValue(TransactionInfo *message, int32_t value) {
    GPBDescriptor *descriptor = [TransactionInfo descriptor];
    GPBFieldDescriptor *field = [descriptor fieldWithNumber:TransactionInfo_FieldNumber_Result];
    GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - TransactionInfo_Log

@implementation TransactionInfo_Log

@dynamic address;
@dynamic topicsArray, topicsArray_Count;
@dynamic data_p;

typedef struct TransactionInfo_Log__storage_ {
    uint32_t _has_storage_[1];
    NSData *address;
    NSMutableArray *topicsArray;
    NSData *data_p;
} TransactionInfo_Log__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "address",
                .dataTypeSpecific.clazz = Nil,
                .number = TransactionInfo_Log_FieldNumber_Address,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(TransactionInfo_Log__storage_, address),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "topicsArray",
                .dataTypeSpecific.clazz = Nil,
                .number = TransactionInfo_Log_FieldNumber_TopicsArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(TransactionInfo_Log__storage_, topicsArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "data_p",
                .dataTypeSpecific.clazz = Nil,
                .number = TransactionInfo_Log_FieldNumber_Data_p,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(TransactionInfo_Log__storage_, data_p),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(TransactionInfo_Log)
                                   messageName:@"Log"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransactionInfo_Log__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
        [localDescriptor setupContainingMessageClass:GPBObjCClass(TransactionInfo)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - TransactionRet

@implementation TransactionRet

@dynamic blockNumber;
@dynamic blockTimeStamp;
@dynamic transactioninfoArray, transactioninfoArray_Count;

typedef struct TransactionRet__storage_ {
    uint32_t _has_storage_[1];
    NSMutableArray *transactioninfoArray;
    int64_t blockNumber;
    int64_t blockTimeStamp;
} TransactionRet__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "blockNumber",
                .dataTypeSpecific.clazz = Nil,
                .number = TransactionRet_FieldNumber_BlockNumber,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(TransactionRet__storage_, blockNumber),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "blockTimeStamp",
                .dataTypeSpecific.clazz = Nil,
                .number = TransactionRet_FieldNumber_BlockTimeStamp,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(TransactionRet__storage_, blockTimeStamp),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "transactioninfoArray",
                .dataTypeSpecific.clazz = GPBObjCClass(TransactionInfo),
                .number = TransactionRet_FieldNumber_TransactioninfoArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(TransactionRet__storage_, transactioninfoArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeMessage,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(TransactionRet)
                                   messageName:@"TransactionRet"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransactionRet__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        static const char *extraTextFormatInfo =
        "\002\001\013\000\002\016\000";
        [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - Transactions

@implementation Transactions

@dynamic transactionsArray, transactionsArray_Count;

typedef struct Transactions__storage_ {
    uint32_t _has_storage_[1];
    NSMutableArray *transactionsArray;
} Transactions__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "transactionsArray",
                .dataTypeSpecific.clazz = GPBObjCClass(TronTransaction),
                .number = Transactions_FieldNumber_TransactionsArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(Transactions__storage_, transactionsArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeMessage,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Transactions)
                                   messageName:@"Transactions"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transactions__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - BlockHeader

@implementation BlockHeader

@dynamic hasRawData, rawData;
@dynamic witnessSignature;

typedef struct BlockHeader__storage_ {
    uint32_t _has_storage_[1];
    BlockHeader_raw *rawData;
    NSData *witnessSignature;
} BlockHeader__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "rawData",
                .dataTypeSpecific.clazz = GPBObjCClass(BlockHeader_raw),
                .number = BlockHeader_FieldNumber_RawData,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(BlockHeader__storage_, rawData),
                .flags = GPBFieldOptional,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "witnessSignature",
                .dataTypeSpecific.clazz = Nil,
                .number = BlockHeader_FieldNumber_WitnessSignature,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(BlockHeader__storage_, witnessSignature),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(BlockHeader)
                                   messageName:@"BlockHeader"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockHeader__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - BlockHeader_raw

@implementation BlockHeader_raw

@dynamic timestamp;
@dynamic txTrieRoot;
@dynamic parentHash;
@dynamic number;
@dynamic witnessId;
@dynamic witnessAddress;
@dynamic version;
@dynamic accountStateRoot;

typedef struct BlockHeader_raw__storage_ {
    uint32_t _has_storage_[1];
    int32_t version;
    NSData *txTrieRoot;
    NSData *parentHash;
    NSData *witnessAddress;
    NSData *accountStateRoot;
    int64_t timestamp;
    int64_t number;
    int64_t witnessId;
} BlockHeader_raw__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "timestamp",
                .dataTypeSpecific.clazz = Nil,
                .number = BlockHeader_raw_FieldNumber_Timestamp,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(BlockHeader_raw__storage_, timestamp),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "txTrieRoot",
                .dataTypeSpecific.clazz = Nil,
                .number = BlockHeader_raw_FieldNumber_TxTrieRoot,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(BlockHeader_raw__storage_, txTrieRoot),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "parentHash",
                .dataTypeSpecific.clazz = Nil,
                .number = BlockHeader_raw_FieldNumber_ParentHash,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(BlockHeader_raw__storage_, parentHash),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "number",
                .dataTypeSpecific.clazz = Nil,
                .number = BlockHeader_raw_FieldNumber_Number,
                .hasIndex = 3,
                .offset = (uint32_t)offsetof(BlockHeader_raw__storage_, number),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "witnessId",
                .dataTypeSpecific.clazz = Nil,
                .number = BlockHeader_raw_FieldNumber_WitnessId,
                .hasIndex = 4,
                .offset = (uint32_t)offsetof(BlockHeader_raw__storage_, witnessId),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "witnessAddress",
                .dataTypeSpecific.clazz = Nil,
                .number = BlockHeader_raw_FieldNumber_WitnessAddress,
                .hasIndex = 5,
                .offset = (uint32_t)offsetof(BlockHeader_raw__storage_, witnessAddress),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "version",
                .dataTypeSpecific.clazz = Nil,
                .number = BlockHeader_raw_FieldNumber_Version,
                .hasIndex = 6,
                .offset = (uint32_t)offsetof(BlockHeader_raw__storage_, version),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
            {
                .name = "accountStateRoot",
                .dataTypeSpecific.clazz = Nil,
                .number = BlockHeader_raw_FieldNumber_AccountStateRoot,
                .hasIndex = 7,
                .offset = (uint32_t)offsetof(BlockHeader_raw__storage_, accountStateRoot),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(BlockHeader_raw)
                                   messageName:@"raw"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockHeader_raw__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        static const char *extraTextFormatInfo =
        "\003\002\n\000\003\n\000\013\020\000";
        [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        [localDescriptor setupContainingMessageClass:GPBObjCClass(BlockHeader)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - Block

@implementation Block

@dynamic transactionsArray, transactionsArray_Count;
@dynamic hasBlockHeader, blockHeader;

typedef struct Block__storage_ {
    uint32_t _has_storage_[1];
    NSMutableArray *transactionsArray;
    BlockHeader *blockHeader;
} Block__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "transactionsArray",
                .dataTypeSpecific.clazz = GPBObjCClass(TronTransaction),
                .number = Block_FieldNumber_TransactionsArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(Block__storage_, transactionsArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "blockHeader",
                .dataTypeSpecific.clazz = GPBObjCClass(BlockHeader),
                .number = Block_FieldNumber_BlockHeader,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(Block__storage_, blockHeader),
                .flags = GPBFieldOptional,
                .dataType = GPBDataTypeMessage,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Block)
                                   messageName:@"Block"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Block__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - ChainInventory

@implementation ChainInventory

@dynamic idsArray, idsArray_Count;
@dynamic remainNum;

typedef struct ChainInventory__storage_ {
    uint32_t _has_storage_[1];
    NSMutableArray *idsArray;
    int64_t remainNum;
} ChainInventory__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "idsArray",
                .dataTypeSpecific.clazz = GPBObjCClass(ChainInventory_BlockId),
                .number = ChainInventory_FieldNumber_IdsArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(ChainInventory__storage_, idsArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "remainNum",
                .dataTypeSpecific.clazz = Nil,
                .number = ChainInventory_FieldNumber_RemainNum,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(ChainInventory__storage_, remainNum),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ChainInventory)
                                   messageName:@"ChainInventory"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChainInventory__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - ChainInventory_BlockId

@implementation ChainInventory_BlockId

@dynamic hash_p;
@dynamic number;

typedef struct ChainInventory_BlockId__storage_ {
    uint32_t _has_storage_[1];
    NSData *hash_p;
    int64_t number;
} ChainInventory_BlockId__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "hash_p",
                .dataTypeSpecific.clazz = Nil,
                .number = ChainInventory_BlockId_FieldNumber_Hash_p,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(ChainInventory_BlockId__storage_, hash_p),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "number",
                .dataTypeSpecific.clazz = Nil,
                .number = ChainInventory_BlockId_FieldNumber_Number,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(ChainInventory_BlockId__storage_, number),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ChainInventory_BlockId)
                                   messageName:@"BlockId"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChainInventory_BlockId__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
        [localDescriptor setupContainingMessageClass:GPBObjCClass(ChainInventory)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - BlockInventory

@implementation BlockInventory

@dynamic idsArray, idsArray_Count;
@dynamic type;

typedef struct BlockInventory__storage_ {
    uint32_t _has_storage_[1];
    BlockInventory_Type type;
    NSMutableArray *idsArray;
} BlockInventory__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "idsArray",
                .dataTypeSpecific.clazz = GPBObjCClass(BlockInventory_BlockId),
                .number = BlockInventory_FieldNumber_IdsArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(BlockInventory__storage_, idsArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "type",
                .dataTypeSpecific.enumDescFunc = BlockInventory_Type_EnumDescriptor,
                .number = BlockInventory_FieldNumber_Type,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(BlockInventory__storage_, type),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeEnum,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(BlockInventory)
                                   messageName:@"BlockInventory"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockInventory__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

int32_t BlockInventory_Type_RawValue(BlockInventory *message) {
    GPBDescriptor *descriptor = [BlockInventory descriptor];
    GPBFieldDescriptor *field = [descriptor fieldWithNumber:BlockInventory_FieldNumber_Type];
    return GPBGetMessageRawEnumField(message, field);
}

void SetBlockInventory_Type_RawValue(BlockInventory *message, int32_t value) {
    GPBDescriptor *descriptor = [BlockInventory descriptor];
    GPBFieldDescriptor *field = [descriptor fieldWithNumber:BlockInventory_FieldNumber_Type];
    GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - BlockInventory_BlockId

@implementation BlockInventory_BlockId

@dynamic hash_p;
@dynamic number;

typedef struct BlockInventory_BlockId__storage_ {
    uint32_t _has_storage_[1];
    NSData *hash_p;
    int64_t number;
} BlockInventory_BlockId__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "hash_p",
                .dataTypeSpecific.clazz = Nil,
                .number = BlockInventory_BlockId_FieldNumber_Hash_p,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(BlockInventory_BlockId__storage_, hash_p),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "number",
                .dataTypeSpecific.clazz = Nil,
                .number = BlockInventory_BlockId_FieldNumber_Number,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(BlockInventory_BlockId__storage_, number),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(BlockInventory_BlockId)
                                   messageName:@"BlockId"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockInventory_BlockId__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
        [localDescriptor setupContainingMessageClass:GPBObjCClass(BlockInventory)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - Inventory

@implementation Inventory

@dynamic type;
@dynamic idsArray, idsArray_Count;

typedef struct Inventory__storage_ {
    uint32_t _has_storage_[1];
    Inventory_InventoryType type;
    NSMutableArray *idsArray;
} Inventory__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "type",
                .dataTypeSpecific.enumDescFunc = Inventory_InventoryType_EnumDescriptor,
                .number = Inventory_FieldNumber_Type,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(Inventory__storage_, type),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeEnum,
            },
            {
                .name = "idsArray",
                .dataTypeSpecific.clazz = Nil,
                .number = Inventory_FieldNumber_IdsArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(Inventory__storage_, idsArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeBytes,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Inventory)
                                   messageName:@"Inventory"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Inventory__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

int32_t Inventory_Type_RawValue(Inventory *message) {
    GPBDescriptor *descriptor = [Inventory descriptor];
    GPBFieldDescriptor *field = [descriptor fieldWithNumber:Inventory_FieldNumber_Type];
    return GPBGetMessageRawEnumField(message, field);
}

void SetInventory_Type_RawValue(Inventory *message, int32_t value) {
    GPBDescriptor *descriptor = [Inventory descriptor];
    GPBFieldDescriptor *field = [descriptor fieldWithNumber:Inventory_FieldNumber_Type];
    GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Items

@implementation Items

@dynamic type;
@dynamic blocksArray, blocksArray_Count;
@dynamic blockHeadersArray, blockHeadersArray_Count;
@dynamic transactionsArray, transactionsArray_Count;

typedef struct Items__storage_ {
    uint32_t _has_storage_[1];
    Items_ItemType type;
    NSMutableArray *blocksArray;
    NSMutableArray *blockHeadersArray;
    NSMutableArray *transactionsArray;
} Items__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "type",
                .dataTypeSpecific.enumDescFunc = Items_ItemType_EnumDescriptor,
                .number = Items_FieldNumber_Type,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(Items__storage_, type),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeEnum,
            },
            {
                .name = "blocksArray",
                .dataTypeSpecific.clazz = GPBObjCClass(Block),
                .number = Items_FieldNumber_BlocksArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(Items__storage_, blocksArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "blockHeadersArray",
                .dataTypeSpecific.clazz = GPBObjCClass(BlockHeader),
                .number = Items_FieldNumber_BlockHeadersArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(Items__storage_, blockHeadersArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "transactionsArray",
                .dataTypeSpecific.clazz = GPBObjCClass(TronTransaction),
                .number = Items_FieldNumber_TransactionsArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(Items__storage_, transactionsArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeMessage,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Items)
                                   messageName:@"Items"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Items__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

int32_t Items_Type_RawValue(Items *message) {
    GPBDescriptor *descriptor = [Items descriptor];
    GPBFieldDescriptor *field = [descriptor fieldWithNumber:Items_FieldNumber_Type];
    return GPBGetMessageRawEnumField(message, field);
}

void SetItems_Type_RawValue(Items *message, int32_t value) {
    GPBDescriptor *descriptor = [Items descriptor];
    GPBFieldDescriptor *field = [descriptor fieldWithNumber:Items_FieldNumber_Type];
    GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - DynamicProperties

@implementation DynamicProperties

@dynamic lastSolidityBlockNum;

typedef struct DynamicProperties__storage_ {
    uint32_t _has_storage_[1];
    int64_t lastSolidityBlockNum;
} DynamicProperties__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "lastSolidityBlockNum",
                .dataTypeSpecific.clazz = Nil,
                .number = DynamicProperties_FieldNumber_LastSolidityBlockNum,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(DynamicProperties__storage_, lastSolidityBlockNum),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(DynamicProperties)
                                   messageName:@"DynamicProperties"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DynamicProperties__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - DisconnectMessage

@implementation DisconnectMessage

@dynamic reason;

typedef struct DisconnectMessage__storage_ {
    uint32_t _has_storage_[1];
    ReasonCode reason;
} DisconnectMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "reason",
                .dataTypeSpecific.enumDescFunc = ReasonCode_EnumDescriptor,
                .number = DisconnectMessage_FieldNumber_Reason,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(DisconnectMessage__storage_, reason),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeEnum,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(DisconnectMessage)
                                   messageName:@"DisconnectMessage"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DisconnectMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

int32_t DisconnectMessage_Reason_RawValue(DisconnectMessage *message) {
    GPBDescriptor *descriptor = [DisconnectMessage descriptor];
    GPBFieldDescriptor *field = [descriptor fieldWithNumber:DisconnectMessage_FieldNumber_Reason];
    return GPBGetMessageRawEnumField(message, field);
}

void SetDisconnectMessage_Reason_RawValue(DisconnectMessage *message, int32_t value) {
    GPBDescriptor *descriptor = [DisconnectMessage descriptor];
    GPBFieldDescriptor *field = [descriptor fieldWithNumber:DisconnectMessage_FieldNumber_Reason];
    GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - HelloMessage

@implementation HelloMessage

@dynamic hasFrom, from;
@dynamic version;
@dynamic timestamp;
@dynamic hasGenesisBlockId, genesisBlockId;
@dynamic hasSolidBlockId, solidBlockId;
@dynamic hasHeadBlockId, headBlockId;
@dynamic address;
@dynamic signature;
@dynamic nodeType;
@dynamic lowestBlockNum;

typedef struct HelloMessage__storage_ {
    uint32_t _has_storage_[1];
    int32_t version;
    int32_t nodeType;
    Endpoint *from;
    HelloMessage_BlockId *genesisBlockId;
    HelloMessage_BlockId *solidBlockId;
    HelloMessage_BlockId *headBlockId;
    NSData *address;
    NSData *signature;
    int64_t timestamp;
    int64_t lowestBlockNum;
} HelloMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "from",
                .dataTypeSpecific.clazz = GPBObjCClass(Endpoint),
                .number = HelloMessage_FieldNumber_From,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(HelloMessage__storage_, from),
                .flags = GPBFieldOptional,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "version",
                .dataTypeSpecific.clazz = Nil,
                .number = HelloMessage_FieldNumber_Version,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(HelloMessage__storage_, version),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
            {
                .name = "timestamp",
                .dataTypeSpecific.clazz = Nil,
                .number = HelloMessage_FieldNumber_Timestamp,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(HelloMessage__storage_, timestamp),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "genesisBlockId",
                .dataTypeSpecific.clazz = GPBObjCClass(HelloMessage_BlockId),
                .number = HelloMessage_FieldNumber_GenesisBlockId,
                .hasIndex = 3,
                .offset = (uint32_t)offsetof(HelloMessage__storage_, genesisBlockId),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "solidBlockId",
                .dataTypeSpecific.clazz = GPBObjCClass(HelloMessage_BlockId),
                .number = HelloMessage_FieldNumber_SolidBlockId,
                .hasIndex = 4,
                .offset = (uint32_t)offsetof(HelloMessage__storage_, solidBlockId),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "headBlockId",
                .dataTypeSpecific.clazz = GPBObjCClass(HelloMessage_BlockId),
                .number = HelloMessage_FieldNumber_HeadBlockId,
                .hasIndex = 5,
                .offset = (uint32_t)offsetof(HelloMessage__storage_, headBlockId),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "address",
                .dataTypeSpecific.clazz = Nil,
                .number = HelloMessage_FieldNumber_Address,
                .hasIndex = 6,
                .offset = (uint32_t)offsetof(HelloMessage__storage_, address),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "signature",
                .dataTypeSpecific.clazz = Nil,
                .number = HelloMessage_FieldNumber_Signature,
                .hasIndex = 7,
                .offset = (uint32_t)offsetof(HelloMessage__storage_, signature),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "nodeType",
                .dataTypeSpecific.clazz = Nil,
                .number = HelloMessage_FieldNumber_NodeType,
                .hasIndex = 8,
                .offset = (uint32_t)offsetof(HelloMessage__storage_, nodeType),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
            {
                .name = "lowestBlockNum",
                .dataTypeSpecific.clazz = Nil,
                .number = HelloMessage_FieldNumber_LowestBlockNum,
                .hasIndex = 9,
                .offset = (uint32_t)offsetof(HelloMessage__storage_, lowestBlockNum),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(HelloMessage)
                                   messageName:@"HelloMessage"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(HelloMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        static const char *extraTextFormatInfo =
        "\005\004\016\000\005\014\000\006\013\000\t\010\000\n\016\000";
        [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - HelloMessage_BlockId

@implementation HelloMessage_BlockId

@dynamic hash_p;
@dynamic number;

typedef struct HelloMessage_BlockId__storage_ {
    uint32_t _has_storage_[1];
    NSData *hash_p;
    int64_t number;
} HelloMessage_BlockId__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "hash_p",
                .dataTypeSpecific.clazz = Nil,
                .number = HelloMessage_BlockId_FieldNumber_Hash_p,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(HelloMessage_BlockId__storage_, hash_p),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "number",
                .dataTypeSpecific.clazz = Nil,
                .number = HelloMessage_BlockId_FieldNumber_Number,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(HelloMessage_BlockId__storage_, number),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(HelloMessage_BlockId)
                                   messageName:@"BlockId"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(HelloMessage_BlockId__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
        [localDescriptor setupContainingMessageClass:GPBObjCClass(HelloMessage)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - InternalTransaction

@implementation InternalTransaction

@dynamic hash_p;
@dynamic callerAddress;
@dynamic transferToAddress;
@dynamic callValueInfoArray, callValueInfoArray_Count;
@dynamic note;
@dynamic rejected;
@dynamic extra;

typedef struct InternalTransaction__storage_ {
    uint32_t _has_storage_[1];
    NSData *hash_p;
    NSData *callerAddress;
    NSData *transferToAddress;
    NSMutableArray *callValueInfoArray;
    NSData *note;
    NSString *extra;
} InternalTransaction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "hash_p",
                .dataTypeSpecific.clazz = Nil,
                .number = InternalTransaction_FieldNumber_Hash_p,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(InternalTransaction__storage_, hash_p),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "callerAddress",
                .dataTypeSpecific.clazz = Nil,
                .number = InternalTransaction_FieldNumber_CallerAddress,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(InternalTransaction__storage_, callerAddress),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "transferToAddress",
                .dataTypeSpecific.clazz = Nil,
                .number = InternalTransaction_FieldNumber_TransferToAddress,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(InternalTransaction__storage_, transferToAddress),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "callValueInfoArray",
                .dataTypeSpecific.clazz = GPBObjCClass(InternalTransaction_CallValueInfo),
                .number = InternalTransaction_FieldNumber_CallValueInfoArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(InternalTransaction__storage_, callValueInfoArray),
                .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "note",
                .dataTypeSpecific.clazz = Nil,
                .number = InternalTransaction_FieldNumber_Note,
                .hasIndex = 3,
                .offset = (uint32_t)offsetof(InternalTransaction__storage_, note),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "rejected",
                .dataTypeSpecific.clazz = Nil,
                .number = InternalTransaction_FieldNumber_Rejected,
                .hasIndex = 4,
                .offset = 5,  // Stored in _has_storage_ to save space.
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBool,
            },
            {
                .name = "extra",
                .dataTypeSpecific.clazz = Nil,
                .number = InternalTransaction_FieldNumber_Extra,
                .hasIndex = 6,
                .offset = (uint32_t)offsetof(InternalTransaction__storage_, extra),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeString,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(InternalTransaction)
                                   messageName:@"InternalTransaction"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InternalTransaction__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        static const char *extraTextFormatInfo =
        "\002\003\n\247\000\004\000callValueInfo\000";
        [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - InternalTransaction_CallValueInfo

@implementation InternalTransaction_CallValueInfo

@dynamic callValue;
@dynamic tokenId;

typedef struct InternalTransaction_CallValueInfo__storage_ {
    uint32_t _has_storage_[1];
    NSString *tokenId;
    int64_t callValue;
} InternalTransaction_CallValueInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "callValue",
                .dataTypeSpecific.clazz = Nil,
                .number = InternalTransaction_CallValueInfo_FieldNumber_CallValue,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(InternalTransaction_CallValueInfo__storage_, callValue),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "tokenId",
                .dataTypeSpecific.clazz = Nil,
                .number = InternalTransaction_CallValueInfo_FieldNumber_TokenId,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(InternalTransaction_CallValueInfo__storage_, tokenId),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeString,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(InternalTransaction_CallValueInfo)
                                   messageName:@"CallValueInfo"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InternalTransaction_CallValueInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        static const char *extraTextFormatInfo =
        "\002\001\t\000\002\007\000";
        [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        [localDescriptor setupContainingMessageClass:GPBObjCClass(InternalTransaction)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - DelegatedResourceAccountIndex

@implementation DelegatedResourceAccountIndex

@dynamic account;
@dynamic fromAccountsArray, fromAccountsArray_Count;
@dynamic toAccountsArray, toAccountsArray_Count;
@dynamic timestamp;

typedef struct DelegatedResourceAccountIndex__storage_ {
    uint32_t _has_storage_[1];
    NSData *account;
    NSMutableArray *fromAccountsArray;
    NSMutableArray *toAccountsArray;
    int64_t timestamp;
} DelegatedResourceAccountIndex__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "account",
                .dataTypeSpecific.clazz = Nil,
                .number = DelegatedResourceAccountIndex_FieldNumber_Account,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(DelegatedResourceAccountIndex__storage_, account),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "fromAccountsArray",
                .dataTypeSpecific.clazz = Nil,
                .number = DelegatedResourceAccountIndex_FieldNumber_FromAccountsArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(DelegatedResourceAccountIndex__storage_, fromAccountsArray),
                .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "toAccountsArray",
                .dataTypeSpecific.clazz = Nil,
                .number = DelegatedResourceAccountIndex_FieldNumber_ToAccountsArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(DelegatedResourceAccountIndex__storage_, toAccountsArray),
                .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "timestamp",
                .dataTypeSpecific.clazz = Nil,
                .number = DelegatedResourceAccountIndex_FieldNumber_Timestamp,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(DelegatedResourceAccountIndex__storage_, timestamp),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(DelegatedResourceAccountIndex)
                                   messageName:@"DelegatedResourceAccountIndex"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DelegatedResourceAccountIndex__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        static const char *extraTextFormatInfo =
        "\002\002\000fromAccounts\000\003\000toAccounts\000";
        [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - NodeInfo

@implementation NodeInfo

@dynamic beginSyncNum;
@dynamic block;
@dynamic solidityBlock;
@dynamic currentConnectCount;
@dynamic activeConnectCount;
@dynamic passiveConnectCount;
@dynamic totalFlow;
@dynamic peerInfoListArray, peerInfoListArray_Count;
@dynamic hasConfigNodeInfo, configNodeInfo;
@dynamic hasMachineInfo, machineInfo;
@dynamic cheatWitnessInfoMap, cheatWitnessInfoMap_Count;

typedef struct NodeInfo__storage_ {
    uint32_t _has_storage_[1];
    int32_t currentConnectCount;
    int32_t activeConnectCount;
    int32_t passiveConnectCount;
    NSString *block;
    NSString *solidityBlock;
    NSMutableArray *peerInfoListArray;
    NodeInfo_ConfigNodeInfo *configNodeInfo;
    NodeInfo_MachineInfo *machineInfo;
    NSMutableDictionary *cheatWitnessInfoMap;
    int64_t beginSyncNum;
    int64_t totalFlow;
} NodeInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "beginSyncNum",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_FieldNumber_BeginSyncNum,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(NodeInfo__storage_, beginSyncNum),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "block",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_FieldNumber_Block,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(NodeInfo__storage_, block),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeString,
            },
            {
                .name = "solidityBlock",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_FieldNumber_SolidityBlock,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(NodeInfo__storage_, solidityBlock),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeString,
            },
            {
                .name = "currentConnectCount",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_FieldNumber_CurrentConnectCount,
                .hasIndex = 3,
                .offset = (uint32_t)offsetof(NodeInfo__storage_, currentConnectCount),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
            {
                .name = "activeConnectCount",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_FieldNumber_ActiveConnectCount,
                .hasIndex = 4,
                .offset = (uint32_t)offsetof(NodeInfo__storage_, activeConnectCount),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
            {
                .name = "passiveConnectCount",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_FieldNumber_PassiveConnectCount,
                .hasIndex = 5,
                .offset = (uint32_t)offsetof(NodeInfo__storage_, passiveConnectCount),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
            {
                .name = "totalFlow",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_FieldNumber_TotalFlow,
                .hasIndex = 6,
                .offset = (uint32_t)offsetof(NodeInfo__storage_, totalFlow),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "peerInfoListArray",
                .dataTypeSpecific.clazz = GPBObjCClass(NodeInfo_PeerInfo),
                .number = NodeInfo_FieldNumber_PeerInfoListArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(NodeInfo__storage_, peerInfoListArray),
                .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "configNodeInfo",
                .dataTypeSpecific.clazz = GPBObjCClass(NodeInfo_ConfigNodeInfo),
                .number = NodeInfo_FieldNumber_ConfigNodeInfo,
                .hasIndex = 7,
                .offset = (uint32_t)offsetof(NodeInfo__storage_, configNodeInfo),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "machineInfo",
                .dataTypeSpecific.clazz = GPBObjCClass(NodeInfo_MachineInfo),
                .number = NodeInfo_FieldNumber_MachineInfo,
                .hasIndex = 8,
                .offset = (uint32_t)offsetof(NodeInfo__storage_, machineInfo),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "cheatWitnessInfoMap",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_FieldNumber_CheatWitnessInfoMap,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(NodeInfo__storage_, cheatWitnessInfoMap),
                .flags = (GPBFieldFlags)(GPBFieldMapKeyString | GPBFieldTextFormatNameCustom),
                .dataType = GPBDataTypeString,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(NodeInfo)
                                   messageName:@"NodeInfo"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NodeInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        static const char *extraTextFormatInfo =
        "\n\001\014\000\003\r\000\004\023\000\005\022\000\006\023\000\007\t\000\010\000peerInfoList\000\t\016\000\n\013\000"
        "\013\023\000";
        [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - NodeInfo_PeerInfo

@implementation NodeInfo_PeerInfo

@dynamic lastSyncBlock;
@dynamic remainNum;
@dynamic lastBlockUpdateTime;
@dynamic syncFlag;
@dynamic headBlockTimeWeBothHave;
@dynamic needSyncFromPeer;
@dynamic needSyncFromUs;
@dynamic host;
@dynamic port;
@dynamic nodeId;
@dynamic connectTime;
@dynamic avgLatency;
@dynamic syncToFetchSize;
@dynamic syncToFetchSizePeekNum;
@dynamic syncBlockRequestedSize;
@dynamic unFetchSynNum;
@dynamic blockInPorcSize;
@dynamic headBlockWeBothHave;
@dynamic isActive;
@dynamic score;
@dynamic nodeCount;
@dynamic inFlow;
@dynamic disconnectTimes;
@dynamic localDisconnectReason;
@dynamic remoteDisconnectReason;

typedef struct NodeInfo_PeerInfo__storage_ {
    uint32_t _has_storage_[1];
    int32_t port;
    int32_t syncToFetchSize;
    int32_t syncBlockRequestedSize;
    int32_t blockInPorcSize;
    int32_t score;
    int32_t nodeCount;
    int32_t disconnectTimes;
    NSString *lastSyncBlock;
    NSString *host;
    NSString *nodeId;
    NSString *headBlockWeBothHave;
    NSString *localDisconnectReason;
    NSString *remoteDisconnectReason;
    int64_t remainNum;
    int64_t lastBlockUpdateTime;
    int64_t headBlockTimeWeBothHave;
    int64_t connectTime;
    double avgLatency;
    int64_t syncToFetchSizePeekNum;
    int64_t unFetchSynNum;
    int64_t inFlow;
} NodeInfo_PeerInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "lastSyncBlock",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_PeerInfo_FieldNumber_LastSyncBlock,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(NodeInfo_PeerInfo__storage_, lastSyncBlock),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeString,
            },
            {
                .name = "remainNum",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_PeerInfo_FieldNumber_RemainNum,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(NodeInfo_PeerInfo__storage_, remainNum),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "lastBlockUpdateTime",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_PeerInfo_FieldNumber_LastBlockUpdateTime,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(NodeInfo_PeerInfo__storage_, lastBlockUpdateTime),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "syncFlag",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_PeerInfo_FieldNumber_SyncFlag,
                .hasIndex = 3,
                .offset = 4,  // Stored in _has_storage_ to save space.
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBool,
            },
            {
                .name = "headBlockTimeWeBothHave",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_PeerInfo_FieldNumber_HeadBlockTimeWeBothHave,
                .hasIndex = 5,
                .offset = (uint32_t)offsetof(NodeInfo_PeerInfo__storage_, headBlockTimeWeBothHave),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "needSyncFromPeer",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_PeerInfo_FieldNumber_NeedSyncFromPeer,
                .hasIndex = 6,
                .offset = 7,  // Stored in _has_storage_ to save space.
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBool,
            },
            {
                .name = "needSyncFromUs",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_PeerInfo_FieldNumber_NeedSyncFromUs,
                .hasIndex = 8,
                .offset = 9,  // Stored in _has_storage_ to save space.
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBool,
            },
            {
                .name = "host",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_PeerInfo_FieldNumber_Host,
                .hasIndex = 10,
                .offset = (uint32_t)offsetof(NodeInfo_PeerInfo__storage_, host),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeString,
            },
            {
                .name = "port",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_PeerInfo_FieldNumber_Port,
                .hasIndex = 11,
                .offset = (uint32_t)offsetof(NodeInfo_PeerInfo__storage_, port),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
            {
                .name = "nodeId",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_PeerInfo_FieldNumber_NodeId,
                .hasIndex = 12,
                .offset = (uint32_t)offsetof(NodeInfo_PeerInfo__storage_, nodeId),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeString,
            },
            {
                .name = "connectTime",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_PeerInfo_FieldNumber_ConnectTime,
                .hasIndex = 13,
                .offset = (uint32_t)offsetof(NodeInfo_PeerInfo__storage_, connectTime),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "avgLatency",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_PeerInfo_FieldNumber_AvgLatency,
                .hasIndex = 14,
                .offset = (uint32_t)offsetof(NodeInfo_PeerInfo__storage_, avgLatency),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeDouble,
            },
            {
                .name = "syncToFetchSize",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_PeerInfo_FieldNumber_SyncToFetchSize,
                .hasIndex = 15,
                .offset = (uint32_t)offsetof(NodeInfo_PeerInfo__storage_, syncToFetchSize),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
            {
                .name = "syncToFetchSizePeekNum",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_PeerInfo_FieldNumber_SyncToFetchSizePeekNum,
                .hasIndex = 16,
                .offset = (uint32_t)offsetof(NodeInfo_PeerInfo__storage_, syncToFetchSizePeekNum),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "syncBlockRequestedSize",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_PeerInfo_FieldNumber_SyncBlockRequestedSize,
                .hasIndex = 17,
                .offset = (uint32_t)offsetof(NodeInfo_PeerInfo__storage_, syncBlockRequestedSize),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
            {
                .name = "unFetchSynNum",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_PeerInfo_FieldNumber_UnFetchSynNum,
                .hasIndex = 18,
                .offset = (uint32_t)offsetof(NodeInfo_PeerInfo__storage_, unFetchSynNum),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "blockInPorcSize",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_PeerInfo_FieldNumber_BlockInPorcSize,
                .hasIndex = 19,
                .offset = (uint32_t)offsetof(NodeInfo_PeerInfo__storage_, blockInPorcSize),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
            {
                .name = "headBlockWeBothHave",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_PeerInfo_FieldNumber_HeadBlockWeBothHave,
                .hasIndex = 20,
                .offset = (uint32_t)offsetof(NodeInfo_PeerInfo__storage_, headBlockWeBothHave),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeString,
            },
            {
                .name = "isActive",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_PeerInfo_FieldNumber_IsActive,
                .hasIndex = 21,
                .offset = 22,  // Stored in _has_storage_ to save space.
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBool,
            },
            {
                .name = "score",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_PeerInfo_FieldNumber_Score,
                .hasIndex = 23,
                .offset = (uint32_t)offsetof(NodeInfo_PeerInfo__storage_, score),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
            {
                .name = "nodeCount",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_PeerInfo_FieldNumber_NodeCount,
                .hasIndex = 24,
                .offset = (uint32_t)offsetof(NodeInfo_PeerInfo__storage_, nodeCount),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
            {
                .name = "inFlow",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_PeerInfo_FieldNumber_InFlow,
                .hasIndex = 25,
                .offset = (uint32_t)offsetof(NodeInfo_PeerInfo__storage_, inFlow),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "disconnectTimes",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_PeerInfo_FieldNumber_DisconnectTimes,
                .hasIndex = 26,
                .offset = (uint32_t)offsetof(NodeInfo_PeerInfo__storage_, disconnectTimes),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
            {
                .name = "localDisconnectReason",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_PeerInfo_FieldNumber_LocalDisconnectReason,
                .hasIndex = 27,
                .offset = (uint32_t)offsetof(NodeInfo_PeerInfo__storage_, localDisconnectReason),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeString,
            },
            {
                .name = "remoteDisconnectReason",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_PeerInfo_FieldNumber_RemoteDisconnectReason,
                .hasIndex = 28,
                .offset = (uint32_t)offsetof(NodeInfo_PeerInfo__storage_, remoteDisconnectReason),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeString,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(NodeInfo_PeerInfo)
                                   messageName:@"PeerInfo"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NodeInfo_PeerInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        static const char *extraTextFormatInfo =
        "\026\001\r\000\002\t\000\003\023\000\004\010\000\005\027\000\006\020\000\007\016\000\n\006\000\013\013\000\014\n\000\r\017\000\016\026\000\017\026\000"
        "\020\r\000\021\017\000\022\023\000\023\010\000\025\t\000\026\006\000\027\017\000\030\025\000\031\026\000";
        [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        [localDescriptor setupContainingMessageClass:GPBObjCClass(NodeInfo)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - NodeInfo_ConfigNodeInfo

@implementation NodeInfo_ConfigNodeInfo

@dynamic codeVersion;
@dynamic p2PVersion;
@dynamic listenPort;
@dynamic discoverEnable;
@dynamic activeNodeSize;
@dynamic passiveNodeSize;
@dynamic sendNodeSize;
@dynamic maxConnectCount;
@dynamic sameIpMaxConnectCount;
@dynamic backupListenPort;
@dynamic backupMemberSize;
@dynamic backupPriority;
@dynamic dbVersion;
@dynamic minParticipationRate;
@dynamic supportConstant;
@dynamic minTimeRatio;
@dynamic maxTimeRatio;
@dynamic allowCreationOfContracts;
@dynamic allowAdaptiveEnergy;

typedef struct NodeInfo_ConfigNodeInfo__storage_ {
    uint32_t _has_storage_[1];
    int32_t listenPort;
    int32_t activeNodeSize;
    int32_t passiveNodeSize;
    int32_t sendNodeSize;
    int32_t maxConnectCount;
    int32_t sameIpMaxConnectCount;
    int32_t backupListenPort;
    int32_t backupMemberSize;
    int32_t backupPriority;
    int32_t dbVersion;
    int32_t minParticipationRate;
    NSString *codeVersion;
    NSString *p2PVersion;
    double minTimeRatio;
    double maxTimeRatio;
    int64_t allowCreationOfContracts;
    int64_t allowAdaptiveEnergy;
} NodeInfo_ConfigNodeInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "codeVersion",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_ConfigNodeInfo_FieldNumber_CodeVersion,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(NodeInfo_ConfigNodeInfo__storage_, codeVersion),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeString,
            },
            {
                .name = "p2PVersion",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_ConfigNodeInfo_FieldNumber_P2PVersion,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(NodeInfo_ConfigNodeInfo__storage_, p2PVersion),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeString,
            },
            {
                .name = "listenPort",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_ConfigNodeInfo_FieldNumber_ListenPort,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(NodeInfo_ConfigNodeInfo__storage_, listenPort),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
            {
                .name = "discoverEnable",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_ConfigNodeInfo_FieldNumber_DiscoverEnable,
                .hasIndex = 3,
                .offset = 4,  // Stored in _has_storage_ to save space.
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBool,
            },
            {
                .name = "activeNodeSize",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_ConfigNodeInfo_FieldNumber_ActiveNodeSize,
                .hasIndex = 5,
                .offset = (uint32_t)offsetof(NodeInfo_ConfigNodeInfo__storage_, activeNodeSize),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
            {
                .name = "passiveNodeSize",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_ConfigNodeInfo_FieldNumber_PassiveNodeSize,
                .hasIndex = 6,
                .offset = (uint32_t)offsetof(NodeInfo_ConfigNodeInfo__storage_, passiveNodeSize),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
            {
                .name = "sendNodeSize",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_ConfigNodeInfo_FieldNumber_SendNodeSize,
                .hasIndex = 7,
                .offset = (uint32_t)offsetof(NodeInfo_ConfigNodeInfo__storage_, sendNodeSize),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
            {
                .name = "maxConnectCount",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_ConfigNodeInfo_FieldNumber_MaxConnectCount,
                .hasIndex = 8,
                .offset = (uint32_t)offsetof(NodeInfo_ConfigNodeInfo__storage_, maxConnectCount),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
            {
                .name = "sameIpMaxConnectCount",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_ConfigNodeInfo_FieldNumber_SameIpMaxConnectCount,
                .hasIndex = 9,
                .offset = (uint32_t)offsetof(NodeInfo_ConfigNodeInfo__storage_, sameIpMaxConnectCount),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
            {
                .name = "backupListenPort",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_ConfigNodeInfo_FieldNumber_BackupListenPort,
                .hasIndex = 10,
                .offset = (uint32_t)offsetof(NodeInfo_ConfigNodeInfo__storage_, backupListenPort),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
            {
                .name = "backupMemberSize",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_ConfigNodeInfo_FieldNumber_BackupMemberSize,
                .hasIndex = 11,
                .offset = (uint32_t)offsetof(NodeInfo_ConfigNodeInfo__storage_, backupMemberSize),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
            {
                .name = "backupPriority",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_ConfigNodeInfo_FieldNumber_BackupPriority,
                .hasIndex = 12,
                .offset = (uint32_t)offsetof(NodeInfo_ConfigNodeInfo__storage_, backupPriority),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
            {
                .name = "dbVersion",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_ConfigNodeInfo_FieldNumber_DbVersion,
                .hasIndex = 13,
                .offset = (uint32_t)offsetof(NodeInfo_ConfigNodeInfo__storage_, dbVersion),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
            {
                .name = "minParticipationRate",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_ConfigNodeInfo_FieldNumber_MinParticipationRate,
                .hasIndex = 14,
                .offset = (uint32_t)offsetof(NodeInfo_ConfigNodeInfo__storage_, minParticipationRate),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
            {
                .name = "supportConstant",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_ConfigNodeInfo_FieldNumber_SupportConstant,
                .hasIndex = 15,
                .offset = 16,  // Stored in _has_storage_ to save space.
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBool,
            },
            {
                .name = "minTimeRatio",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_ConfigNodeInfo_FieldNumber_MinTimeRatio,
                .hasIndex = 17,
                .offset = (uint32_t)offsetof(NodeInfo_ConfigNodeInfo__storage_, minTimeRatio),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeDouble,
            },
            {
                .name = "maxTimeRatio",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_ConfigNodeInfo_FieldNumber_MaxTimeRatio,
                .hasIndex = 18,
                .offset = (uint32_t)offsetof(NodeInfo_ConfigNodeInfo__storage_, maxTimeRatio),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeDouble,
            },
            {
                .name = "allowCreationOfContracts",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_ConfigNodeInfo_FieldNumber_AllowCreationOfContracts,
                .hasIndex = 19,
                .offset = (uint32_t)offsetof(NodeInfo_ConfigNodeInfo__storage_, allowCreationOfContracts),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "allowAdaptiveEnergy",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_ConfigNodeInfo_FieldNumber_AllowAdaptiveEnergy,
                .hasIndex = 20,
                .offset = (uint32_t)offsetof(NodeInfo_ConfigNodeInfo__storage_, allowAdaptiveEnergy),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(NodeInfo_ConfigNodeInfo)
                                   messageName:@"ConfigNodeInfo"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NodeInfo_ConfigNodeInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        static const char *extraTextFormatInfo =
        "\023\001\013\000\002\002(\000\003\n\000\004\016\000\005\016\000\006\017\000\007\014\000\010\017\000\t\025\000\n\020\000\013\020\000\014\016\000\r\t"
        "\000\016\024\000\017\017\000\020\014\000\021\014\000\022\030\000\023\023\000";
        [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        [localDescriptor setupContainingMessageClass:GPBObjCClass(NodeInfo)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - NodeInfo_MachineInfo

@implementation NodeInfo_MachineInfo

@dynamic threadCount;
@dynamic deadLockThreadCount;
@dynamic cpuCount;
@dynamic totalMemory;
@dynamic freeMemory;
@dynamic cpuRate;
@dynamic javaVersion;
@dynamic osName;
@dynamic jvmTotalMemory;
@dynamic jvmFreeMemory;
@dynamic processCpuRate;
@dynamic memoryDescInfoListArray, memoryDescInfoListArray_Count;
@dynamic deadLockThreadInfoListArray, deadLockThreadInfoListArray_Count;

typedef struct NodeInfo_MachineInfo__storage_ {
    uint32_t _has_storage_[1];
    int32_t threadCount;
    int32_t deadLockThreadCount;
    int32_t cpuCount;
    NSString *javaVersion;
    NSString *osName;
    NSMutableArray *memoryDescInfoListArray;
    NSMutableArray *deadLockThreadInfoListArray;
    int64_t totalMemory;
    int64_t freeMemory;
    double cpuRate;
    int64_t jvmTotalMemory;
    int64_t jvmFreeMemory;
    double processCpuRate;
} NodeInfo_MachineInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "threadCount",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_MachineInfo_FieldNumber_ThreadCount,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(NodeInfo_MachineInfo__storage_, threadCount),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
            {
                .name = "deadLockThreadCount",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_MachineInfo_FieldNumber_DeadLockThreadCount,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(NodeInfo_MachineInfo__storage_, deadLockThreadCount),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
            {
                .name = "cpuCount",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_MachineInfo_FieldNumber_CpuCount,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(NodeInfo_MachineInfo__storage_, cpuCount),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
            {
                .name = "totalMemory",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_MachineInfo_FieldNumber_TotalMemory,
                .hasIndex = 3,
                .offset = (uint32_t)offsetof(NodeInfo_MachineInfo__storage_, totalMemory),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "freeMemory",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_MachineInfo_FieldNumber_FreeMemory,
                .hasIndex = 4,
                .offset = (uint32_t)offsetof(NodeInfo_MachineInfo__storage_, freeMemory),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "cpuRate",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_MachineInfo_FieldNumber_CpuRate,
                .hasIndex = 5,
                .offset = (uint32_t)offsetof(NodeInfo_MachineInfo__storage_, cpuRate),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeDouble,
            },
            {
                .name = "javaVersion",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_MachineInfo_FieldNumber_JavaVersion,
                .hasIndex = 6,
                .offset = (uint32_t)offsetof(NodeInfo_MachineInfo__storage_, javaVersion),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeString,
            },
            {
                .name = "osName",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_MachineInfo_FieldNumber_OsName,
                .hasIndex = 7,
                .offset = (uint32_t)offsetof(NodeInfo_MachineInfo__storage_, osName),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeString,
            },
            {
                .name = "jvmTotalMemory",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_MachineInfo_FieldNumber_JvmTotalMemory,
                .hasIndex = 8,
                .offset = (uint32_t)offsetof(NodeInfo_MachineInfo__storage_, jvmTotalMemory),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "jvmFreeMemory",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_MachineInfo_FieldNumber_JvmFreeMemory,
                .hasIndex = 9,
                .offset = (uint32_t)offsetof(NodeInfo_MachineInfo__storage_, jvmFreeMemory),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "processCpuRate",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_MachineInfo_FieldNumber_ProcessCpuRate,
                .hasIndex = 10,
                .offset = (uint32_t)offsetof(NodeInfo_MachineInfo__storage_, processCpuRate),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeDouble,
            },
            {
                .name = "memoryDescInfoListArray",
                .dataTypeSpecific.clazz = GPBObjCClass(NodeInfo_MachineInfo_MemoryDescInfo),
                .number = NodeInfo_MachineInfo_FieldNumber_MemoryDescInfoListArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(NodeInfo_MachineInfo__storage_, memoryDescInfoListArray),
                .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "deadLockThreadInfoListArray",
                .dataTypeSpecific.clazz = GPBObjCClass(NodeInfo_MachineInfo_DeadLockThreadInfo),
                .number = NodeInfo_MachineInfo_FieldNumber_DeadLockThreadInfoListArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(NodeInfo_MachineInfo__storage_, deadLockThreadInfoListArray),
                .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
                .dataType = GPBDataTypeMessage,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(NodeInfo_MachineInfo)
                                   messageName:@"MachineInfo"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NodeInfo_MachineInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        static const char *extraTextFormatInfo =
        "\r\001\013\000\002\023\000\003\010\000\004\013\000\005\n\000\006\007\000\007\013\000\010\006\000\t\016\000\n\r\000\013\016\000\014\000memo"
        "ryDescInfoList\000\r\000deadLockThreadInfoList\000";
        [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        [localDescriptor setupContainingMessageClass:GPBObjCClass(NodeInfo)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - NodeInfo_MachineInfo_MemoryDescInfo

@implementation NodeInfo_MachineInfo_MemoryDescInfo

@dynamic name;
@dynamic initSize;
@dynamic useSize;
@dynamic maxSize;
@dynamic useRate;

typedef struct NodeInfo_MachineInfo_MemoryDescInfo__storage_ {
    uint32_t _has_storage_[1];
    NSString *name;
    int64_t initSize;
    int64_t useSize;
    int64_t maxSize;
    double useRate;
} NodeInfo_MachineInfo_MemoryDescInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "name",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_MachineInfo_MemoryDescInfo_FieldNumber_Name,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(NodeInfo_MachineInfo_MemoryDescInfo__storage_, name),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeString,
            },
            {
                .name = "initSize",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_MachineInfo_MemoryDescInfo_FieldNumber_InitSize,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(NodeInfo_MachineInfo_MemoryDescInfo__storage_, initSize),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "useSize",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_MachineInfo_MemoryDescInfo_FieldNumber_UseSize,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(NodeInfo_MachineInfo_MemoryDescInfo__storage_, useSize),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "maxSize",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_MachineInfo_MemoryDescInfo_FieldNumber_MaxSize,
                .hasIndex = 3,
                .offset = (uint32_t)offsetof(NodeInfo_MachineInfo_MemoryDescInfo__storage_, maxSize),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "useRate",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_MachineInfo_MemoryDescInfo_FieldNumber_UseRate,
                .hasIndex = 4,
                .offset = (uint32_t)offsetof(NodeInfo_MachineInfo_MemoryDescInfo__storage_, useRate),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeDouble,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(NodeInfo_MachineInfo_MemoryDescInfo)
                                   messageName:@"MemoryDescInfo"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NodeInfo_MachineInfo_MemoryDescInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        static const char *extraTextFormatInfo =
        "\004\002\010\000\003\007\000\004\007\000\005\007\000";
        [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        [localDescriptor setupContainingMessageClass:GPBObjCClass(NodeInfo_MachineInfo)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - NodeInfo_MachineInfo_DeadLockThreadInfo

@implementation NodeInfo_MachineInfo_DeadLockThreadInfo

@dynamic name;
@dynamic lockName;
@dynamic lockOwner;
@dynamic state;
@dynamic blockTime;
@dynamic waitTime;
@dynamic stackTrace;

typedef struct NodeInfo_MachineInfo_DeadLockThreadInfo__storage_ {
    uint32_t _has_storage_[1];
    NSString *name;
    NSString *lockName;
    NSString *lockOwner;
    NSString *state;
    NSString *stackTrace;
    int64_t blockTime;
    int64_t waitTime;
} NodeInfo_MachineInfo_DeadLockThreadInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "name",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_MachineInfo_DeadLockThreadInfo_FieldNumber_Name,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(NodeInfo_MachineInfo_DeadLockThreadInfo__storage_, name),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeString,
            },
            {
                .name = "lockName",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_MachineInfo_DeadLockThreadInfo_FieldNumber_LockName,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(NodeInfo_MachineInfo_DeadLockThreadInfo__storage_, lockName),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeString,
            },
            {
                .name = "lockOwner",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_MachineInfo_DeadLockThreadInfo_FieldNumber_LockOwner,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(NodeInfo_MachineInfo_DeadLockThreadInfo__storage_, lockOwner),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeString,
            },
            {
                .name = "state",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_MachineInfo_DeadLockThreadInfo_FieldNumber_State,
                .hasIndex = 3,
                .offset = (uint32_t)offsetof(NodeInfo_MachineInfo_DeadLockThreadInfo__storage_, state),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeString,
            },
            {
                .name = "blockTime",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_MachineInfo_DeadLockThreadInfo_FieldNumber_BlockTime,
                .hasIndex = 4,
                .offset = (uint32_t)offsetof(NodeInfo_MachineInfo_DeadLockThreadInfo__storage_, blockTime),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "waitTime",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_MachineInfo_DeadLockThreadInfo_FieldNumber_WaitTime,
                .hasIndex = 5,
                .offset = (uint32_t)offsetof(NodeInfo_MachineInfo_DeadLockThreadInfo__storage_, waitTime),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "stackTrace",
                .dataTypeSpecific.clazz = Nil,
                .number = NodeInfo_MachineInfo_DeadLockThreadInfo_FieldNumber_StackTrace,
                .hasIndex = 6,
                .offset = (uint32_t)offsetof(NodeInfo_MachineInfo_DeadLockThreadInfo__storage_, stackTrace),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeString,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(NodeInfo_MachineInfo_DeadLockThreadInfo)
                                   messageName:@"DeadLockThreadInfo"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NodeInfo_MachineInfo_DeadLockThreadInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        static const char *extraTextFormatInfo =
        "\005\002\010\000\003\t\000\005\t\000\006\010\000\007\n\000";
        [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        [localDescriptor setupContainingMessageClass:GPBObjCClass(NodeInfo_MachineInfo)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - MetricsInfo

@implementation MetricsInfo

@dynamic interval;
@dynamic hasNode, node;
@dynamic hasBlockchain, blockchain;
@dynamic hasNet, net;

typedef struct MetricsInfo__storage_ {
    uint32_t _has_storage_[1];
    MetricsInfo_NodeInfo *node;
    MetricsInfo_BlockChainInfo *blockchain;
    MetricsInfo_NetInfo *net;
    int64_t interval;
} MetricsInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "interval",
                .dataTypeSpecific.clazz = Nil,
                .number = MetricsInfo_FieldNumber_Interval,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(MetricsInfo__storage_, interval),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "node",
                .dataTypeSpecific.clazz = GPBObjCClass(MetricsInfo_NodeInfo),
                .number = MetricsInfo_FieldNumber_Node,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(MetricsInfo__storage_, node),
                .flags = GPBFieldOptional,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "blockchain",
                .dataTypeSpecific.clazz = GPBObjCClass(MetricsInfo_BlockChainInfo),
                .number = MetricsInfo_FieldNumber_Blockchain,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(MetricsInfo__storage_, blockchain),
                .flags = GPBFieldOptional,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "net",
                .dataTypeSpecific.clazz = GPBObjCClass(MetricsInfo_NetInfo),
                .number = MetricsInfo_FieldNumber_Net,
                .hasIndex = 3,
                .offset = (uint32_t)offsetof(MetricsInfo__storage_, net),
                .flags = GPBFieldOptional,
                .dataType = GPBDataTypeMessage,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(MetricsInfo)
                                   messageName:@"MetricsInfo"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MetricsInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - MetricsInfo_NodeInfo

@implementation MetricsInfo_NodeInfo

@dynamic ip;
@dynamic nodeType;
@dynamic version;
@dynamic backupStatus;

typedef struct MetricsInfo_NodeInfo__storage_ {
    uint32_t _has_storage_[1];
    int32_t nodeType;
    int32_t backupStatus;
    NSString *ip;
    NSString *version;
} MetricsInfo_NodeInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "ip",
                .dataTypeSpecific.clazz = Nil,
                .number = MetricsInfo_NodeInfo_FieldNumber_Ip,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(MetricsInfo_NodeInfo__storage_, ip),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeString,
            },
            {
                .name = "nodeType",
                .dataTypeSpecific.clazz = Nil,
                .number = MetricsInfo_NodeInfo_FieldNumber_NodeType,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(MetricsInfo_NodeInfo__storage_, nodeType),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
            {
                .name = "version",
                .dataTypeSpecific.clazz = Nil,
                .number = MetricsInfo_NodeInfo_FieldNumber_Version,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(MetricsInfo_NodeInfo__storage_, version),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeString,
            },
            {
                .name = "backupStatus",
                .dataTypeSpecific.clazz = Nil,
                .number = MetricsInfo_NodeInfo_FieldNumber_BackupStatus,
                .hasIndex = 3,
                .offset = (uint32_t)offsetof(MetricsInfo_NodeInfo__storage_, backupStatus),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(MetricsInfo_NodeInfo)
                                   messageName:@"NodeInfo"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MetricsInfo_NodeInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        static const char *extraTextFormatInfo =
        "\002\002\010\000\004\014\000";
        [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        [localDescriptor setupContainingMessageClass:GPBObjCClass(MetricsInfo)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - MetricsInfo_BlockChainInfo

@implementation MetricsInfo_BlockChainInfo

@dynamic headBlockNum;
@dynamic headBlockTimestamp;
@dynamic headBlockHash;
@dynamic forkCount;
@dynamic failForkCount;
@dynamic hasBlockProcessTime, blockProcessTime;
@dynamic hasTps, tps;
@dynamic transactionCacheSize;
@dynamic hasMissedTransaction, missedTransaction;
@dynamic witnessesArray, witnessesArray_Count;
@dynamic failProcessBlockNum;
@dynamic failProcessBlockReason;
@dynamic dupWitnessArray, dupWitnessArray_Count;

typedef struct MetricsInfo_BlockChainInfo__storage_ {
    uint32_t _has_storage_[1];
    int32_t forkCount;
    int32_t failForkCount;
    int32_t transactionCacheSize;
    NSString *headBlockHash;
    MetricsInfo_RateInfo *blockProcessTime;
    MetricsInfo_RateInfo *tps;
    MetricsInfo_RateInfo *missedTransaction;
    NSMutableArray *witnessesArray;
    NSString *failProcessBlockReason;
    NSMutableArray *dupWitnessArray;
    int64_t headBlockNum;
    int64_t headBlockTimestamp;
    int64_t failProcessBlockNum;
} MetricsInfo_BlockChainInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "headBlockNum",
                .dataTypeSpecific.clazz = Nil,
                .number = MetricsInfo_BlockChainInfo_FieldNumber_HeadBlockNum,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(MetricsInfo_BlockChainInfo__storage_, headBlockNum),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "headBlockTimestamp",
                .dataTypeSpecific.clazz = Nil,
                .number = MetricsInfo_BlockChainInfo_FieldNumber_HeadBlockTimestamp,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(MetricsInfo_BlockChainInfo__storage_, headBlockTimestamp),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "headBlockHash",
                .dataTypeSpecific.clazz = Nil,
                .number = MetricsInfo_BlockChainInfo_FieldNumber_HeadBlockHash,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(MetricsInfo_BlockChainInfo__storage_, headBlockHash),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeString,
            },
            {
                .name = "forkCount",
                .dataTypeSpecific.clazz = Nil,
                .number = MetricsInfo_BlockChainInfo_FieldNumber_ForkCount,
                .hasIndex = 3,
                .offset = (uint32_t)offsetof(MetricsInfo_BlockChainInfo__storage_, forkCount),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
            {
                .name = "failForkCount",
                .dataTypeSpecific.clazz = Nil,
                .number = MetricsInfo_BlockChainInfo_FieldNumber_FailForkCount,
                .hasIndex = 4,
                .offset = (uint32_t)offsetof(MetricsInfo_BlockChainInfo__storage_, failForkCount),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
            {
                .name = "blockProcessTime",
                .dataTypeSpecific.clazz = GPBObjCClass(MetricsInfo_RateInfo),
                .number = MetricsInfo_BlockChainInfo_FieldNumber_BlockProcessTime,
                .hasIndex = 5,
                .offset = (uint32_t)offsetof(MetricsInfo_BlockChainInfo__storage_, blockProcessTime),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "tps",
                .dataTypeSpecific.clazz = GPBObjCClass(MetricsInfo_RateInfo),
                .number = MetricsInfo_BlockChainInfo_FieldNumber_Tps,
                .hasIndex = 6,
                .offset = (uint32_t)offsetof(MetricsInfo_BlockChainInfo__storage_, tps),
                .flags = GPBFieldOptional,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "transactionCacheSize",
                .dataTypeSpecific.clazz = Nil,
                .number = MetricsInfo_BlockChainInfo_FieldNumber_TransactionCacheSize,
                .hasIndex = 7,
                .offset = (uint32_t)offsetof(MetricsInfo_BlockChainInfo__storage_, transactionCacheSize),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
            {
                .name = "missedTransaction",
                .dataTypeSpecific.clazz = GPBObjCClass(MetricsInfo_RateInfo),
                .number = MetricsInfo_BlockChainInfo_FieldNumber_MissedTransaction,
                .hasIndex = 8,
                .offset = (uint32_t)offsetof(MetricsInfo_BlockChainInfo__storage_, missedTransaction),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "witnessesArray",
                .dataTypeSpecific.clazz = GPBObjCClass(MetricsInfo_BlockChainInfo_Witness),
                .number = MetricsInfo_BlockChainInfo_FieldNumber_WitnessesArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(MetricsInfo_BlockChainInfo__storage_, witnessesArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "failProcessBlockNum",
                .dataTypeSpecific.clazz = Nil,
                .number = MetricsInfo_BlockChainInfo_FieldNumber_FailProcessBlockNum,
                .hasIndex = 9,
                .offset = (uint32_t)offsetof(MetricsInfo_BlockChainInfo__storage_, failProcessBlockNum),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "failProcessBlockReason",
                .dataTypeSpecific.clazz = Nil,
                .number = MetricsInfo_BlockChainInfo_FieldNumber_FailProcessBlockReason,
                .hasIndex = 10,
                .offset = (uint32_t)offsetof(MetricsInfo_BlockChainInfo__storage_, failProcessBlockReason),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeString,
            },
            {
                .name = "dupWitnessArray",
                .dataTypeSpecific.clazz = GPBObjCClass(MetricsInfo_BlockChainInfo_DupWitness),
                .number = MetricsInfo_BlockChainInfo_FieldNumber_DupWitnessArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(MetricsInfo_BlockChainInfo__storage_, dupWitnessArray),
                .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
                .dataType = GPBDataTypeMessage,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(MetricsInfo_BlockChainInfo)
                                   messageName:@"BlockChainInfo"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MetricsInfo_BlockChainInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        static const char *extraTextFormatInfo =
        "\013\001\014\000\002\022\000\003\r\000\004\t\000\005\r\000\006\020\000\010\024\000\t\021\000\013\023\000\014\026\000\r\000dupWitn"
        "ess\000";
        [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        [localDescriptor setupContainingMessageClass:GPBObjCClass(MetricsInfo)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - MetricsInfo_BlockChainInfo_Witness

@implementation MetricsInfo_BlockChainInfo_Witness

@dynamic address;
@dynamic version;

typedef struct MetricsInfo_BlockChainInfo_Witness__storage_ {
    uint32_t _has_storage_[1];
    int32_t version;
    NSString *address;
} MetricsInfo_BlockChainInfo_Witness__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "address",
                .dataTypeSpecific.clazz = Nil,
                .number = MetricsInfo_BlockChainInfo_Witness_FieldNumber_Address,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(MetricsInfo_BlockChainInfo_Witness__storage_, address),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeString,
            },
            {
                .name = "version",
                .dataTypeSpecific.clazz = Nil,
                .number = MetricsInfo_BlockChainInfo_Witness_FieldNumber_Version,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(MetricsInfo_BlockChainInfo_Witness__storage_, version),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(MetricsInfo_BlockChainInfo_Witness)
                                   messageName:@"Witness"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MetricsInfo_BlockChainInfo_Witness__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
        [localDescriptor setupContainingMessageClass:GPBObjCClass(MetricsInfo_BlockChainInfo)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - MetricsInfo_BlockChainInfo_DupWitness

@implementation MetricsInfo_BlockChainInfo_DupWitness

@dynamic address;
@dynamic blockNum;
@dynamic count;

typedef struct MetricsInfo_BlockChainInfo_DupWitness__storage_ {
    uint32_t _has_storage_[1];
    int32_t count;
    NSString *address;
    int64_t blockNum;
} MetricsInfo_BlockChainInfo_DupWitness__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "address",
                .dataTypeSpecific.clazz = Nil,
                .number = MetricsInfo_BlockChainInfo_DupWitness_FieldNumber_Address,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(MetricsInfo_BlockChainInfo_DupWitness__storage_, address),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeString,
            },
            {
                .name = "blockNum",
                .dataTypeSpecific.clazz = Nil,
                .number = MetricsInfo_BlockChainInfo_DupWitness_FieldNumber_BlockNum,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(MetricsInfo_BlockChainInfo_DupWitness__storage_, blockNum),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "count",
                .dataTypeSpecific.clazz = Nil,
                .number = MetricsInfo_BlockChainInfo_DupWitness_FieldNumber_Count,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(MetricsInfo_BlockChainInfo_DupWitness__storage_, count),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(MetricsInfo_BlockChainInfo_DupWitness)
                                   messageName:@"DupWitness"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MetricsInfo_BlockChainInfo_DupWitness__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        static const char *extraTextFormatInfo =
        "\001\002\010\000";
        [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        [localDescriptor setupContainingMessageClass:GPBObjCClass(MetricsInfo_BlockChainInfo)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - MetricsInfo_RateInfo

@implementation MetricsInfo_RateInfo

@dynamic count;
@dynamic meanRate;
@dynamic oneMinuteRate;
@dynamic fiveMinuteRate;
@dynamic fifteenMinuteRate;

typedef struct MetricsInfo_RateInfo__storage_ {
    uint32_t _has_storage_[1];
    int64_t count;
    double meanRate;
    double oneMinuteRate;
    double fiveMinuteRate;
    double fifteenMinuteRate;
} MetricsInfo_RateInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "count",
                .dataTypeSpecific.clazz = Nil,
                .number = MetricsInfo_RateInfo_FieldNumber_Count,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(MetricsInfo_RateInfo__storage_, count),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "meanRate",
                .dataTypeSpecific.clazz = Nil,
                .number = MetricsInfo_RateInfo_FieldNumber_MeanRate,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(MetricsInfo_RateInfo__storage_, meanRate),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeDouble,
            },
            {
                .name = "oneMinuteRate",
                .dataTypeSpecific.clazz = Nil,
                .number = MetricsInfo_RateInfo_FieldNumber_OneMinuteRate,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(MetricsInfo_RateInfo__storage_, oneMinuteRate),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeDouble,
            },
            {
                .name = "fiveMinuteRate",
                .dataTypeSpecific.clazz = Nil,
                .number = MetricsInfo_RateInfo_FieldNumber_FiveMinuteRate,
                .hasIndex = 3,
                .offset = (uint32_t)offsetof(MetricsInfo_RateInfo__storage_, fiveMinuteRate),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeDouble,
            },
            {
                .name = "fifteenMinuteRate",
                .dataTypeSpecific.clazz = Nil,
                .number = MetricsInfo_RateInfo_FieldNumber_FifteenMinuteRate,
                .hasIndex = 4,
                .offset = (uint32_t)offsetof(MetricsInfo_RateInfo__storage_, fifteenMinuteRate),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeDouble,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(MetricsInfo_RateInfo)
                                   messageName:@"RateInfo"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MetricsInfo_RateInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        static const char *extraTextFormatInfo =
        "\004\002\010\000\003\r\000\004\016\000\005\021\000";
        [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        [localDescriptor setupContainingMessageClass:GPBObjCClass(MetricsInfo)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - MetricsInfo_NetInfo

@implementation MetricsInfo_NetInfo

@dynamic errorProtoCount;
@dynamic hasApi, api;
@dynamic connectionCount;
@dynamic validConnectionCount;
@dynamic hasTcpInTraffic, tcpInTraffic;
@dynamic hasTcpOutTraffic, tcpOutTraffic;
@dynamic disconnectionCount;
@dynamic disconnectionDetailArray, disconnectionDetailArray_Count;
@dynamic hasUdpInTraffic, udpInTraffic;
@dynamic hasUdpOutTraffic, udpOutTraffic;
@dynamic hasLatency, latency;

typedef struct MetricsInfo_NetInfo__storage_ {
    uint32_t _has_storage_[1];
    int32_t errorProtoCount;
    int32_t connectionCount;
    int32_t validConnectionCount;
    int32_t disconnectionCount;
    MetricsInfo_NetInfo_ApiInfo *api;
    MetricsInfo_RateInfo *tcpInTraffic;
    MetricsInfo_RateInfo *tcpOutTraffic;
    NSMutableArray *disconnectionDetailArray;
    MetricsInfo_RateInfo *udpInTraffic;
    MetricsInfo_RateInfo *udpOutTraffic;
    MetricsInfo_NetInfo_LatencyInfo *latency;
} MetricsInfo_NetInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "errorProtoCount",
                .dataTypeSpecific.clazz = Nil,
                .number = MetricsInfo_NetInfo_FieldNumber_ErrorProtoCount,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(MetricsInfo_NetInfo__storage_, errorProtoCount),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
            {
                .name = "api",
                .dataTypeSpecific.clazz = GPBObjCClass(MetricsInfo_NetInfo_ApiInfo),
                .number = MetricsInfo_NetInfo_FieldNumber_Api,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(MetricsInfo_NetInfo__storage_, api),
                .flags = GPBFieldOptional,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "connectionCount",
                .dataTypeSpecific.clazz = Nil,
                .number = MetricsInfo_NetInfo_FieldNumber_ConnectionCount,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(MetricsInfo_NetInfo__storage_, connectionCount),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
            {
                .name = "validConnectionCount",
                .dataTypeSpecific.clazz = Nil,
                .number = MetricsInfo_NetInfo_FieldNumber_ValidConnectionCount,
                .hasIndex = 3,
                .offset = (uint32_t)offsetof(MetricsInfo_NetInfo__storage_, validConnectionCount),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
            {
                .name = "tcpInTraffic",
                .dataTypeSpecific.clazz = GPBObjCClass(MetricsInfo_RateInfo),
                .number = MetricsInfo_NetInfo_FieldNumber_TcpInTraffic,
                .hasIndex = 4,
                .offset = (uint32_t)offsetof(MetricsInfo_NetInfo__storage_, tcpInTraffic),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "tcpOutTraffic",
                .dataTypeSpecific.clazz = GPBObjCClass(MetricsInfo_RateInfo),
                .number = MetricsInfo_NetInfo_FieldNumber_TcpOutTraffic,
                .hasIndex = 5,
                .offset = (uint32_t)offsetof(MetricsInfo_NetInfo__storage_, tcpOutTraffic),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "disconnectionCount",
                .dataTypeSpecific.clazz = Nil,
                .number = MetricsInfo_NetInfo_FieldNumber_DisconnectionCount,
                .hasIndex = 6,
                .offset = (uint32_t)offsetof(MetricsInfo_NetInfo__storage_, disconnectionCount),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
            {
                .name = "disconnectionDetailArray",
                .dataTypeSpecific.clazz = GPBObjCClass(MetricsInfo_NetInfo_DisconnectionDetailInfo),
                .number = MetricsInfo_NetInfo_FieldNumber_DisconnectionDetailArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(MetricsInfo_NetInfo__storage_, disconnectionDetailArray),
                .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "udpInTraffic",
                .dataTypeSpecific.clazz = GPBObjCClass(MetricsInfo_RateInfo),
                .number = MetricsInfo_NetInfo_FieldNumber_UdpInTraffic,
                .hasIndex = 7,
                .offset = (uint32_t)offsetof(MetricsInfo_NetInfo__storage_, udpInTraffic),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "udpOutTraffic",
                .dataTypeSpecific.clazz = GPBObjCClass(MetricsInfo_RateInfo),
                .number = MetricsInfo_NetInfo_FieldNumber_UdpOutTraffic,
                .hasIndex = 8,
                .offset = (uint32_t)offsetof(MetricsInfo_NetInfo__storage_, udpOutTraffic),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "latency",
                .dataTypeSpecific.clazz = GPBObjCClass(MetricsInfo_NetInfo_LatencyInfo),
                .number = MetricsInfo_NetInfo_FieldNumber_Latency,
                .hasIndex = 9,
                .offset = (uint32_t)offsetof(MetricsInfo_NetInfo__storage_, latency),
                .flags = GPBFieldOptional,
                .dataType = GPBDataTypeMessage,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(MetricsInfo_NetInfo)
                                   messageName:@"NetInfo"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MetricsInfo_NetInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        static const char *extraTextFormatInfo =
        "\t\001\017\000\003\017\000\004\024\000\005\014\000\006\r\000\007\022\000\010\000disconnectionDetail"
        "\000\t\014\000\n\r\000";
        [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        [localDescriptor setupContainingMessageClass:GPBObjCClass(MetricsInfo)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - MetricsInfo_NetInfo_ApiInfo

@implementation MetricsInfo_NetInfo_ApiInfo

@dynamic hasQps, qps;
@dynamic hasFailQps, failQps;
@dynamic hasOutTraffic, outTraffic;
@dynamic detailArray, detailArray_Count;

typedef struct MetricsInfo_NetInfo_ApiInfo__storage_ {
    uint32_t _has_storage_[1];
    MetricsInfo_RateInfo *qps;
    MetricsInfo_RateInfo *failQps;
    MetricsInfo_RateInfo *outTraffic;
    NSMutableArray *detailArray;
} MetricsInfo_NetInfo_ApiInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "qps",
                .dataTypeSpecific.clazz = GPBObjCClass(MetricsInfo_RateInfo),
                .number = MetricsInfo_NetInfo_ApiInfo_FieldNumber_Qps,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(MetricsInfo_NetInfo_ApiInfo__storage_, qps),
                .flags = GPBFieldOptional,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "failQps",
                .dataTypeSpecific.clazz = GPBObjCClass(MetricsInfo_RateInfo),
                .number = MetricsInfo_NetInfo_ApiInfo_FieldNumber_FailQps,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(MetricsInfo_NetInfo_ApiInfo__storage_, failQps),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "outTraffic",
                .dataTypeSpecific.clazz = GPBObjCClass(MetricsInfo_RateInfo),
                .number = MetricsInfo_NetInfo_ApiInfo_FieldNumber_OutTraffic,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(MetricsInfo_NetInfo_ApiInfo__storage_, outTraffic),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "detailArray",
                .dataTypeSpecific.clazz = GPBObjCClass(MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo),
                .number = MetricsInfo_NetInfo_ApiInfo_FieldNumber_DetailArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(MetricsInfo_NetInfo_ApiInfo__storage_, detailArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeMessage,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(MetricsInfo_NetInfo_ApiInfo)
                                   messageName:@"ApiInfo"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MetricsInfo_NetInfo_ApiInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        static const char *extraTextFormatInfo =
        "\002\002\007\000\003\n\000";
        [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        [localDescriptor setupContainingMessageClass:GPBObjCClass(MetricsInfo_NetInfo)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo

@implementation MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo

@dynamic name;
@dynamic hasQps, qps;
@dynamic hasFailQps, failQps;
@dynamic hasOutTraffic, outTraffic;

typedef struct MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo__storage_ {
    uint32_t _has_storage_[1];
    NSString *name;
    MetricsInfo_RateInfo *qps;
    MetricsInfo_RateInfo *failQps;
    MetricsInfo_RateInfo *outTraffic;
} MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "name",
                .dataTypeSpecific.clazz = Nil,
                .number = MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo_FieldNumber_Name,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo__storage_, name),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeString,
            },
            {
                .name = "qps",
                .dataTypeSpecific.clazz = GPBObjCClass(MetricsInfo_RateInfo),
                .number = MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo_FieldNumber_Qps,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo__storage_, qps),
                .flags = GPBFieldOptional,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "failQps",
                .dataTypeSpecific.clazz = GPBObjCClass(MetricsInfo_RateInfo),
                .number = MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo_FieldNumber_FailQps,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo__storage_, failQps),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "outTraffic",
                .dataTypeSpecific.clazz = GPBObjCClass(MetricsInfo_RateInfo),
                .number = MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo_FieldNumber_OutTraffic,
                .hasIndex = 3,
                .offset = (uint32_t)offsetof(MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo__storage_, outTraffic),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
                .dataType = GPBDataTypeMessage,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo)
                                   messageName:@"ApiDetailInfo"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        static const char *extraTextFormatInfo =
        "\002\003\007\000\004\n\000";
        [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        [localDescriptor setupContainingMessageClass:GPBObjCClass(MetricsInfo_NetInfo_ApiInfo)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - MetricsInfo_NetInfo_DisconnectionDetailInfo

@implementation MetricsInfo_NetInfo_DisconnectionDetailInfo

@dynamic reason;
@dynamic count;

typedef struct MetricsInfo_NetInfo_DisconnectionDetailInfo__storage_ {
    uint32_t _has_storage_[1];
    int32_t count;
    NSString *reason;
} MetricsInfo_NetInfo_DisconnectionDetailInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "reason",
                .dataTypeSpecific.clazz = Nil,
                .number = MetricsInfo_NetInfo_DisconnectionDetailInfo_FieldNumber_Reason,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(MetricsInfo_NetInfo_DisconnectionDetailInfo__storage_, reason),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeString,
            },
            {
                .name = "count",
                .dataTypeSpecific.clazz = Nil,
                .number = MetricsInfo_NetInfo_DisconnectionDetailInfo_FieldNumber_Count,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(MetricsInfo_NetInfo_DisconnectionDetailInfo__storage_, count),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(MetricsInfo_NetInfo_DisconnectionDetailInfo)
                                   messageName:@"DisconnectionDetailInfo"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MetricsInfo_NetInfo_DisconnectionDetailInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
        [localDescriptor setupContainingMessageClass:GPBObjCClass(MetricsInfo_NetInfo)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - MetricsInfo_NetInfo_LatencyInfo

@implementation MetricsInfo_NetInfo_LatencyInfo

@dynamic top99;
@dynamic top95;
@dynamic top75;
@dynamic totalCount;
@dynamic delay1S;
@dynamic delay2S;
@dynamic delay3S;
@dynamic detailArray, detailArray_Count;

typedef struct MetricsInfo_NetInfo_LatencyInfo__storage_ {
    uint32_t _has_storage_[1];
    int32_t top99;
    int32_t top95;
    int32_t top75;
    int32_t totalCount;
    int32_t delay1S;
    int32_t delay2S;
    int32_t delay3S;
    NSMutableArray *detailArray;
} MetricsInfo_NetInfo_LatencyInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "top99",
                .dataTypeSpecific.clazz = Nil,
                .number = MetricsInfo_NetInfo_LatencyInfo_FieldNumber_Top99,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(MetricsInfo_NetInfo_LatencyInfo__storage_, top99),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
            {
                .name = "top95",
                .dataTypeSpecific.clazz = Nil,
                .number = MetricsInfo_NetInfo_LatencyInfo_FieldNumber_Top95,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(MetricsInfo_NetInfo_LatencyInfo__storage_, top95),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
            {
                .name = "top75",
                .dataTypeSpecific.clazz = Nil,
                .number = MetricsInfo_NetInfo_LatencyInfo_FieldNumber_Top75,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(MetricsInfo_NetInfo_LatencyInfo__storage_, top75),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
            {
                .name = "totalCount",
                .dataTypeSpecific.clazz = Nil,
                .number = MetricsInfo_NetInfo_LatencyInfo_FieldNumber_TotalCount,
                .hasIndex = 3,
                .offset = (uint32_t)offsetof(MetricsInfo_NetInfo_LatencyInfo__storage_, totalCount),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
            {
                .name = "delay1S",
                .dataTypeSpecific.clazz = Nil,
                .number = MetricsInfo_NetInfo_LatencyInfo_FieldNumber_Delay1S,
                .hasIndex = 4,
                .offset = (uint32_t)offsetof(MetricsInfo_NetInfo_LatencyInfo__storage_, delay1S),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
            {
                .name = "delay2S",
                .dataTypeSpecific.clazz = Nil,
                .number = MetricsInfo_NetInfo_LatencyInfo_FieldNumber_Delay2S,
                .hasIndex = 5,
                .offset = (uint32_t)offsetof(MetricsInfo_NetInfo_LatencyInfo__storage_, delay2S),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
            {
                .name = "delay3S",
                .dataTypeSpecific.clazz = Nil,
                .number = MetricsInfo_NetInfo_LatencyInfo_FieldNumber_Delay3S,
                .hasIndex = 6,
                .offset = (uint32_t)offsetof(MetricsInfo_NetInfo_LatencyInfo__storage_, delay3S),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
            {
                .name = "detailArray",
                .dataTypeSpecific.clazz = GPBObjCClass(MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo),
                .number = MetricsInfo_NetInfo_LatencyInfo_FieldNumber_DetailArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(MetricsInfo_NetInfo_LatencyInfo__storage_, detailArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeMessage,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(MetricsInfo_NetInfo_LatencyInfo)
                                   messageName:@"LatencyInfo"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MetricsInfo_NetInfo_LatencyInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        static const char *extraTextFormatInfo =
        "\004\004\n\000\005\007\000\006\007\000\007\007\000";
        [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        [localDescriptor setupContainingMessageClass:GPBObjCClass(MetricsInfo_NetInfo)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo

@implementation MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo

@dynamic witness;
@dynamic top99;
@dynamic top95;
@dynamic top75;
@dynamic count;
@dynamic delay1S;
@dynamic delay2S;
@dynamic delay3S;

typedef struct MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo__storage_ {
    uint32_t _has_storage_[1];
    int32_t top99;
    int32_t top95;
    int32_t top75;
    int32_t count;
    int32_t delay1S;
    int32_t delay2S;
    int32_t delay3S;
    NSString *witness;
} MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "witness",
                .dataTypeSpecific.clazz = Nil,
                .number = MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo_FieldNumber_Witness,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo__storage_, witness),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeString,
            },
            {
                .name = "top99",
                .dataTypeSpecific.clazz = Nil,
                .number = MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo_FieldNumber_Top99,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo__storage_, top99),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
            {
                .name = "top95",
                .dataTypeSpecific.clazz = Nil,
                .number = MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo_FieldNumber_Top95,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo__storage_, top95),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
            {
                .name = "top75",
                .dataTypeSpecific.clazz = Nil,
                .number = MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo_FieldNumber_Top75,
                .hasIndex = 3,
                .offset = (uint32_t)offsetof(MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo__storage_, top75),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
            {
                .name = "count",
                .dataTypeSpecific.clazz = Nil,
                .number = MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo_FieldNumber_Count,
                .hasIndex = 4,
                .offset = (uint32_t)offsetof(MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo__storage_, count),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
            {
                .name = "delay1S",
                .dataTypeSpecific.clazz = Nil,
                .number = MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo_FieldNumber_Delay1S,
                .hasIndex = 5,
                .offset = (uint32_t)offsetof(MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo__storage_, delay1S),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
            {
                .name = "delay2S",
                .dataTypeSpecific.clazz = Nil,
                .number = MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo_FieldNumber_Delay2S,
                .hasIndex = 6,
                .offset = (uint32_t)offsetof(MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo__storage_, delay2S),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
            {
                .name = "delay3S",
                .dataTypeSpecific.clazz = Nil,
                .number = MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo_FieldNumber_Delay3S,
                .hasIndex = 7,
                .offset = (uint32_t)offsetof(MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo__storage_, delay3S),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo)
                                   messageName:@"LatencyDetailInfo"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        static const char *extraTextFormatInfo =
        "\003\006\007\000\007\007\000\010\007\000";
        [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        [localDescriptor setupContainingMessageClass:GPBObjCClass(MetricsInfo_NetInfo_LatencyInfo)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - PBFTMessage

@implementation PBFTMessage

@dynamic hasRawData, rawData;
@dynamic signature;

typedef struct PBFTMessage__storage_ {
    uint32_t _has_storage_[1];
    PBFTMessage_Raw *rawData;
    NSData *signature;
} PBFTMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "rawData",
                .dataTypeSpecific.clazz = GPBObjCClass(PBFTMessage_Raw),
                .number = PBFTMessage_FieldNumber_RawData,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(PBFTMessage__storage_, rawData),
                .flags = GPBFieldOptional,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "signature",
                .dataTypeSpecific.clazz = Nil,
                .number = PBFTMessage_FieldNumber_Signature,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(PBFTMessage__storage_, signature),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(PBFTMessage)
                                   messageName:@"PBFTMessage"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PBFTMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - PBFTMessage_Raw

@implementation PBFTMessage_Raw

@dynamic msgType;
@dynamic dataType;
@dynamic viewN;
@dynamic epoch;
@dynamic data_p;

typedef struct PBFTMessage_Raw__storage_ {
    uint32_t _has_storage_[1];
    PBFTMessage_MsgType msgType;
    PBFTMessage_DataType dataType;
    NSData *data_p;
    int64_t viewN;
    int64_t epoch;
} PBFTMessage_Raw__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "msgType",
                .dataTypeSpecific.enumDescFunc = PBFTMessage_MsgType_EnumDescriptor,
                .number = PBFTMessage_Raw_FieldNumber_MsgType,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(PBFTMessage_Raw__storage_, msgType),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeEnum,
            },
            {
                .name = "dataType",
                .dataTypeSpecific.enumDescFunc = PBFTMessage_DataType_EnumDescriptor,
                .number = PBFTMessage_Raw_FieldNumber_DataType,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(PBFTMessage_Raw__storage_, dataType),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeEnum,
            },
            {
                .name = "viewN",
                .dataTypeSpecific.clazz = Nil,
                .number = PBFTMessage_Raw_FieldNumber_ViewN,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(PBFTMessage_Raw__storage_, viewN),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "epoch",
                .dataTypeSpecific.clazz = Nil,
                .number = PBFTMessage_Raw_FieldNumber_Epoch,
                .hasIndex = 3,
                .offset = (uint32_t)offsetof(PBFTMessage_Raw__storage_, epoch),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "data_p",
                .dataTypeSpecific.clazz = Nil,
                .number = PBFTMessage_Raw_FieldNumber_Data_p,
                .hasIndex = 4,
                .offset = (uint32_t)offsetof(PBFTMessage_Raw__storage_, data_p),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(PBFTMessage_Raw)
                                   messageName:@"Raw"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PBFTMessage_Raw__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
        [localDescriptor setupContainingMessageClass:GPBObjCClass(PBFTMessage)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

int32_t PBFTMessage_Raw_MsgType_RawValue(PBFTMessage_Raw *message) {
    GPBDescriptor *descriptor = [PBFTMessage_Raw descriptor];
    GPBFieldDescriptor *field = [descriptor fieldWithNumber:PBFTMessage_Raw_FieldNumber_MsgType];
    return GPBGetMessageRawEnumField(message, field);
}

void SetPBFTMessage_Raw_MsgType_RawValue(PBFTMessage_Raw *message, int32_t value) {
    GPBDescriptor *descriptor = [PBFTMessage_Raw descriptor];
    GPBFieldDescriptor *field = [descriptor fieldWithNumber:PBFTMessage_Raw_FieldNumber_MsgType];
    GPBSetMessageRawEnumField(message, field, value);
}

int32_t PBFTMessage_Raw_DataType_RawValue(PBFTMessage_Raw *message) {
    GPBDescriptor *descriptor = [PBFTMessage_Raw descriptor];
    GPBFieldDescriptor *field = [descriptor fieldWithNumber:PBFTMessage_Raw_FieldNumber_DataType];
    return GPBGetMessageRawEnumField(message, field);
}

void SetPBFTMessage_Raw_DataType_RawValue(PBFTMessage_Raw *message, int32_t value) {
    GPBDescriptor *descriptor = [PBFTMessage_Raw descriptor];
    GPBFieldDescriptor *field = [descriptor fieldWithNumber:PBFTMessage_Raw_FieldNumber_DataType];
    GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - PBFTCommitResult

@implementation PBFTCommitResult

@dynamic data_p;
@dynamic signatureArray, signatureArray_Count;

typedef struct PBFTCommitResult__storage_ {
    uint32_t _has_storage_[1];
    NSData *data_p;
    NSMutableArray *signatureArray;
} PBFTCommitResult__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "data_p",
                .dataTypeSpecific.clazz = Nil,
                .number = PBFTCommitResult_FieldNumber_Data_p,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(PBFTCommitResult__storage_, data_p),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "signatureArray",
                .dataTypeSpecific.clazz = Nil,
                .number = PBFTCommitResult_FieldNumber_SignatureArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(PBFTCommitResult__storage_, signatureArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeBytes,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(PBFTCommitResult)
                                   messageName:@"PBFTCommitResult"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PBFTCommitResult__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - SRL

@implementation SRL

@dynamic srAddressArray, srAddressArray_Count;

typedef struct SRL__storage_ {
    uint32_t _has_storage_[1];
    NSMutableArray *srAddressArray;
} SRL__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "srAddressArray",
                .dataTypeSpecific.clazz = Nil,
                .number = SRL_FieldNumber_SrAddressArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(SRL__storage_, srAddressArray),
                .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
                .dataType = GPBDataTypeBytes,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SRL)
                                   messageName:@"SRL"
                               fileDescription:&TronRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SRL__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        static const char *extraTextFormatInfo =
        "\001\001\000srAddress\000";
        [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)

// clang-format on
