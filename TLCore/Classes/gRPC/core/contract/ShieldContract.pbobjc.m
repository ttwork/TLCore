// Generated by the protocol buffer compiler.  DO NOT EDIT!
// clang-format off
// source: core/contract/shield_contract.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
#define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
#import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
#import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#if GOOGLE_PROTOBUF_OBJC_VERSION < 30007
#error This file was generated by a newer version of protoc which is incompatible with your Protocol Buffer library sources.
#endif
#if 30007 < GOOGLE_PROTOBUF_OBJC_MIN_SUPPORTED_VERSION
#error This file was generated by an older version of protoc which is incompatible with your Protocol Buffer library sources.
#endif

#import "ShieldContract.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective-C Class declarations
// Forward declarations of Objective-C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(AuthenticationPath);
GPBObjCClassDeclaration(IncrementalMerkleTree);
GPBObjCClassDeclaration(IncrementalMerkleVoucher);
GPBObjCClassDeclaration(IncrementalMerkleVoucherInfo);
GPBObjCClassDeclaration(MerklePath);
GPBObjCClassDeclaration(OutputPoint);
GPBObjCClassDeclaration(OutputPointInfo);
GPBObjCClassDeclaration(PedersenHash);
GPBObjCClassDeclaration(ReceiveDescription);
GPBObjCClassDeclaration(ShieldedTransferContract);
GPBObjCClassDeclaration(SpendDescription);

#pragma mark - ShieldContractRoot

@implementation ShieldContractRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

static GPBFileDescription ShieldContractRoot_FileDescription = {
    .package = "protocol",
    .prefix = NULL,
    .syntax = GPBFileSyntaxProto3
};

#pragma mark - AuthenticationPath

@implementation AuthenticationPath

@dynamic valueArray, valueArray_Count;

typedef struct AuthenticationPath__storage_ {
    uint32_t _has_storage_[1];
    GPBBoolArray *valueArray;
} AuthenticationPath__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "valueArray",
                .dataTypeSpecific.clazz = Nil,
                .number = AuthenticationPath_FieldNumber_ValueArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(AuthenticationPath__storage_, valueArray),
                .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
                .dataType = GPBDataTypeBool,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(AuthenticationPath)
                                   messageName:@"AuthenticationPath"
                               fileDescription:&ShieldContractRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AuthenticationPath__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - MerklePath

@implementation MerklePath

@dynamic authenticationPathsArray, authenticationPathsArray_Count;
@dynamic indexArray, indexArray_Count;
@dynamic rt;

typedef struct MerklePath__storage_ {
    uint32_t _has_storage_[1];
    NSMutableArray *authenticationPathsArray;
    GPBBoolArray *indexArray;
    NSData *rt;
} MerklePath__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "authenticationPathsArray",
                .dataTypeSpecific.clazz = GPBObjCClass(AuthenticationPath),
                .number = MerklePath_FieldNumber_AuthenticationPathsArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(MerklePath__storage_, authenticationPathsArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "indexArray",
                .dataTypeSpecific.clazz = Nil,
                .number = MerklePath_FieldNumber_IndexArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(MerklePath__storage_, indexArray),
                .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
                .dataType = GPBDataTypeBool,
            },
            {
                .name = "rt",
                .dataTypeSpecific.clazz = Nil,
                .number = MerklePath_FieldNumber_Rt,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(MerklePath__storage_, rt),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(MerklePath)
                                   messageName:@"MerklePath"
                               fileDescription:&ShieldContractRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MerklePath__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - OutputPoint

@implementation OutputPoint

@dynamic hash_p;
@dynamic index;

typedef struct OutputPoint__storage_ {
    uint32_t _has_storage_[1];
    int32_t index;
    NSData *hash_p;
} OutputPoint__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "hash_p",
                .dataTypeSpecific.clazz = Nil,
                .number = OutputPoint_FieldNumber_Hash_p,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(OutputPoint__storage_, hash_p),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "index",
                .dataTypeSpecific.clazz = Nil,
                .number = OutputPoint_FieldNumber_Index,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(OutputPoint__storage_, index),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(OutputPoint)
                                   messageName:@"OutputPoint"
                               fileDescription:&ShieldContractRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OutputPoint__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - OutputPointInfo

@implementation OutputPointInfo

@dynamic outPointsArray, outPointsArray_Count;
@dynamic blockNum;

typedef struct OutputPointInfo__storage_ {
    uint32_t _has_storage_[1];
    int32_t blockNum;
    NSMutableArray *outPointsArray;
} OutputPointInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "outPointsArray",
                .dataTypeSpecific.clazz = GPBObjCClass(OutputPoint),
                .number = OutputPointInfo_FieldNumber_OutPointsArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(OutputPointInfo__storage_, outPointsArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "blockNum",
                .dataTypeSpecific.clazz = Nil,
                .number = OutputPointInfo_FieldNumber_BlockNum,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(OutputPointInfo__storage_, blockNum),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(OutputPointInfo)
                                   messageName:@"OutputPointInfo"
                               fileDescription:&ShieldContractRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OutputPointInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - PedersenHash

@implementation PedersenHash

@dynamic content;

typedef struct PedersenHash__storage_ {
    uint32_t _has_storage_[1];
    NSData *content;
} PedersenHash__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "content",
                .dataTypeSpecific.clazz = Nil,
                .number = PedersenHash_FieldNumber_Content,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(PedersenHash__storage_, content),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(PedersenHash)
                                   messageName:@"PedersenHash"
                               fileDescription:&ShieldContractRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PedersenHash__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - IncrementalMerkleTree

@implementation IncrementalMerkleTree

@dynamic hasLeft, left;
@dynamic hasRight, right;
@dynamic parentsArray, parentsArray_Count;

typedef struct IncrementalMerkleTree__storage_ {
    uint32_t _has_storage_[1];
    PedersenHash *left;
    PedersenHash *right;
    NSMutableArray *parentsArray;
} IncrementalMerkleTree__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "left",
                .dataTypeSpecific.clazz = GPBObjCClass(PedersenHash),
                .number = IncrementalMerkleTree_FieldNumber_Left,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(IncrementalMerkleTree__storage_, left),
                .flags = GPBFieldOptional,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "right",
                .dataTypeSpecific.clazz = GPBObjCClass(PedersenHash),
                .number = IncrementalMerkleTree_FieldNumber_Right,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(IncrementalMerkleTree__storage_, right),
                .flags = GPBFieldOptional,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "parentsArray",
                .dataTypeSpecific.clazz = GPBObjCClass(PedersenHash),
                .number = IncrementalMerkleTree_FieldNumber_ParentsArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(IncrementalMerkleTree__storage_, parentsArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeMessage,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(IncrementalMerkleTree)
                                   messageName:@"IncrementalMerkleTree"
                               fileDescription:&ShieldContractRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IncrementalMerkleTree__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - IncrementalMerkleVoucher

@implementation IncrementalMerkleVoucher

@dynamic hasTree, tree;
@dynamic filledArray, filledArray_Count;
@dynamic hasCursor, cursor;
@dynamic cursorDepth;
@dynamic rt;
@dynamic hasOutputPoint, outputPoint;

typedef struct IncrementalMerkleVoucher__storage_ {
    uint32_t _has_storage_[1];
    IncrementalMerkleTree *tree;
    NSMutableArray *filledArray;
    IncrementalMerkleTree *cursor;
    NSData *rt;
    OutputPoint *outputPoint;
    int64_t cursorDepth;
} IncrementalMerkleVoucher__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "tree",
                .dataTypeSpecific.clazz = GPBObjCClass(IncrementalMerkleTree),
                .number = IncrementalMerkleVoucher_FieldNumber_Tree,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(IncrementalMerkleVoucher__storage_, tree),
                .flags = GPBFieldOptional,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "filledArray",
                .dataTypeSpecific.clazz = GPBObjCClass(PedersenHash),
                .number = IncrementalMerkleVoucher_FieldNumber_FilledArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(IncrementalMerkleVoucher__storage_, filledArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "cursor",
                .dataTypeSpecific.clazz = GPBObjCClass(IncrementalMerkleTree),
                .number = IncrementalMerkleVoucher_FieldNumber_Cursor,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(IncrementalMerkleVoucher__storage_, cursor),
                .flags = GPBFieldOptional,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "cursorDepth",
                .dataTypeSpecific.clazz = Nil,
                .number = IncrementalMerkleVoucher_FieldNumber_CursorDepth,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(IncrementalMerkleVoucher__storage_, cursorDepth),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "rt",
                .dataTypeSpecific.clazz = Nil,
                .number = IncrementalMerkleVoucher_FieldNumber_Rt,
                .hasIndex = 3,
                .offset = (uint32_t)offsetof(IncrementalMerkleVoucher__storage_, rt),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "outputPoint",
                .dataTypeSpecific.clazz = GPBObjCClass(OutputPoint),
                .number = IncrementalMerkleVoucher_FieldNumber_OutputPoint,
                .hasIndex = 4,
                .offset = (uint32_t)offsetof(IncrementalMerkleVoucher__storage_, outputPoint),
                .flags = GPBFieldOptional,
                .dataType = GPBDataTypeMessage,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(IncrementalMerkleVoucher)
                                   messageName:@"IncrementalMerkleVoucher"
                               fileDescription:&ShieldContractRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IncrementalMerkleVoucher__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - IncrementalMerkleVoucherInfo

@implementation IncrementalMerkleVoucherInfo

@dynamic vouchersArray, vouchersArray_Count;
@dynamic pathsArray, pathsArray_Count;

typedef struct IncrementalMerkleVoucherInfo__storage_ {
    uint32_t _has_storage_[1];
    NSMutableArray *vouchersArray;
    NSMutableArray *pathsArray;
} IncrementalMerkleVoucherInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "vouchersArray",
                .dataTypeSpecific.clazz = GPBObjCClass(IncrementalMerkleVoucher),
                .number = IncrementalMerkleVoucherInfo_FieldNumber_VouchersArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(IncrementalMerkleVoucherInfo__storage_, vouchersArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "pathsArray",
                .dataTypeSpecific.clazz = Nil,
                .number = IncrementalMerkleVoucherInfo_FieldNumber_PathsArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(IncrementalMerkleVoucherInfo__storage_, pathsArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeBytes,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(IncrementalMerkleVoucherInfo)
                                   messageName:@"IncrementalMerkleVoucherInfo"
                               fileDescription:&ShieldContractRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IncrementalMerkleVoucherInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - SpendDescription

@implementation SpendDescription

@dynamic valueCommitment;
@dynamic anchor;
@dynamic nullifier;
@dynamic rk;
@dynamic zkproof;
@dynamic spendAuthoritySignature;

typedef struct SpendDescription__storage_ {
    uint32_t _has_storage_[1];
    NSData *valueCommitment;
    NSData *anchor;
    NSData *nullifier;
    NSData *rk;
    NSData *zkproof;
    NSData *spendAuthoritySignature;
} SpendDescription__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "valueCommitment",
                .dataTypeSpecific.clazz = Nil,
                .number = SpendDescription_FieldNumber_ValueCommitment,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(SpendDescription__storage_, valueCommitment),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "anchor",
                .dataTypeSpecific.clazz = Nil,
                .number = SpendDescription_FieldNumber_Anchor,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(SpendDescription__storage_, anchor),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "nullifier",
                .dataTypeSpecific.clazz = Nil,
                .number = SpendDescription_FieldNumber_Nullifier,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(SpendDescription__storage_, nullifier),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "rk",
                .dataTypeSpecific.clazz = Nil,
                .number = SpendDescription_FieldNumber_Rk,
                .hasIndex = 3,
                .offset = (uint32_t)offsetof(SpendDescription__storage_, rk),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "zkproof",
                .dataTypeSpecific.clazz = Nil,
                .number = SpendDescription_FieldNumber_Zkproof,
                .hasIndex = 4,
                .offset = (uint32_t)offsetof(SpendDescription__storage_, zkproof),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "spendAuthoritySignature",
                .dataTypeSpecific.clazz = Nil,
                .number = SpendDescription_FieldNumber_SpendAuthoritySignature,
                .hasIndex = 5,
                .offset = (uint32_t)offsetof(SpendDescription__storage_, spendAuthoritySignature),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SpendDescription)
                                   messageName:@"SpendDescription"
                               fileDescription:&ShieldContractRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SpendDescription__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - ReceiveDescription

@implementation ReceiveDescription

@dynamic valueCommitment;
@dynamic noteCommitment;
@dynamic epk;
@dynamic cEnc;
@dynamic cOut;
@dynamic zkproof;

typedef struct ReceiveDescription__storage_ {
    uint32_t _has_storage_[1];
    NSData *valueCommitment;
    NSData *noteCommitment;
    NSData *epk;
    NSData *cEnc;
    NSData *cOut;
    NSData *zkproof;
} ReceiveDescription__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "valueCommitment",
                .dataTypeSpecific.clazz = Nil,
                .number = ReceiveDescription_FieldNumber_ValueCommitment,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(ReceiveDescription__storage_, valueCommitment),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "noteCommitment",
                .dataTypeSpecific.clazz = Nil,
                .number = ReceiveDescription_FieldNumber_NoteCommitment,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(ReceiveDescription__storage_, noteCommitment),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "epk",
                .dataTypeSpecific.clazz = Nil,
                .number = ReceiveDescription_FieldNumber_Epk,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(ReceiveDescription__storage_, epk),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "cEnc",
                .dataTypeSpecific.clazz = Nil,
                .number = ReceiveDescription_FieldNumber_CEnc,
                .hasIndex = 3,
                .offset = (uint32_t)offsetof(ReceiveDescription__storage_, cEnc),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "cOut",
                .dataTypeSpecific.clazz = Nil,
                .number = ReceiveDescription_FieldNumber_COut,
                .hasIndex = 4,
                .offset = (uint32_t)offsetof(ReceiveDescription__storage_, cOut),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "zkproof",
                .dataTypeSpecific.clazz = Nil,
                .number = ReceiveDescription_FieldNumber_Zkproof,
                .hasIndex = 5,
                .offset = (uint32_t)offsetof(ReceiveDescription__storage_, zkproof),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ReceiveDescription)
                                   messageName:@"ReceiveDescription"
                               fileDescription:&ShieldContractRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ReceiveDescription__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - ShieldedTransferContract

@implementation ShieldedTransferContract

@dynamic transparentFromAddress;
@dynamic fromAmount;
@dynamic spendDescriptionArray, spendDescriptionArray_Count;
@dynamic receiveDescriptionArray, receiveDescriptionArray_Count;
@dynamic bindingSignature;
@dynamic transparentToAddress;
@dynamic toAmount;

typedef struct ShieldedTransferContract__storage_ {
    uint32_t _has_storage_[1];
    NSData *transparentFromAddress;
    NSMutableArray *spendDescriptionArray;
    NSMutableArray *receiveDescriptionArray;
    NSData *bindingSignature;
    NSData *transparentToAddress;
    int64_t fromAmount;
    int64_t toAmount;
} ShieldedTransferContract__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "transparentFromAddress",
                .dataTypeSpecific.clazz = Nil,
                .number = ShieldedTransferContract_FieldNumber_TransparentFromAddress,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(ShieldedTransferContract__storage_, transparentFromAddress),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "fromAmount",
                .dataTypeSpecific.clazz = Nil,
                .number = ShieldedTransferContract_FieldNumber_FromAmount,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(ShieldedTransferContract__storage_, fromAmount),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "spendDescriptionArray",
                .dataTypeSpecific.clazz = GPBObjCClass(SpendDescription),
                .number = ShieldedTransferContract_FieldNumber_SpendDescriptionArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(ShieldedTransferContract__storage_, spendDescriptionArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "receiveDescriptionArray",
                .dataTypeSpecific.clazz = GPBObjCClass(ReceiveDescription),
                .number = ShieldedTransferContract_FieldNumber_ReceiveDescriptionArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(ShieldedTransferContract__storage_, receiveDescriptionArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "bindingSignature",
                .dataTypeSpecific.clazz = Nil,
                .number = ShieldedTransferContract_FieldNumber_BindingSignature,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(ShieldedTransferContract__storage_, bindingSignature),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "transparentToAddress",
                .dataTypeSpecific.clazz = Nil,
                .number = ShieldedTransferContract_FieldNumber_TransparentToAddress,
                .hasIndex = 3,
                .offset = (uint32_t)offsetof(ShieldedTransferContract__storage_, transparentToAddress),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "toAmount",
                .dataTypeSpecific.clazz = Nil,
                .number = ShieldedTransferContract_FieldNumber_ToAmount,
                .hasIndex = 4,
                .offset = (uint32_t)offsetof(ShieldedTransferContract__storage_, toAmount),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ShieldedTransferContract)
                                   messageName:@"ShieldedTransferContract"
                               fileDescription:&ShieldContractRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ShieldedTransferContract__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)

// clang-format on
