// Generated by the protocol buffer compiler.  DO NOT EDIT!
// clang-format off
// source: api/api.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
#define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
#import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
#import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#if GOOGLE_PROTOBUF_OBJC_VERSION < 30007
#error This file was generated by a newer version of protoc which is incompatible with your Protocol Buffer library sources.
#endif
#if 30007 < GOOGLE_PROTOBUF_OBJC_MIN_SUPPORTED_VERSION
#error This file was generated by an older version of protoc which is incompatible with your Protocol Buffer library sources.
#endif

#import <stdatomic.h>

#import "Api_Tron.pbobjc.h"
#import "Tron.pbobjc.h"
#import "Annotations.pbobjc.h"
#import "AssetIssueContract.pbobjc.h"
#import "AccountContract.pbobjc.h"
#import "WitnessContract.pbobjc.h"
#import "BalanceContract.pbobjc.h"
#import "ProposalContract.pbobjc.h"
#import "StorageContract.pbobjc.h"
#import "ExchangeContract.pbobjc.h"
#import "MarketContract.pbobjc.h"
#import "SmartContract.pbobjc.h"
#import "ShieldContract.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective-C Class declarations
// Forward declarations of Objective-C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(TronAccount);
GPBObjCClassDeclaration(AccountNetMessage);
GPBObjCClassDeclaration(AccountPaginated);
GPBObjCClassDeclaration(AccountResourceMessage);
GPBObjCClassDeclaration(Address);
GPBObjCClassDeclaration(AssetIssueContract);
GPBObjCClassDeclaration(AssetIssueList);
GPBObjCClassDeclaration(Block);
GPBObjCClassDeclaration(BlockExtention);
GPBObjCClassDeclaration(BlockHeader);
GPBObjCClassDeclaration(BlockIncrementalMerkleTree);
GPBObjCClassDeclaration(BlockLimit);
GPBObjCClassDeclaration(BlockList);
GPBObjCClassDeclaration(BlockListExtention);
GPBObjCClassDeclaration(BlockReference);
GPBObjCClassDeclaration(BlockReq);
GPBObjCClassDeclaration(BytesMessage);
GPBObjCClassDeclaration(CanDelegatedMaxSizeRequestMessage);
GPBObjCClassDeclaration(CanDelegatedMaxSizeResponseMessage);
GPBObjCClassDeclaration(CanWithdrawUnfreezeAmountRequestMessage);
GPBObjCClassDeclaration(CanWithdrawUnfreezeAmountResponseMessage);
GPBObjCClassDeclaration(DecryptNotes);
GPBObjCClassDeclaration(DecryptNotesMarked);
GPBObjCClassDeclaration(DecryptNotesMarked_NoteTx);
GPBObjCClassDeclaration(DecryptNotesTRC20);
GPBObjCClassDeclaration(DecryptNotesTRC20_NoteTx);
GPBObjCClassDeclaration(DecryptNotes_NoteTx);
GPBObjCClassDeclaration(DelegatedResource);
GPBObjCClassDeclaration(DelegatedResourceList);
GPBObjCClassDeclaration(DelegatedResourceMessage);
GPBObjCClassDeclaration(DiversifierMessage);
GPBObjCClassDeclaration(EmptyMessage);
GPBObjCClassDeclaration(EstimateEnergyMessage);
GPBObjCClassDeclaration(Exchange);
GPBObjCClassDeclaration(ExchangeList);
GPBObjCClassDeclaration(ExpandedSpendingKeyMessage);
GPBObjCClassDeclaration(GetAvailableUnfreezeCountRequestMessage);
GPBObjCClassDeclaration(GetAvailableUnfreezeCountResponseMessage);
GPBObjCClassDeclaration(IncomingViewingKeyDiversifierMessage);
GPBObjCClassDeclaration(IncomingViewingKeyMessage);
GPBObjCClassDeclaration(IncrementalMerkleTree);
GPBObjCClassDeclaration(IncrementalMerkleVoucher);
GPBObjCClassDeclaration(InternalTransaction);
GPBObjCClassDeclaration(IvkDecryptAndMarkParameters);
GPBObjCClassDeclaration(IvkDecryptParameters);
GPBObjCClassDeclaration(IvkDecryptTRC20Parameters);
GPBObjCClassDeclaration(NfParameters);
GPBObjCClassDeclaration(NfTRC20Parameters);
GPBObjCClassDeclaration(Node);
GPBObjCClassDeclaration(NodeList);
GPBObjCClassDeclaration(Note);
GPBObjCClassDeclaration(NoteParameters);
GPBObjCClassDeclaration(NullifierResult);
GPBObjCClassDeclaration(NumberMessage);
GPBObjCClassDeclaration(OvkDecryptParameters);
GPBObjCClassDeclaration(OvkDecryptTRC20Parameters);
GPBObjCClassDeclaration(PaginatedMessage);
GPBObjCClassDeclaration(PaymentAddressMessage);
GPBObjCClassDeclaration(Permission);
GPBObjCClassDeclaration(PrivateParameters);
GPBObjCClassDeclaration(PrivateParametersWithoutAsk);
GPBObjCClassDeclaration(PrivateShieldedTRC20Parameters);
GPBObjCClassDeclaration(PrivateShieldedTRC20ParametersWithoutAsk);
GPBObjCClassDeclaration(Proposal);
GPBObjCClassDeclaration(ProposalList);
GPBObjCClassDeclaration(ReceiveDescription);
GPBObjCClassDeclaration(ReceiveNote);
GPBObjCClassDeclaration(Return);
GPBObjCClassDeclaration(ShieldedAddressInfo);
GPBObjCClassDeclaration(ShieldedTRC20Parameters);
GPBObjCClassDeclaration(ShieldedTRC20TriggerContractParameters);
GPBObjCClassDeclaration(SpendAuthSigParameters);
GPBObjCClassDeclaration(SpendDescription);
GPBObjCClassDeclaration(SpendNote);
GPBObjCClassDeclaration(SpendNoteTRC20);
GPBObjCClassDeclaration(SpendResult);
GPBObjCClassDeclaration(TimeMessage);
GPBObjCClassDeclaration(TimePaginatedMessage);
GPBObjCClassDeclaration(TronTransaction);
GPBObjCClassDeclaration(TransactionApprovedList);
GPBObjCClassDeclaration(TransactionApprovedList_Result);
GPBObjCClassDeclaration(TransactionExtention);
GPBObjCClassDeclaration(TransactionIdList);
GPBObjCClassDeclaration(TransactionInfo);
GPBObjCClassDeclaration(TransactionInfoList);
GPBObjCClassDeclaration(TransactionInfo_Log);
GPBObjCClassDeclaration(TransactionLimit);
GPBObjCClassDeclaration(TransactionList);
GPBObjCClassDeclaration(TransactionListExtention);
GPBObjCClassDeclaration(TransactionSignWeight);
GPBObjCClassDeclaration(TransactionSignWeight_Result);
GPBObjCClassDeclaration(ViewingKeyMessage);
GPBObjCClassDeclaration(Witness);
GPBObjCClassDeclaration(WitnessList);

#pragma mark - ApiRoot

@implementation ApiRoot

+ (GPBExtensionRegistry*)extensionRegistry {
    // This is called by +initialize so there is no need to worry
    // about thread safety and initialization of registry.
    static GPBExtensionRegistry* registry = nil;
    if (!registry) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        registry = [[GPBExtensionRegistry alloc] init];
        // Merge in the imports (direct or indirect) that defined extensions.
        [registry addExtensions:[GAPIAnnotationsRoot extensionRegistry]];
    }
    return registry;
}

@end

static GPBFileDescription ApiRoot_FileDescription = {
    .package = "protocol",
    .prefix = NULL,
    .syntax = GPBFileSyntaxProto3
};

#pragma mark - Enum Return_response_code

GPBEnumDescriptor *Return_response_code_EnumDescriptor(void) {
    static _Atomic(GPBEnumDescriptor*) descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static const char *valueNames =
        "Success\000Sigerror\000ContractValidateError\000C"
        "ontractExeError\000BandwithError\000DupTransac"
        "tionError\000TaposError\000TooBigTransactionEr"
        "ror\000TransactionExpirationError\000ServerBus"
        "y\000NoConnection\000NotEnoughEffectiveConnect"
        "ion\000OtherError\000";
        static const int32_t values[] = {
            Return_response_code_Success,
            Return_response_code_Sigerror,
            Return_response_code_ContractValidateError,
            Return_response_code_ContractExeError,
            Return_response_code_BandwithError,
            Return_response_code_DupTransactionError,
            Return_response_code_TaposError,
            Return_response_code_TooBigTransactionError,
            Return_response_code_TransactionExpirationError,
            Return_response_code_ServerBusy,
            Return_response_code_NoConnection,
            Return_response_code_NotEnoughEffectiveConnection,
            Return_response_code_OtherError,
        };
        GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Return_response_code)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Return_response_code_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None];
        GPBEnumDescriptor *expected = nil;
        if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
            [worker release];
        }
    }
    return descriptor;
}

BOOL Return_response_code_IsValidValue(int32_t value__) {
    switch (value__) {
        case Return_response_code_Success:
        case Return_response_code_Sigerror:
        case Return_response_code_ContractValidateError:
        case Return_response_code_ContractExeError:
        case Return_response_code_BandwithError:
        case Return_response_code_DupTransactionError:
        case Return_response_code_TaposError:
        case Return_response_code_TooBigTransactionError:
        case Return_response_code_TransactionExpirationError:
        case Return_response_code_ServerBusy:
        case Return_response_code_NoConnection:
        case Return_response_code_NotEnoughEffectiveConnection:
        case Return_response_code_OtherError:
            return YES;
        default:
            return NO;
    }
}

#pragma mark - Enum TransactionSignWeight_Result_response_code

GPBEnumDescriptor *TransactionSignWeight_Result_response_code_EnumDescriptor(void) {
    static _Atomic(GPBEnumDescriptor*) descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static const char *valueNames =
        "EnoughPermission\000NotEnoughPermission\000Sig"
        "natureFormatError\000ComputeAddressError\000Pe"
        "rmissionError\000OtherError\000";
        static const int32_t values[] = {
            TransactionSignWeight_Result_response_code_EnoughPermission,
            TransactionSignWeight_Result_response_code_NotEnoughPermission,
            TransactionSignWeight_Result_response_code_SignatureFormatError,
            TransactionSignWeight_Result_response_code_ComputeAddressError,
            TransactionSignWeight_Result_response_code_PermissionError,
            TransactionSignWeight_Result_response_code_OtherError,
        };
        GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(TransactionSignWeight_Result_response_code)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:TransactionSignWeight_Result_response_code_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None];
        GPBEnumDescriptor *expected = nil;
        if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
            [worker release];
        }
    }
    return descriptor;
}

BOOL TransactionSignWeight_Result_response_code_IsValidValue(int32_t value__) {
    switch (value__) {
        case TransactionSignWeight_Result_response_code_EnoughPermission:
        case TransactionSignWeight_Result_response_code_NotEnoughPermission:
        case TransactionSignWeight_Result_response_code_SignatureFormatError:
        case TransactionSignWeight_Result_response_code_ComputeAddressError:
        case TransactionSignWeight_Result_response_code_PermissionError:
        case TransactionSignWeight_Result_response_code_OtherError:
            return YES;
        default:
            return NO;
    }
}

#pragma mark - Enum TransactionApprovedList_Result_response_code

GPBEnumDescriptor *TransactionApprovedList_Result_response_code_EnumDescriptor(void) {
    static _Atomic(GPBEnumDescriptor*) descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static const char *valueNames =
        "Success\000SignatureFormatError\000ComputeAddr"
        "essError\000OtherError\000";
        static const int32_t values[] = {
            TransactionApprovedList_Result_response_code_Success,
            TransactionApprovedList_Result_response_code_SignatureFormatError,
            TransactionApprovedList_Result_response_code_ComputeAddressError,
            TransactionApprovedList_Result_response_code_OtherError,
        };
        GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(TransactionApprovedList_Result_response_code)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:TransactionApprovedList_Result_response_code_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None];
        GPBEnumDescriptor *expected = nil;
        if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
            [worker release];
        }
    }
    return descriptor;
}

BOOL TransactionApprovedList_Result_response_code_IsValidValue(int32_t value__) {
    switch (value__) {
        case TransactionApprovedList_Result_response_code_Success:
        case TransactionApprovedList_Result_response_code_SignatureFormatError:
        case TransactionApprovedList_Result_response_code_ComputeAddressError:
        case TransactionApprovedList_Result_response_code_OtherError:
            return YES;
        default:
            return NO;
    }
}

#pragma mark - Return

@implementation Return

@dynamic result;
@dynamic code;
@dynamic message;

typedef struct Return__storage_ {
    uint32_t _has_storage_[1];
    Return_response_code code;
    NSData *message;
} Return__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "result",
                .dataTypeSpecific.clazz = Nil,
                .number = Return_FieldNumber_Result,
                .hasIndex = 0,
                .offset = 1,  // Stored in _has_storage_ to save space.
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBool,
            },
            {
                .name = "code",
                .dataTypeSpecific.enumDescFunc = Return_response_code_EnumDescriptor,
                .number = Return_FieldNumber_Code,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(Return__storage_, code),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeEnum,
            },
            {
                .name = "message",
                .dataTypeSpecific.clazz = Nil,
                .number = Return_FieldNumber_Message,
                .hasIndex = 3,
                .offset = (uint32_t)offsetof(Return__storage_, message),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Return)
                                   messageName:@"Return"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Return__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

int32_t Return_Code_RawValue(Return *message) {
    GPBDescriptor *descriptor = [Return descriptor];
    GPBFieldDescriptor *field = [descriptor fieldWithNumber:Return_FieldNumber_Code];
    return GPBGetMessageRawEnumField(message, field);
}

void SetReturn_Code_RawValue(Return *message, int32_t value) {
    GPBDescriptor *descriptor = [Return descriptor];
    GPBFieldDescriptor *field = [descriptor fieldWithNumber:Return_FieldNumber_Code];
    GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - BlockReference

@implementation BlockReference

@dynamic blockNum;
@dynamic blockHash;

typedef struct BlockReference__storage_ {
    uint32_t _has_storage_[1];
    NSData *blockHash;
    int64_t blockNum;
} BlockReference__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "blockNum",
                .dataTypeSpecific.clazz = Nil,
                .number = BlockReference_FieldNumber_BlockNum,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(BlockReference__storage_, blockNum),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "blockHash",
                .dataTypeSpecific.clazz = Nil,
                .number = BlockReference_FieldNumber_BlockHash,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(BlockReference__storage_, blockHash),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(BlockReference)
                                   messageName:@"BlockReference"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockReference__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - WitnessList

@implementation WitnessList

@dynamic witnessesArray, witnessesArray_Count;

typedef struct WitnessList__storage_ {
    uint32_t _has_storage_[1];
    NSMutableArray *witnessesArray;
} WitnessList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "witnessesArray",
                .dataTypeSpecific.clazz = GPBObjCClass(Witness),
                .number = WitnessList_FieldNumber_WitnessesArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(WitnessList__storage_, witnessesArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeMessage,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(WitnessList)
                                   messageName:@"WitnessList"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(WitnessList__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - ProposalList

@implementation ProposalList

@dynamic proposalsArray, proposalsArray_Count;

typedef struct ProposalList__storage_ {
    uint32_t _has_storage_[1];
    NSMutableArray *proposalsArray;
} ProposalList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "proposalsArray",
                .dataTypeSpecific.clazz = GPBObjCClass(Proposal),
                .number = ProposalList_FieldNumber_ProposalsArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(ProposalList__storage_, proposalsArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeMessage,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ProposalList)
                                   messageName:@"ProposalList"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ProposalList__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - ExchangeList

@implementation ExchangeList

@dynamic exchangesArray, exchangesArray_Count;

typedef struct ExchangeList__storage_ {
    uint32_t _has_storage_[1];
    NSMutableArray *exchangesArray;
} ExchangeList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "exchangesArray",
                .dataTypeSpecific.clazz = GPBObjCClass(Exchange),
                .number = ExchangeList_FieldNumber_ExchangesArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(ExchangeList__storage_, exchangesArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeMessage,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ExchangeList)
                                   messageName:@"ExchangeList"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ExchangeList__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - AssetIssueList

@implementation AssetIssueList

@dynamic assetIssueArray, assetIssueArray_Count;

typedef struct AssetIssueList__storage_ {
    uint32_t _has_storage_[1];
    NSMutableArray *assetIssueArray;
} AssetIssueList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "assetIssueArray",
                .dataTypeSpecific.clazz = GPBObjCClass(AssetIssueContract),
                .number = AssetIssueList_FieldNumber_AssetIssueArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(AssetIssueList__storage_, assetIssueArray),
                .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
                .dataType = GPBDataTypeMessage,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(AssetIssueList)
                                   messageName:@"AssetIssueList"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AssetIssueList__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        static const char *extraTextFormatInfo =
        "\001\001\000assetIssue\000";
        [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - BlockList

@implementation BlockList

@dynamic blockArray, blockArray_Count;

typedef struct BlockList__storage_ {
    uint32_t _has_storage_[1];
    NSMutableArray *blockArray;
} BlockList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "blockArray",
                .dataTypeSpecific.clazz = GPBObjCClass(Block),
                .number = BlockList_FieldNumber_BlockArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(BlockList__storage_, blockArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeMessage,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(BlockList)
                                   messageName:@"BlockList"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockList__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - TransactionList

@implementation TransactionList

@dynamic transactionArray, transactionArray_Count;

typedef struct TransactionList__storage_ {
    uint32_t _has_storage_[1];
    NSMutableArray *transactionArray;
} TransactionList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "transactionArray",
                .dataTypeSpecific.clazz = GPBObjCClass(TronTransaction),
                .number = TransactionList_FieldNumber_TransactionArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(TransactionList__storage_, transactionArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeMessage,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(TransactionList)
                                   messageName:@"TransactionList"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransactionList__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - TransactionIdList

@implementation TransactionIdList

@dynamic txIdArray, txIdArray_Count;

typedef struct TransactionIdList__storage_ {
    uint32_t _has_storage_[1];
    NSMutableArray *txIdArray;
} TransactionIdList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "txIdArray",
                .dataTypeSpecific.clazz = Nil,
                .number = TransactionIdList_FieldNumber_TxIdArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(TransactionIdList__storage_, txIdArray),
                .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
                .dataType = GPBDataTypeString,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(TransactionIdList)
                                   messageName:@"TransactionIdList"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransactionIdList__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        static const char *extraTextFormatInfo =
        "\001\001\000txId\000";
        [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - DelegatedResourceMessage

@implementation DelegatedResourceMessage

@dynamic fromAddress;
@dynamic toAddress;

typedef struct DelegatedResourceMessage__storage_ {
    uint32_t _has_storage_[1];
    NSData *fromAddress;
    NSData *toAddress;
} DelegatedResourceMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "fromAddress",
                .dataTypeSpecific.clazz = Nil,
                .number = DelegatedResourceMessage_FieldNumber_FromAddress,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(DelegatedResourceMessage__storage_, fromAddress),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "toAddress",
                .dataTypeSpecific.clazz = Nil,
                .number = DelegatedResourceMessage_FieldNumber_ToAddress,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(DelegatedResourceMessage__storage_, toAddress),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(DelegatedResourceMessage)
                                   messageName:@"DelegatedResourceMessage"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DelegatedResourceMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        static const char *extraTextFormatInfo =
        "\002\001\013\000\002\t\000";
        [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - DelegatedResourceList

@implementation DelegatedResourceList

@dynamic delegatedResourceArray, delegatedResourceArray_Count;

typedef struct DelegatedResourceList__storage_ {
    uint32_t _has_storage_[1];
    NSMutableArray *delegatedResourceArray;
} DelegatedResourceList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "delegatedResourceArray",
                .dataTypeSpecific.clazz = GPBObjCClass(DelegatedResource),
                .number = DelegatedResourceList_FieldNumber_DelegatedResourceArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(DelegatedResourceList__storage_, delegatedResourceArray),
                .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
                .dataType = GPBDataTypeMessage,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(DelegatedResourceList)
                                   messageName:@"DelegatedResourceList"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DelegatedResourceList__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        static const char *extraTextFormatInfo =
        "\001\001\000delegatedResource\000";
        [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - GetAvailableUnfreezeCountRequestMessage

@implementation GetAvailableUnfreezeCountRequestMessage

@dynamic ownerAddress;

typedef struct GetAvailableUnfreezeCountRequestMessage__storage_ {
    uint32_t _has_storage_[1];
    NSData *ownerAddress;
} GetAvailableUnfreezeCountRequestMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "ownerAddress",
                .dataTypeSpecific.clazz = Nil,
                .number = GetAvailableUnfreezeCountRequestMessage_FieldNumber_OwnerAddress,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(GetAvailableUnfreezeCountRequestMessage__storage_, ownerAddress),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(GetAvailableUnfreezeCountRequestMessage)
                                   messageName:@"GetAvailableUnfreezeCountRequestMessage"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetAvailableUnfreezeCountRequestMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - GetAvailableUnfreezeCountResponseMessage

@implementation GetAvailableUnfreezeCountResponseMessage

@dynamic count;

typedef struct GetAvailableUnfreezeCountResponseMessage__storage_ {
    uint32_t _has_storage_[1];
    int64_t count;
} GetAvailableUnfreezeCountResponseMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "count",
                .dataTypeSpecific.clazz = Nil,
                .number = GetAvailableUnfreezeCountResponseMessage_FieldNumber_Count,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(GetAvailableUnfreezeCountResponseMessage__storage_, count),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(GetAvailableUnfreezeCountResponseMessage)
                                   messageName:@"GetAvailableUnfreezeCountResponseMessage"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetAvailableUnfreezeCountResponseMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - CanDelegatedMaxSizeRequestMessage

@implementation CanDelegatedMaxSizeRequestMessage

@dynamic type;
@dynamic ownerAddress;

typedef struct CanDelegatedMaxSizeRequestMessage__storage_ {
    uint32_t _has_storage_[1];
    int32_t type;
    NSData *ownerAddress;
} CanDelegatedMaxSizeRequestMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "type",
                .dataTypeSpecific.clazz = Nil,
                .number = CanDelegatedMaxSizeRequestMessage_FieldNumber_Type,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(CanDelegatedMaxSizeRequestMessage__storage_, type),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
            {
                .name = "ownerAddress",
                .dataTypeSpecific.clazz = Nil,
                .number = CanDelegatedMaxSizeRequestMessage_FieldNumber_OwnerAddress,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(CanDelegatedMaxSizeRequestMessage__storage_, ownerAddress),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(CanDelegatedMaxSizeRequestMessage)
                                   messageName:@"CanDelegatedMaxSizeRequestMessage"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CanDelegatedMaxSizeRequestMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - CanDelegatedMaxSizeResponseMessage

@implementation CanDelegatedMaxSizeResponseMessage

@dynamic maxSize;

typedef struct CanDelegatedMaxSizeResponseMessage__storage_ {
    uint32_t _has_storage_[1];
    int64_t maxSize;
} CanDelegatedMaxSizeResponseMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "maxSize",
                .dataTypeSpecific.clazz = Nil,
                .number = CanDelegatedMaxSizeResponseMessage_FieldNumber_MaxSize,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(CanDelegatedMaxSizeResponseMessage__storage_, maxSize),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(CanDelegatedMaxSizeResponseMessage)
                                   messageName:@"CanDelegatedMaxSizeResponseMessage"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CanDelegatedMaxSizeResponseMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - CanWithdrawUnfreezeAmountRequestMessage

@implementation CanWithdrawUnfreezeAmountRequestMessage

@dynamic ownerAddress;
@dynamic timestamp;

typedef struct CanWithdrawUnfreezeAmountRequestMessage__storage_ {
    uint32_t _has_storage_[1];
    NSData *ownerAddress;
    int64_t timestamp;
} CanWithdrawUnfreezeAmountRequestMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "ownerAddress",
                .dataTypeSpecific.clazz = Nil,
                .number = CanWithdrawUnfreezeAmountRequestMessage_FieldNumber_OwnerAddress,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(CanWithdrawUnfreezeAmountRequestMessage__storage_, ownerAddress),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "timestamp",
                .dataTypeSpecific.clazz = Nil,
                .number = CanWithdrawUnfreezeAmountRequestMessage_FieldNumber_Timestamp,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(CanWithdrawUnfreezeAmountRequestMessage__storage_, timestamp),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(CanWithdrawUnfreezeAmountRequestMessage)
                                   messageName:@"CanWithdrawUnfreezeAmountRequestMessage"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CanWithdrawUnfreezeAmountRequestMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - CanWithdrawUnfreezeAmountResponseMessage

@implementation CanWithdrawUnfreezeAmountResponseMessage

@dynamic amount;

typedef struct CanWithdrawUnfreezeAmountResponseMessage__storage_ {
    uint32_t _has_storage_[1];
    int64_t amount;
} CanWithdrawUnfreezeAmountResponseMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "amount",
                .dataTypeSpecific.clazz = Nil,
                .number = CanWithdrawUnfreezeAmountResponseMessage_FieldNumber_Amount,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(CanWithdrawUnfreezeAmountResponseMessage__storage_, amount),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(CanWithdrawUnfreezeAmountResponseMessage)
                                   messageName:@"CanWithdrawUnfreezeAmountResponseMessage"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CanWithdrawUnfreezeAmountResponseMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - NodeList

@implementation NodeList

@dynamic nodesArray, nodesArray_Count;

typedef struct NodeList__storage_ {
    uint32_t _has_storage_[1];
    NSMutableArray *nodesArray;
} NodeList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "nodesArray",
                .dataTypeSpecific.clazz = GPBObjCClass(Node),
                .number = NodeList_FieldNumber_NodesArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(NodeList__storage_, nodesArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeMessage,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(NodeList)
                                   messageName:@"NodeList"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NodeList__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - Node

@implementation Node

@dynamic hasAddress, address;

typedef struct Node__storage_ {
    uint32_t _has_storage_[1];
    Address *address;
} Node__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "address",
                .dataTypeSpecific.clazz = GPBObjCClass(Address),
                .number = Node_FieldNumber_Address,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(Node__storage_, address),
                .flags = GPBFieldOptional,
                .dataType = GPBDataTypeMessage,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Node)
                                   messageName:@"Node"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Node__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - Address

@implementation Address

@dynamic host;
@dynamic port;

typedef struct Address__storage_ {
    uint32_t _has_storage_[1];
    int32_t port;
    NSData *host;
} Address__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "host",
                .dataTypeSpecific.clazz = Nil,
                .number = Address_FieldNumber_Host,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(Address__storage_, host),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "port",
                .dataTypeSpecific.clazz = Nil,
                .number = Address_FieldNumber_Port,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(Address__storage_, port),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Address)
                                   messageName:@"Address"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Address__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - EmptyMessage

@implementation EmptyMessage


typedef struct EmptyMessage__storage_ {
    uint32_t _has_storage_[1];
} EmptyMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(EmptyMessage)
                                   messageName:@"EmptyMessage"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(EmptyMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - NumberMessage

@implementation NumberMessage

@dynamic num;

typedef struct NumberMessage__storage_ {
    uint32_t _has_storage_[1];
    int64_t num;
} NumberMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "num",
                .dataTypeSpecific.clazz = Nil,
                .number = NumberMessage_FieldNumber_Num,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(NumberMessage__storage_, num),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(NumberMessage)
                                   messageName:@"NumberMessage"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NumberMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - BytesMessage

@implementation BytesMessage

@dynamic value;

typedef struct BytesMessage__storage_ {
    uint32_t _has_storage_[1];
    NSData *value;
} BytesMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "value",
                .dataTypeSpecific.clazz = Nil,
                .number = BytesMessage_FieldNumber_Value,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(BytesMessage__storage_, value),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(BytesMessage)
                                   messageName:@"BytesMessage"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BytesMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - TimeMessage

@implementation TimeMessage

@dynamic beginInMilliseconds;
@dynamic endInMilliseconds;

typedef struct TimeMessage__storage_ {
    uint32_t _has_storage_[1];
    int64_t beginInMilliseconds;
    int64_t endInMilliseconds;
} TimeMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "beginInMilliseconds",
                .dataTypeSpecific.clazz = Nil,
                .number = TimeMessage_FieldNumber_BeginInMilliseconds,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(TimeMessage__storage_, beginInMilliseconds),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "endInMilliseconds",
                .dataTypeSpecific.clazz = Nil,
                .number = TimeMessage_FieldNumber_EndInMilliseconds,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(TimeMessage__storage_, endInMilliseconds),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(TimeMessage)
                                   messageName:@"TimeMessage"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TimeMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        static const char *extraTextFormatInfo =
        "\002\001\023\000\002\021\000";
        [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - BlockReq

@implementation BlockReq

@dynamic idOrNum;
@dynamic detail;

typedef struct BlockReq__storage_ {
    uint32_t _has_storage_[1];
    NSString *idOrNum;
} BlockReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "idOrNum",
                .dataTypeSpecific.clazz = Nil,
                .number = BlockReq_FieldNumber_IdOrNum,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(BlockReq__storage_, idOrNum),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeString,
            },
            {
                .name = "detail",
                .dataTypeSpecific.clazz = Nil,
                .number = BlockReq_FieldNumber_Detail,
                .hasIndex = 1,
                .offset = 2,  // Stored in _has_storage_ to save space.
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBool,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(BlockReq)
                                   messageName:@"BlockReq"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - BlockLimit

@implementation BlockLimit

@dynamic startNum;
@dynamic endNum;

typedef struct BlockLimit__storage_ {
    uint32_t _has_storage_[1];
    int64_t startNum;
    int64_t endNum;
} BlockLimit__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "startNum",
                .dataTypeSpecific.clazz = Nil,
                .number = BlockLimit_FieldNumber_StartNum,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(BlockLimit__storage_, startNum),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "endNum",
                .dataTypeSpecific.clazz = Nil,
                .number = BlockLimit_FieldNumber_EndNum,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(BlockLimit__storage_, endNum),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(BlockLimit)
                                   messageName:@"BlockLimit"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockLimit__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        static const char *extraTextFormatInfo =
        "\002\001\010\000\002\006\000";
        [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - TransactionLimit

@implementation TransactionLimit

@dynamic transactionId;
@dynamic limitNum;

typedef struct TransactionLimit__storage_ {
    uint32_t _has_storage_[1];
    NSData *transactionId;
    int64_t limitNum;
} TransactionLimit__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "transactionId",
                .dataTypeSpecific.clazz = Nil,
                .number = TransactionLimit_FieldNumber_TransactionId,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(TransactionLimit__storage_, transactionId),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "limitNum",
                .dataTypeSpecific.clazz = Nil,
                .number = TransactionLimit_FieldNumber_LimitNum,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(TransactionLimit__storage_, limitNum),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(TransactionLimit)
                                   messageName:@"TransactionLimit"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransactionLimit__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        static const char *extraTextFormatInfo =
        "\002\001\r\000\002\010\000";
        [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - AccountPaginated

@implementation AccountPaginated

@dynamic hasAccount, account;
@dynamic offset;
@dynamic limit;

typedef struct AccountPaginated__storage_ {
    uint32_t _has_storage_[1];
    TronAccount *account;
    int64_t offset;
    int64_t limit;
} AccountPaginated__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "account",
                .dataTypeSpecific.clazz = GPBObjCClass(TronAccount),
                .number = AccountPaginated_FieldNumber_Account,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(AccountPaginated__storage_, account),
                .flags = GPBFieldOptional,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "offset",
                .dataTypeSpecific.clazz = Nil,
                .number = AccountPaginated_FieldNumber_Offset,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(AccountPaginated__storage_, offset),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "limit",
                .dataTypeSpecific.clazz = Nil,
                .number = AccountPaginated_FieldNumber_Limit,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(AccountPaginated__storage_, limit),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(AccountPaginated)
                                   messageName:@"AccountPaginated"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AccountPaginated__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - TimePaginatedMessage

@implementation TimePaginatedMessage

@dynamic hasTimeMessage, timeMessage;
@dynamic offset;
@dynamic limit;

typedef struct TimePaginatedMessage__storage_ {
    uint32_t _has_storage_[1];
    TimeMessage *timeMessage;
    int64_t offset;
    int64_t limit;
} TimePaginatedMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "timeMessage",
                .dataTypeSpecific.clazz = GPBObjCClass(TimeMessage),
                .number = TimePaginatedMessage_FieldNumber_TimeMessage,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(TimePaginatedMessage__storage_, timeMessage),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "offset",
                .dataTypeSpecific.clazz = Nil,
                .number = TimePaginatedMessage_FieldNumber_Offset,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(TimePaginatedMessage__storage_, offset),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "limit",
                .dataTypeSpecific.clazz = Nil,
                .number = TimePaginatedMessage_FieldNumber_Limit,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(TimePaginatedMessage__storage_, limit),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(TimePaginatedMessage)
                                   messageName:@"TimePaginatedMessage"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TimePaginatedMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        static const char *extraTextFormatInfo =
        "\001\001\013\000";
        [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - AccountNetMessage

@implementation AccountNetMessage

@dynamic freeNetUsed;
@dynamic freeNetLimit;
@dynamic netUsed;
@dynamic netLimit;
@dynamic assetNetUsed, assetNetUsed_Count;
@dynamic assetNetLimit, assetNetLimit_Count;
@dynamic totalNetLimit;
@dynamic totalNetWeight;

typedef struct AccountNetMessage__storage_ {
    uint32_t _has_storage_[1];
    GPBStringInt64Dictionary *assetNetUsed;
    GPBStringInt64Dictionary *assetNetLimit;
    int64_t freeNetUsed;
    int64_t freeNetLimit;
    int64_t netUsed;
    int64_t netLimit;
    int64_t totalNetLimit;
    int64_t totalNetWeight;
} AccountNetMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "freeNetUsed",
                .dataTypeSpecific.clazz = Nil,
                .number = AccountNetMessage_FieldNumber_FreeNetUsed,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(AccountNetMessage__storage_, freeNetUsed),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "freeNetLimit",
                .dataTypeSpecific.clazz = Nil,
                .number = AccountNetMessage_FieldNumber_FreeNetLimit,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(AccountNetMessage__storage_, freeNetLimit),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "netUsed",
                .dataTypeSpecific.clazz = Nil,
                .number = AccountNetMessage_FieldNumber_NetUsed,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(AccountNetMessage__storage_, netUsed),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "netLimit",
                .dataTypeSpecific.clazz = Nil,
                .number = AccountNetMessage_FieldNumber_NetLimit,
                .hasIndex = 3,
                .offset = (uint32_t)offsetof(AccountNetMessage__storage_, netLimit),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "assetNetUsed",
                .dataTypeSpecific.clazz = Nil,
                .number = AccountNetMessage_FieldNumber_AssetNetUsed,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(AccountNetMessage__storage_, assetNetUsed),
                .flags = (GPBFieldFlags)(GPBFieldMapKeyString | GPBFieldTextFormatNameCustom),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "assetNetLimit",
                .dataTypeSpecific.clazz = Nil,
                .number = AccountNetMessage_FieldNumber_AssetNetLimit,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(AccountNetMessage__storage_, assetNetLimit),
                .flags = (GPBFieldFlags)(GPBFieldMapKeyString | GPBFieldTextFormatNameCustom),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "totalNetLimit",
                .dataTypeSpecific.clazz = Nil,
                .number = AccountNetMessage_FieldNumber_TotalNetLimit,
                .hasIndex = 4,
                .offset = (uint32_t)offsetof(AccountNetMessage__storage_, totalNetLimit),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "totalNetWeight",
                .dataTypeSpecific.clazz = Nil,
                .number = AccountNetMessage_FieldNumber_TotalNetWeight,
                .hasIndex = 5,
                .offset = (uint32_t)offsetof(AccountNetMessage__storage_, totalNetWeight),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(AccountNetMessage)
                                   messageName:@"AccountNetMessage"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AccountNetMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        static const char *extraTextFormatInfo =
        "\010\001\013\000\002\014\000\003G\000\004H\000\005\014\000\006\r\000\007M\000\010N\000";
        [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - AccountResourceMessage

@implementation AccountResourceMessage

@dynamic freeNetUsed;
@dynamic freeNetLimit;
@dynamic netUsed;
@dynamic netLimit;
@dynamic assetNetUsed, assetNetUsed_Count;
@dynamic assetNetLimit, assetNetLimit_Count;
@dynamic totalNetLimit;
@dynamic totalNetWeight;
@dynamic totalTronPowerWeight;
@dynamic tronPowerUsed;
@dynamic tronPowerLimit;
@dynamic energyUsed;
@dynamic energyLimit;
@dynamic totalEnergyLimit;
@dynamic totalEnergyWeight;
@dynamic storageUsed;
@dynamic storageLimit;

typedef struct AccountResourceMessage__storage_ {
    uint32_t _has_storage_[1];
    GPBStringInt64Dictionary *assetNetUsed;
    GPBStringInt64Dictionary *assetNetLimit;
    int64_t freeNetUsed;
    int64_t freeNetLimit;
    int64_t netUsed;
    int64_t netLimit;
    int64_t totalNetLimit;
    int64_t totalNetWeight;
    int64_t totalTronPowerWeight;
    int64_t tronPowerUsed;
    int64_t tronPowerLimit;
    int64_t energyUsed;
    int64_t energyLimit;
    int64_t totalEnergyLimit;
    int64_t totalEnergyWeight;
    int64_t storageUsed;
    int64_t storageLimit;
} AccountResourceMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "freeNetUsed",
                .dataTypeSpecific.clazz = Nil,
                .number = AccountResourceMessage_FieldNumber_FreeNetUsed,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(AccountResourceMessage__storage_, freeNetUsed),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "freeNetLimit",
                .dataTypeSpecific.clazz = Nil,
                .number = AccountResourceMessage_FieldNumber_FreeNetLimit,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(AccountResourceMessage__storage_, freeNetLimit),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "netUsed",
                .dataTypeSpecific.clazz = Nil,
                .number = AccountResourceMessage_FieldNumber_NetUsed,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(AccountResourceMessage__storage_, netUsed),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "netLimit",
                .dataTypeSpecific.clazz = Nil,
                .number = AccountResourceMessage_FieldNumber_NetLimit,
                .hasIndex = 3,
                .offset = (uint32_t)offsetof(AccountResourceMessage__storage_, netLimit),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "assetNetUsed",
                .dataTypeSpecific.clazz = Nil,
                .number = AccountResourceMessage_FieldNumber_AssetNetUsed,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(AccountResourceMessage__storage_, assetNetUsed),
                .flags = (GPBFieldFlags)(GPBFieldMapKeyString | GPBFieldTextFormatNameCustom),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "assetNetLimit",
                .dataTypeSpecific.clazz = Nil,
                .number = AccountResourceMessage_FieldNumber_AssetNetLimit,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(AccountResourceMessage__storage_, assetNetLimit),
                .flags = (GPBFieldFlags)(GPBFieldMapKeyString | GPBFieldTextFormatNameCustom),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "totalNetLimit",
                .dataTypeSpecific.clazz = Nil,
                .number = AccountResourceMessage_FieldNumber_TotalNetLimit,
                .hasIndex = 4,
                .offset = (uint32_t)offsetof(AccountResourceMessage__storage_, totalNetLimit),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "totalNetWeight",
                .dataTypeSpecific.clazz = Nil,
                .number = AccountResourceMessage_FieldNumber_TotalNetWeight,
                .hasIndex = 5,
                .offset = (uint32_t)offsetof(AccountResourceMessage__storage_, totalNetWeight),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "totalTronPowerWeight",
                .dataTypeSpecific.clazz = Nil,
                .number = AccountResourceMessage_FieldNumber_TotalTronPowerWeight,
                .hasIndex = 6,
                .offset = (uint32_t)offsetof(AccountResourceMessage__storage_, totalTronPowerWeight),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "tronPowerUsed",
                .dataTypeSpecific.clazz = Nil,
                .number = AccountResourceMessage_FieldNumber_TronPowerUsed,
                .hasIndex = 7,
                .offset = (uint32_t)offsetof(AccountResourceMessage__storage_, tronPowerUsed),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "tronPowerLimit",
                .dataTypeSpecific.clazz = Nil,
                .number = AccountResourceMessage_FieldNumber_TronPowerLimit,
                .hasIndex = 8,
                .offset = (uint32_t)offsetof(AccountResourceMessage__storage_, tronPowerLimit),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "energyUsed",
                .dataTypeSpecific.clazz = Nil,
                .number = AccountResourceMessage_FieldNumber_EnergyUsed,
                .hasIndex = 9,
                .offset = (uint32_t)offsetof(AccountResourceMessage__storage_, energyUsed),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "energyLimit",
                .dataTypeSpecific.clazz = Nil,
                .number = AccountResourceMessage_FieldNumber_EnergyLimit,
                .hasIndex = 10,
                .offset = (uint32_t)offsetof(AccountResourceMessage__storage_, energyLimit),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "totalEnergyLimit",
                .dataTypeSpecific.clazz = Nil,
                .number = AccountResourceMessage_FieldNumber_TotalEnergyLimit,
                .hasIndex = 11,
                .offset = (uint32_t)offsetof(AccountResourceMessage__storage_, totalEnergyLimit),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "totalEnergyWeight",
                .dataTypeSpecific.clazz = Nil,
                .number = AccountResourceMessage_FieldNumber_TotalEnergyWeight,
                .hasIndex = 12,
                .offset = (uint32_t)offsetof(AccountResourceMessage__storage_, totalEnergyWeight),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "storageUsed",
                .dataTypeSpecific.clazz = Nil,
                .number = AccountResourceMessage_FieldNumber_StorageUsed,
                .hasIndex = 13,
                .offset = (uint32_t)offsetof(AccountResourceMessage__storage_, storageUsed),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "storageLimit",
                .dataTypeSpecific.clazz = Nil,
                .number = AccountResourceMessage_FieldNumber_StorageLimit,
                .hasIndex = 14,
                .offset = (uint32_t)offsetof(AccountResourceMessage__storage_, storageLimit),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(AccountResourceMessage)
                                   messageName:@"AccountResourceMessage"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AccountResourceMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        static const char *extraTextFormatInfo =
        "\021\001\013\000\002\014\000\003G\000\004H\000\005\014\000\006\r\000\007M\000\010N\000\tT\000\n\r\000\013\016\000\rJ\000\016K\000"
        "\017P\000\020Q\000\025\013\000\026\014\000";
        [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - PaginatedMessage

@implementation PaginatedMessage

@dynamic offset;
@dynamic limit;

typedef struct PaginatedMessage__storage_ {
    uint32_t _has_storage_[1];
    int64_t offset;
    int64_t limit;
} PaginatedMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "offset",
                .dataTypeSpecific.clazz = Nil,
                .number = PaginatedMessage_FieldNumber_Offset,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(PaginatedMessage__storage_, offset),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "limit",
                .dataTypeSpecific.clazz = Nil,
                .number = PaginatedMessage_FieldNumber_Limit,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(PaginatedMessage__storage_, limit),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(PaginatedMessage)
                                   messageName:@"PaginatedMessage"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PaginatedMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - TransactionExtention

@implementation TransactionExtention

@dynamic hasTransaction, transaction;
@dynamic txid;
@dynamic constantResultArray, constantResultArray_Count;
@dynamic hasResult, result;
@dynamic energyUsed;
@dynamic logsArray, logsArray_Count;
@dynamic internalTransactionsArray, internalTransactionsArray_Count;
@dynamic energyPenalty;

typedef struct TransactionExtention__storage_ {
    uint32_t _has_storage_[1];
    TronTransaction *transaction;
    NSData *txid;
    NSMutableArray *constantResultArray;
    Return *result;
    NSMutableArray *logsArray;
    NSMutableArray *internalTransactionsArray;
    int64_t energyUsed;
    int64_t energyPenalty;
} TransactionExtention__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "transaction",
                .dataTypeSpecific.clazz = GPBObjCClass(TronTransaction),
                .number = TransactionExtention_FieldNumber_Transaction,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(TransactionExtention__storage_, transaction),
                .flags = GPBFieldOptional,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "txid",
                .dataTypeSpecific.clazz = Nil,
                .number = TransactionExtention_FieldNumber_Txid,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(TransactionExtention__storage_, txid),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "constantResultArray",
                .dataTypeSpecific.clazz = Nil,
                .number = TransactionExtention_FieldNumber_ConstantResultArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(TransactionExtention__storage_, constantResultArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "result",
                .dataTypeSpecific.clazz = GPBObjCClass(Return),
                .number = TransactionExtention_FieldNumber_Result,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(TransactionExtention__storage_, result),
                .flags = GPBFieldOptional,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "energyUsed",
                .dataTypeSpecific.clazz = Nil,
                .number = TransactionExtention_FieldNumber_EnergyUsed,
                .hasIndex = 3,
                .offset = (uint32_t)offsetof(TransactionExtention__storage_, energyUsed),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "logsArray",
                .dataTypeSpecific.clazz = GPBObjCClass(TransactionInfo_Log),
                .number = TransactionExtention_FieldNumber_LogsArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(TransactionExtention__storage_, logsArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "internalTransactionsArray",
                .dataTypeSpecific.clazz = GPBObjCClass(InternalTransaction),
                .number = TransactionExtention_FieldNumber_InternalTransactionsArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(TransactionExtention__storage_, internalTransactionsArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "energyPenalty",
                .dataTypeSpecific.clazz = Nil,
                .number = TransactionExtention_FieldNumber_EnergyPenalty,
                .hasIndex = 4,
                .offset = (uint32_t)offsetof(TransactionExtention__storage_, energyPenalty),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(TransactionExtention)
                                   messageName:@"TransactionExtention"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransactionExtention__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - EstimateEnergyMessage

@implementation EstimateEnergyMessage

@dynamic hasResult, result;
@dynamic energyRequired;

typedef struct EstimateEnergyMessage__storage_ {
    uint32_t _has_storage_[1];
    Return *result;
    int64_t energyRequired;
} EstimateEnergyMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "result",
                .dataTypeSpecific.clazz = GPBObjCClass(Return),
                .number = EstimateEnergyMessage_FieldNumber_Result,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(EstimateEnergyMessage__storage_, result),
                .flags = GPBFieldOptional,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "energyRequired",
                .dataTypeSpecific.clazz = Nil,
                .number = EstimateEnergyMessage_FieldNumber_EnergyRequired,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(EstimateEnergyMessage__storage_, energyRequired),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(EstimateEnergyMessage)
                                   messageName:@"EstimateEnergyMessage"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EstimateEnergyMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - BlockExtention

@implementation BlockExtention

@dynamic transactionsArray, transactionsArray_Count;
@dynamic hasBlockHeader, blockHeader;
@dynamic blockid;

typedef struct BlockExtention__storage_ {
    uint32_t _has_storage_[1];
    NSMutableArray *transactionsArray;
    BlockHeader *blockHeader;
    NSData *blockid;
} BlockExtention__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "transactionsArray",
                .dataTypeSpecific.clazz = GPBObjCClass(TransactionExtention),
                .number = BlockExtention_FieldNumber_TransactionsArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(BlockExtention__storage_, transactionsArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "blockHeader",
                .dataTypeSpecific.clazz = GPBObjCClass(BlockHeader),
                .number = BlockExtention_FieldNumber_BlockHeader,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(BlockExtention__storage_, blockHeader),
                .flags = GPBFieldOptional,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "blockid",
                .dataTypeSpecific.clazz = Nil,
                .number = BlockExtention_FieldNumber_Blockid,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(BlockExtention__storage_, blockid),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(BlockExtention)
                                   messageName:@"BlockExtention"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockExtention__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - BlockListExtention

@implementation BlockListExtention

@dynamic blockArray, blockArray_Count;

typedef struct BlockListExtention__storage_ {
    uint32_t _has_storage_[1];
    NSMutableArray *blockArray;
} BlockListExtention__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "blockArray",
                .dataTypeSpecific.clazz = GPBObjCClass(BlockExtention),
                .number = BlockListExtention_FieldNumber_BlockArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(BlockListExtention__storage_, blockArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeMessage,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(BlockListExtention)
                                   messageName:@"BlockListExtention"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockListExtention__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - TransactionListExtention

@implementation TransactionListExtention

@dynamic transactionArray, transactionArray_Count;

typedef struct TransactionListExtention__storage_ {
    uint32_t _has_storage_[1];
    NSMutableArray *transactionArray;
} TransactionListExtention__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "transactionArray",
                .dataTypeSpecific.clazz = GPBObjCClass(TransactionExtention),
                .number = TransactionListExtention_FieldNumber_TransactionArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(TransactionListExtention__storage_, transactionArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeMessage,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(TransactionListExtention)
                                   messageName:@"TransactionListExtention"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransactionListExtention__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - BlockIncrementalMerkleTree

@implementation BlockIncrementalMerkleTree

@dynamic number;
@dynamic hasMerkleTree, merkleTree;

typedef struct BlockIncrementalMerkleTree__storage_ {
    uint32_t _has_storage_[1];
    IncrementalMerkleTree *merkleTree;
    int64_t number;
} BlockIncrementalMerkleTree__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "number",
                .dataTypeSpecific.clazz = Nil,
                .number = BlockIncrementalMerkleTree_FieldNumber_Number,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(BlockIncrementalMerkleTree__storage_, number),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "merkleTree",
                .dataTypeSpecific.clazz = GPBObjCClass(IncrementalMerkleTree),
                .number = BlockIncrementalMerkleTree_FieldNumber_MerkleTree,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(BlockIncrementalMerkleTree__storage_, merkleTree),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
                .dataType = GPBDataTypeMessage,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(BlockIncrementalMerkleTree)
                                   messageName:@"BlockIncrementalMerkleTree"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockIncrementalMerkleTree__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        static const char *extraTextFormatInfo =
        "\001\002\n\000";
        [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - TransactionSignWeight

@implementation TransactionSignWeight

@dynamic hasPermission, permission;
@dynamic approvedListArray, approvedListArray_Count;
@dynamic currentWeight;
@dynamic hasResult, result;
@dynamic hasTransaction, transaction;

typedef struct TransactionSignWeight__storage_ {
    uint32_t _has_storage_[1];
    Permission *permission;
    NSMutableArray *approvedListArray;
    TransactionSignWeight_Result *result;
    TransactionExtention *transaction;
    int64_t currentWeight;
} TransactionSignWeight__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "permission",
                .dataTypeSpecific.clazz = GPBObjCClass(Permission),
                .number = TransactionSignWeight_FieldNumber_Permission,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(TransactionSignWeight__storage_, permission),
                .flags = GPBFieldOptional,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "approvedListArray",
                .dataTypeSpecific.clazz = Nil,
                .number = TransactionSignWeight_FieldNumber_ApprovedListArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(TransactionSignWeight__storage_, approvedListArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "currentWeight",
                .dataTypeSpecific.clazz = Nil,
                .number = TransactionSignWeight_FieldNumber_CurrentWeight,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(TransactionSignWeight__storage_, currentWeight),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "result",
                .dataTypeSpecific.clazz = GPBObjCClass(TransactionSignWeight_Result),
                .number = TransactionSignWeight_FieldNumber_Result,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(TransactionSignWeight__storage_, result),
                .flags = GPBFieldOptional,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "transaction",
                .dataTypeSpecific.clazz = GPBObjCClass(TransactionExtention),
                .number = TransactionSignWeight_FieldNumber_Transaction,
                .hasIndex = 3,
                .offset = (uint32_t)offsetof(TransactionSignWeight__storage_, transaction),
                .flags = GPBFieldOptional,
                .dataType = GPBDataTypeMessage,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(TransactionSignWeight)
                                   messageName:@"TransactionSignWeight"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransactionSignWeight__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - TransactionSignWeight_Result

@implementation TransactionSignWeight_Result

@dynamic code;
@dynamic message;

typedef struct TransactionSignWeight_Result__storage_ {
    uint32_t _has_storage_[1];
    TransactionSignWeight_Result_response_code code;
    NSString *message;
} TransactionSignWeight_Result__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "code",
                .dataTypeSpecific.enumDescFunc = TransactionSignWeight_Result_response_code_EnumDescriptor,
                .number = TransactionSignWeight_Result_FieldNumber_Code,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(TransactionSignWeight_Result__storage_, code),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeEnum,
            },
            {
                .name = "message",
                .dataTypeSpecific.clazz = Nil,
                .number = TransactionSignWeight_Result_FieldNumber_Message,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(TransactionSignWeight_Result__storage_, message),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeString,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(TransactionSignWeight_Result)
                                   messageName:@"Result"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransactionSignWeight_Result__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
        [localDescriptor setupContainingMessageClass:GPBObjCClass(TransactionSignWeight)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

int32_t TransactionSignWeight_Result_Code_RawValue(TransactionSignWeight_Result *message) {
    GPBDescriptor *descriptor = [TransactionSignWeight_Result descriptor];
    GPBFieldDescriptor *field = [descriptor fieldWithNumber:TransactionSignWeight_Result_FieldNumber_Code];
    return GPBGetMessageRawEnumField(message, field);
}

void SetTransactionSignWeight_Result_Code_RawValue(TransactionSignWeight_Result *message, int32_t value) {
    GPBDescriptor *descriptor = [TransactionSignWeight_Result descriptor];
    GPBFieldDescriptor *field = [descriptor fieldWithNumber:TransactionSignWeight_Result_FieldNumber_Code];
    GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - TransactionApprovedList

@implementation TransactionApprovedList

@dynamic approvedListArray, approvedListArray_Count;
@dynamic hasResult, result;
@dynamic hasTransaction, transaction;

typedef struct TransactionApprovedList__storage_ {
    uint32_t _has_storage_[1];
    NSMutableArray *approvedListArray;
    TransactionApprovedList_Result *result;
    TransactionExtention *transaction;
} TransactionApprovedList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "approvedListArray",
                .dataTypeSpecific.clazz = Nil,
                .number = TransactionApprovedList_FieldNumber_ApprovedListArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(TransactionApprovedList__storage_, approvedListArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "result",
                .dataTypeSpecific.clazz = GPBObjCClass(TransactionApprovedList_Result),
                .number = TransactionApprovedList_FieldNumber_Result,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(TransactionApprovedList__storage_, result),
                .flags = GPBFieldOptional,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "transaction",
                .dataTypeSpecific.clazz = GPBObjCClass(TransactionExtention),
                .number = TransactionApprovedList_FieldNumber_Transaction,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(TransactionApprovedList__storage_, transaction),
                .flags = GPBFieldOptional,
                .dataType = GPBDataTypeMessage,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(TransactionApprovedList)
                                   messageName:@"TransactionApprovedList"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransactionApprovedList__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - TransactionApprovedList_Result

@implementation TransactionApprovedList_Result

@dynamic code;
@dynamic message;

typedef struct TransactionApprovedList_Result__storage_ {
    uint32_t _has_storage_[1];
    TransactionApprovedList_Result_response_code code;
    NSString *message;
} TransactionApprovedList_Result__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "code",
                .dataTypeSpecific.enumDescFunc = TransactionApprovedList_Result_response_code_EnumDescriptor,
                .number = TransactionApprovedList_Result_FieldNumber_Code,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(TransactionApprovedList_Result__storage_, code),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeEnum,
            },
            {
                .name = "message",
                .dataTypeSpecific.clazz = Nil,
                .number = TransactionApprovedList_Result_FieldNumber_Message,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(TransactionApprovedList_Result__storage_, message),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeString,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(TransactionApprovedList_Result)
                                   messageName:@"Result"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransactionApprovedList_Result__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
        [localDescriptor setupContainingMessageClass:GPBObjCClass(TransactionApprovedList)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

int32_t TransactionApprovedList_Result_Code_RawValue(TransactionApprovedList_Result *message) {
    GPBDescriptor *descriptor = [TransactionApprovedList_Result descriptor];
    GPBFieldDescriptor *field = [descriptor fieldWithNumber:TransactionApprovedList_Result_FieldNumber_Code];
    return GPBGetMessageRawEnumField(message, field);
}

void SetTransactionApprovedList_Result_Code_RawValue(TransactionApprovedList_Result *message, int32_t value) {
    GPBDescriptor *descriptor = [TransactionApprovedList_Result descriptor];
    GPBFieldDescriptor *field = [descriptor fieldWithNumber:TransactionApprovedList_Result_FieldNumber_Code];
    GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - IvkDecryptParameters

@implementation IvkDecryptParameters

@dynamic startBlockIndex;
@dynamic endBlockIndex;
@dynamic ivk;

typedef struct IvkDecryptParameters__storage_ {
    uint32_t _has_storage_[1];
    NSData *ivk;
    int64_t startBlockIndex;
    int64_t endBlockIndex;
} IvkDecryptParameters__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "startBlockIndex",
                .dataTypeSpecific.clazz = Nil,
                .number = IvkDecryptParameters_FieldNumber_StartBlockIndex,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(IvkDecryptParameters__storage_, startBlockIndex),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "endBlockIndex",
                .dataTypeSpecific.clazz = Nil,
                .number = IvkDecryptParameters_FieldNumber_EndBlockIndex,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(IvkDecryptParameters__storage_, endBlockIndex),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "ivk",
                .dataTypeSpecific.clazz = Nil,
                .number = IvkDecryptParameters_FieldNumber_Ivk,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(IvkDecryptParameters__storage_, ivk),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(IvkDecryptParameters)
                                   messageName:@"IvkDecryptParameters"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IvkDecryptParameters__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - IvkDecryptAndMarkParameters

@implementation IvkDecryptAndMarkParameters

@dynamic startBlockIndex;
@dynamic endBlockIndex;
@dynamic ivk;
@dynamic ak;
@dynamic nk;

typedef struct IvkDecryptAndMarkParameters__storage_ {
    uint32_t _has_storage_[1];
    NSData *ak;
    NSData *nk;
    NSData *ivk;
    int64_t startBlockIndex;
    int64_t endBlockIndex;
} IvkDecryptAndMarkParameters__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "startBlockIndex",
                .dataTypeSpecific.clazz = Nil,
                .number = IvkDecryptAndMarkParameters_FieldNumber_StartBlockIndex,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(IvkDecryptAndMarkParameters__storage_, startBlockIndex),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "endBlockIndex",
                .dataTypeSpecific.clazz = Nil,
                .number = IvkDecryptAndMarkParameters_FieldNumber_EndBlockIndex,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(IvkDecryptAndMarkParameters__storage_, endBlockIndex),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "ak",
                .dataTypeSpecific.clazz = Nil,
                .number = IvkDecryptAndMarkParameters_FieldNumber_Ak,
                .hasIndex = 3,
                .offset = (uint32_t)offsetof(IvkDecryptAndMarkParameters__storage_, ak),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "nk",
                .dataTypeSpecific.clazz = Nil,
                .number = IvkDecryptAndMarkParameters_FieldNumber_Nk,
                .hasIndex = 4,
                .offset = (uint32_t)offsetof(IvkDecryptAndMarkParameters__storage_, nk),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "ivk",
                .dataTypeSpecific.clazz = Nil,
                .number = IvkDecryptAndMarkParameters_FieldNumber_Ivk,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(IvkDecryptAndMarkParameters__storage_, ivk),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(IvkDecryptAndMarkParameters)
                                   messageName:@"IvkDecryptAndMarkParameters"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IvkDecryptAndMarkParameters__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - OvkDecryptParameters

@implementation OvkDecryptParameters

@dynamic startBlockIndex;
@dynamic endBlockIndex;
@dynamic ovk;

typedef struct OvkDecryptParameters__storage_ {
    uint32_t _has_storage_[1];
    NSData *ovk;
    int64_t startBlockIndex;
    int64_t endBlockIndex;
} OvkDecryptParameters__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "startBlockIndex",
                .dataTypeSpecific.clazz = Nil,
                .number = OvkDecryptParameters_FieldNumber_StartBlockIndex,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(OvkDecryptParameters__storage_, startBlockIndex),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "endBlockIndex",
                .dataTypeSpecific.clazz = Nil,
                .number = OvkDecryptParameters_FieldNumber_EndBlockIndex,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(OvkDecryptParameters__storage_, endBlockIndex),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "ovk",
                .dataTypeSpecific.clazz = Nil,
                .number = OvkDecryptParameters_FieldNumber_Ovk,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(OvkDecryptParameters__storage_, ovk),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(OvkDecryptParameters)
                                   messageName:@"OvkDecryptParameters"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OvkDecryptParameters__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - DecryptNotes

@implementation DecryptNotes

@dynamic noteTxsArray, noteTxsArray_Count;

typedef struct DecryptNotes__storage_ {
    uint32_t _has_storage_[1];
    NSMutableArray *noteTxsArray;
} DecryptNotes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "noteTxsArray",
                .dataTypeSpecific.clazz = GPBObjCClass(DecryptNotes_NoteTx),
                .number = DecryptNotes_FieldNumber_NoteTxsArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(DecryptNotes__storage_, noteTxsArray),
                .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
                .dataType = GPBDataTypeMessage,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(DecryptNotes)
                                   messageName:@"DecryptNotes"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DecryptNotes__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        static const char *extraTextFormatInfo =
        "\001\001\000noteTxs\000";
        [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - DecryptNotes_NoteTx

@implementation DecryptNotes_NoteTx

@dynamic hasNote, note;
@dynamic txid;
@dynamic index;

typedef struct DecryptNotes_NoteTx__storage_ {
    uint32_t _has_storage_[1];
    int32_t index;
    Note *note;
    NSData *txid;
} DecryptNotes_NoteTx__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "note",
                .dataTypeSpecific.clazz = GPBObjCClass(Note),
                .number = DecryptNotes_NoteTx_FieldNumber_Note,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(DecryptNotes_NoteTx__storage_, note),
                .flags = GPBFieldOptional,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "txid",
                .dataTypeSpecific.clazz = Nil,
                .number = DecryptNotes_NoteTx_FieldNumber_Txid,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(DecryptNotes_NoteTx__storage_, txid),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "index",
                .dataTypeSpecific.clazz = Nil,
                .number = DecryptNotes_NoteTx_FieldNumber_Index,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(DecryptNotes_NoteTx__storage_, index),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(DecryptNotes_NoteTx)
                                   messageName:@"NoteTx"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DecryptNotes_NoteTx__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
        [localDescriptor setupContainingMessageClass:GPBObjCClass(DecryptNotes)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - DecryptNotesMarked

@implementation DecryptNotesMarked

@dynamic noteTxsArray, noteTxsArray_Count;

typedef struct DecryptNotesMarked__storage_ {
    uint32_t _has_storage_[1];
    NSMutableArray *noteTxsArray;
} DecryptNotesMarked__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "noteTxsArray",
                .dataTypeSpecific.clazz = GPBObjCClass(DecryptNotesMarked_NoteTx),
                .number = DecryptNotesMarked_FieldNumber_NoteTxsArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(DecryptNotesMarked__storage_, noteTxsArray),
                .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
                .dataType = GPBDataTypeMessage,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(DecryptNotesMarked)
                                   messageName:@"DecryptNotesMarked"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DecryptNotesMarked__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        static const char *extraTextFormatInfo =
        "\001\001\000noteTxs\000";
        [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - DecryptNotesMarked_NoteTx

@implementation DecryptNotesMarked_NoteTx

@dynamic hasNote, note;
@dynamic txid;
@dynamic index;
@dynamic isSpend;

typedef struct DecryptNotesMarked_NoteTx__storage_ {
    uint32_t _has_storage_[1];
    int32_t index;
    Note *note;
    NSData *txid;
} DecryptNotesMarked_NoteTx__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "note",
                .dataTypeSpecific.clazz = GPBObjCClass(Note),
                .number = DecryptNotesMarked_NoteTx_FieldNumber_Note,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(DecryptNotesMarked_NoteTx__storage_, note),
                .flags = GPBFieldOptional,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "txid",
                .dataTypeSpecific.clazz = Nil,
                .number = DecryptNotesMarked_NoteTx_FieldNumber_Txid,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(DecryptNotesMarked_NoteTx__storage_, txid),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "index",
                .dataTypeSpecific.clazz = Nil,
                .number = DecryptNotesMarked_NoteTx_FieldNumber_Index,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(DecryptNotesMarked_NoteTx__storage_, index),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
            {
                .name = "isSpend",
                .dataTypeSpecific.clazz = Nil,
                .number = DecryptNotesMarked_NoteTx_FieldNumber_IsSpend,
                .hasIndex = 3,
                .offset = 4,  // Stored in _has_storage_ to save space.
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBool,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(DecryptNotesMarked_NoteTx)
                                   messageName:@"NoteTx"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DecryptNotesMarked_NoteTx__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
        [localDescriptor setupContainingMessageClass:GPBObjCClass(DecryptNotesMarked)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - Note

@implementation Note

@dynamic value;
@dynamic paymentAddress;
@dynamic rcm;
@dynamic memo;

typedef struct Note__storage_ {
    uint32_t _has_storage_[1];
    NSString *paymentAddress;
    NSData *rcm;
    NSData *memo;
    int64_t value;
} Note__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "value",
                .dataTypeSpecific.clazz = Nil,
                .number = Note_FieldNumber_Value,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(Note__storage_, value),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "paymentAddress",
                .dataTypeSpecific.clazz = Nil,
                .number = Note_FieldNumber_PaymentAddress,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(Note__storage_, paymentAddress),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeString,
            },
            {
                .name = "rcm",
                .dataTypeSpecific.clazz = Nil,
                .number = Note_FieldNumber_Rcm,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(Note__storage_, rcm),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "memo",
                .dataTypeSpecific.clazz = Nil,
                .number = Note_FieldNumber_Memo,
                .hasIndex = 3,
                .offset = (uint32_t)offsetof(Note__storage_, memo),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Note)
                                   messageName:@"Note"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Note__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - SpendNote

@implementation SpendNote

@dynamic hasNote, note;
@dynamic alpha;
@dynamic hasVoucher, voucher;
@dynamic path;

typedef struct SpendNote__storage_ {
    uint32_t _has_storage_[1];
    Note *note;
    NSData *alpha;
    IncrementalMerkleVoucher *voucher;
    NSData *path;
} SpendNote__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "note",
                .dataTypeSpecific.clazz = GPBObjCClass(Note),
                .number = SpendNote_FieldNumber_Note,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(SpendNote__storage_, note),
                .flags = GPBFieldOptional,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "alpha",
                .dataTypeSpecific.clazz = Nil,
                .number = SpendNote_FieldNumber_Alpha,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(SpendNote__storage_, alpha),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "voucher",
                .dataTypeSpecific.clazz = GPBObjCClass(IncrementalMerkleVoucher),
                .number = SpendNote_FieldNumber_Voucher,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(SpendNote__storage_, voucher),
                .flags = GPBFieldOptional,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "path",
                .dataTypeSpecific.clazz = Nil,
                .number = SpendNote_FieldNumber_Path,
                .hasIndex = 3,
                .offset = (uint32_t)offsetof(SpendNote__storage_, path),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SpendNote)
                                   messageName:@"SpendNote"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SpendNote__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - ReceiveNote

@implementation ReceiveNote

@dynamic hasNote, note;

typedef struct ReceiveNote__storage_ {
    uint32_t _has_storage_[1];
    Note *note;
} ReceiveNote__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "note",
                .dataTypeSpecific.clazz = GPBObjCClass(Note),
                .number = ReceiveNote_FieldNumber_Note,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(ReceiveNote__storage_, note),
                .flags = GPBFieldOptional,
                .dataType = GPBDataTypeMessage,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ReceiveNote)
                                   messageName:@"ReceiveNote"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ReceiveNote__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - PrivateParameters

@implementation PrivateParameters

@dynamic transparentFromAddress;
@dynamic ask;
@dynamic nsk;
@dynamic ovk;
@dynamic fromAmount;
@dynamic shieldedSpendsArray, shieldedSpendsArray_Count;
@dynamic shieldedReceivesArray, shieldedReceivesArray_Count;
@dynamic transparentToAddress;
@dynamic toAmount;
@dynamic timeout;

typedef struct PrivateParameters__storage_ {
    uint32_t _has_storage_[1];
    NSData *transparentFromAddress;
    NSData *ask;
    NSData *nsk;
    NSData *ovk;
    NSMutableArray *shieldedSpendsArray;
    NSMutableArray *shieldedReceivesArray;
    NSData *transparentToAddress;
    int64_t fromAmount;
    int64_t toAmount;
    int64_t timeout;
} PrivateParameters__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "transparentFromAddress",
                .dataTypeSpecific.clazz = Nil,
                .number = PrivateParameters_FieldNumber_TransparentFromAddress,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(PrivateParameters__storage_, transparentFromAddress),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "ask",
                .dataTypeSpecific.clazz = Nil,
                .number = PrivateParameters_FieldNumber_Ask,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(PrivateParameters__storage_, ask),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "nsk",
                .dataTypeSpecific.clazz = Nil,
                .number = PrivateParameters_FieldNumber_Nsk,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(PrivateParameters__storage_, nsk),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "ovk",
                .dataTypeSpecific.clazz = Nil,
                .number = PrivateParameters_FieldNumber_Ovk,
                .hasIndex = 3,
                .offset = (uint32_t)offsetof(PrivateParameters__storage_, ovk),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "fromAmount",
                .dataTypeSpecific.clazz = Nil,
                .number = PrivateParameters_FieldNumber_FromAmount,
                .hasIndex = 4,
                .offset = (uint32_t)offsetof(PrivateParameters__storage_, fromAmount),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "shieldedSpendsArray",
                .dataTypeSpecific.clazz = GPBObjCClass(SpendNote),
                .number = PrivateParameters_FieldNumber_ShieldedSpendsArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(PrivateParameters__storage_, shieldedSpendsArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "shieldedReceivesArray",
                .dataTypeSpecific.clazz = GPBObjCClass(ReceiveNote),
                .number = PrivateParameters_FieldNumber_ShieldedReceivesArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(PrivateParameters__storage_, shieldedReceivesArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "transparentToAddress",
                .dataTypeSpecific.clazz = Nil,
                .number = PrivateParameters_FieldNumber_TransparentToAddress,
                .hasIndex = 5,
                .offset = (uint32_t)offsetof(PrivateParameters__storage_, transparentToAddress),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "toAmount",
                .dataTypeSpecific.clazz = Nil,
                .number = PrivateParameters_FieldNumber_ToAmount,
                .hasIndex = 6,
                .offset = (uint32_t)offsetof(PrivateParameters__storage_, toAmount),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "timeout",
                .dataTypeSpecific.clazz = Nil,
                .number = PrivateParameters_FieldNumber_Timeout,
                .hasIndex = 7,
                .offset = (uint32_t)offsetof(PrivateParameters__storage_, timeout),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(PrivateParameters)
                                   messageName:@"PrivateParameters"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PrivateParameters__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - PrivateParametersWithoutAsk

@implementation PrivateParametersWithoutAsk

@dynamic transparentFromAddress;
@dynamic ak;
@dynamic nsk;
@dynamic ovk;
@dynamic fromAmount;
@dynamic shieldedSpendsArray, shieldedSpendsArray_Count;
@dynamic shieldedReceivesArray, shieldedReceivesArray_Count;
@dynamic transparentToAddress;
@dynamic toAmount;
@dynamic timeout;

typedef struct PrivateParametersWithoutAsk__storage_ {
    uint32_t _has_storage_[1];
    NSData *transparentFromAddress;
    NSData *ak;
    NSData *nsk;
    NSData *ovk;
    NSMutableArray *shieldedSpendsArray;
    NSMutableArray *shieldedReceivesArray;
    NSData *transparentToAddress;
    int64_t fromAmount;
    int64_t toAmount;
    int64_t timeout;
} PrivateParametersWithoutAsk__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "transparentFromAddress",
                .dataTypeSpecific.clazz = Nil,
                .number = PrivateParametersWithoutAsk_FieldNumber_TransparentFromAddress,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(PrivateParametersWithoutAsk__storage_, transparentFromAddress),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "ak",
                .dataTypeSpecific.clazz = Nil,
                .number = PrivateParametersWithoutAsk_FieldNumber_Ak,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(PrivateParametersWithoutAsk__storage_, ak),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "nsk",
                .dataTypeSpecific.clazz = Nil,
                .number = PrivateParametersWithoutAsk_FieldNumber_Nsk,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(PrivateParametersWithoutAsk__storage_, nsk),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "ovk",
                .dataTypeSpecific.clazz = Nil,
                .number = PrivateParametersWithoutAsk_FieldNumber_Ovk,
                .hasIndex = 3,
                .offset = (uint32_t)offsetof(PrivateParametersWithoutAsk__storage_, ovk),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "fromAmount",
                .dataTypeSpecific.clazz = Nil,
                .number = PrivateParametersWithoutAsk_FieldNumber_FromAmount,
                .hasIndex = 4,
                .offset = (uint32_t)offsetof(PrivateParametersWithoutAsk__storage_, fromAmount),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "shieldedSpendsArray",
                .dataTypeSpecific.clazz = GPBObjCClass(SpendNote),
                .number = PrivateParametersWithoutAsk_FieldNumber_ShieldedSpendsArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(PrivateParametersWithoutAsk__storage_, shieldedSpendsArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "shieldedReceivesArray",
                .dataTypeSpecific.clazz = GPBObjCClass(ReceiveNote),
                .number = PrivateParametersWithoutAsk_FieldNumber_ShieldedReceivesArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(PrivateParametersWithoutAsk__storage_, shieldedReceivesArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "transparentToAddress",
                .dataTypeSpecific.clazz = Nil,
                .number = PrivateParametersWithoutAsk_FieldNumber_TransparentToAddress,
                .hasIndex = 5,
                .offset = (uint32_t)offsetof(PrivateParametersWithoutAsk__storage_, transparentToAddress),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "toAmount",
                .dataTypeSpecific.clazz = Nil,
                .number = PrivateParametersWithoutAsk_FieldNumber_ToAmount,
                .hasIndex = 6,
                .offset = (uint32_t)offsetof(PrivateParametersWithoutAsk__storage_, toAmount),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "timeout",
                .dataTypeSpecific.clazz = Nil,
                .number = PrivateParametersWithoutAsk_FieldNumber_Timeout,
                .hasIndex = 7,
                .offset = (uint32_t)offsetof(PrivateParametersWithoutAsk__storage_, timeout),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(PrivateParametersWithoutAsk)
                                   messageName:@"PrivateParametersWithoutAsk"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PrivateParametersWithoutAsk__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - SpendAuthSigParameters

@implementation SpendAuthSigParameters

@dynamic ask;
@dynamic txHash;
@dynamic alpha;

typedef struct SpendAuthSigParameters__storage_ {
    uint32_t _has_storage_[1];
    NSData *ask;
    NSData *txHash;
    NSData *alpha;
} SpendAuthSigParameters__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "ask",
                .dataTypeSpecific.clazz = Nil,
                .number = SpendAuthSigParameters_FieldNumber_Ask,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(SpendAuthSigParameters__storage_, ask),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "txHash",
                .dataTypeSpecific.clazz = Nil,
                .number = SpendAuthSigParameters_FieldNumber_TxHash,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(SpendAuthSigParameters__storage_, txHash),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "alpha",
                .dataTypeSpecific.clazz = Nil,
                .number = SpendAuthSigParameters_FieldNumber_Alpha,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(SpendAuthSigParameters__storage_, alpha),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SpendAuthSigParameters)
                                   messageName:@"SpendAuthSigParameters"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SpendAuthSigParameters__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - NfParameters

@implementation NfParameters

@dynamic hasNote, note;
@dynamic hasVoucher, voucher;
@dynamic ak;
@dynamic nk;

typedef struct NfParameters__storage_ {
    uint32_t _has_storage_[1];
    Note *note;
    IncrementalMerkleVoucher *voucher;
    NSData *ak;
    NSData *nk;
} NfParameters__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "note",
                .dataTypeSpecific.clazz = GPBObjCClass(Note),
                .number = NfParameters_FieldNumber_Note,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(NfParameters__storage_, note),
                .flags = GPBFieldOptional,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "voucher",
                .dataTypeSpecific.clazz = GPBObjCClass(IncrementalMerkleVoucher),
                .number = NfParameters_FieldNumber_Voucher,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(NfParameters__storage_, voucher),
                .flags = GPBFieldOptional,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "ak",
                .dataTypeSpecific.clazz = Nil,
                .number = NfParameters_FieldNumber_Ak,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(NfParameters__storage_, ak),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "nk",
                .dataTypeSpecific.clazz = Nil,
                .number = NfParameters_FieldNumber_Nk,
                .hasIndex = 3,
                .offset = (uint32_t)offsetof(NfParameters__storage_, nk),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(NfParameters)
                                   messageName:@"NfParameters"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NfParameters__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - ExpandedSpendingKeyMessage

@implementation ExpandedSpendingKeyMessage

@dynamic ask;
@dynamic nsk;
@dynamic ovk;

typedef struct ExpandedSpendingKeyMessage__storage_ {
    uint32_t _has_storage_[1];
    NSData *ask;
    NSData *nsk;
    NSData *ovk;
} ExpandedSpendingKeyMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "ask",
                .dataTypeSpecific.clazz = Nil,
                .number = ExpandedSpendingKeyMessage_FieldNumber_Ask,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(ExpandedSpendingKeyMessage__storage_, ask),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "nsk",
                .dataTypeSpecific.clazz = Nil,
                .number = ExpandedSpendingKeyMessage_FieldNumber_Nsk,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(ExpandedSpendingKeyMessage__storage_, nsk),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "ovk",
                .dataTypeSpecific.clazz = Nil,
                .number = ExpandedSpendingKeyMessage_FieldNumber_Ovk,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(ExpandedSpendingKeyMessage__storage_, ovk),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ExpandedSpendingKeyMessage)
                                   messageName:@"ExpandedSpendingKeyMessage"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ExpandedSpendingKeyMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - ViewingKeyMessage

@implementation ViewingKeyMessage

@dynamic ak;
@dynamic nk;

typedef struct ViewingKeyMessage__storage_ {
    uint32_t _has_storage_[1];
    NSData *ak;
    NSData *nk;
} ViewingKeyMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "ak",
                .dataTypeSpecific.clazz = Nil,
                .number = ViewingKeyMessage_FieldNumber_Ak,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(ViewingKeyMessage__storage_, ak),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "nk",
                .dataTypeSpecific.clazz = Nil,
                .number = ViewingKeyMessage_FieldNumber_Nk,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(ViewingKeyMessage__storage_, nk),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ViewingKeyMessage)
                                   messageName:@"ViewingKeyMessage"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ViewingKeyMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - IncomingViewingKeyMessage

@implementation IncomingViewingKeyMessage

@dynamic ivk;

typedef struct IncomingViewingKeyMessage__storage_ {
    uint32_t _has_storage_[1];
    NSData *ivk;
} IncomingViewingKeyMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "ivk",
                .dataTypeSpecific.clazz = Nil,
                .number = IncomingViewingKeyMessage_FieldNumber_Ivk,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(IncomingViewingKeyMessage__storage_, ivk),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(IncomingViewingKeyMessage)
                                   messageName:@"IncomingViewingKeyMessage"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IncomingViewingKeyMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - DiversifierMessage

@implementation DiversifierMessage

@dynamic d;

typedef struct DiversifierMessage__storage_ {
    uint32_t _has_storage_[1];
    NSData *d;
} DiversifierMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "d",
                .dataTypeSpecific.clazz = Nil,
                .number = DiversifierMessage_FieldNumber_D,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(DiversifierMessage__storage_, d),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(DiversifierMessage)
                                   messageName:@"DiversifierMessage"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DiversifierMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - IncomingViewingKeyDiversifierMessage

@implementation IncomingViewingKeyDiversifierMessage

@dynamic hasIvk, ivk;
@dynamic hasD, d;

typedef struct IncomingViewingKeyDiversifierMessage__storage_ {
    uint32_t _has_storage_[1];
    IncomingViewingKeyMessage *ivk;
    DiversifierMessage *d;
} IncomingViewingKeyDiversifierMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "ivk",
                .dataTypeSpecific.clazz = GPBObjCClass(IncomingViewingKeyMessage),
                .number = IncomingViewingKeyDiversifierMessage_FieldNumber_Ivk,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(IncomingViewingKeyDiversifierMessage__storage_, ivk),
                .flags = GPBFieldOptional,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "d",
                .dataTypeSpecific.clazz = GPBObjCClass(DiversifierMessage),
                .number = IncomingViewingKeyDiversifierMessage_FieldNumber_D,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(IncomingViewingKeyDiversifierMessage__storage_, d),
                .flags = GPBFieldOptional,
                .dataType = GPBDataTypeMessage,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(IncomingViewingKeyDiversifierMessage)
                                   messageName:@"IncomingViewingKeyDiversifierMessage"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IncomingViewingKeyDiversifierMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - PaymentAddressMessage

@implementation PaymentAddressMessage

@dynamic hasD, d;
@dynamic pkD;
@dynamic paymentAddress;

typedef struct PaymentAddressMessage__storage_ {
    uint32_t _has_storage_[1];
    DiversifierMessage *d;
    NSData *pkD;
    NSString *paymentAddress;
} PaymentAddressMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "d",
                .dataTypeSpecific.clazz = GPBObjCClass(DiversifierMessage),
                .number = PaymentAddressMessage_FieldNumber_D,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(PaymentAddressMessage__storage_, d),
                .flags = GPBFieldOptional,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "pkD",
                .dataTypeSpecific.clazz = Nil,
                .number = PaymentAddressMessage_FieldNumber_PkD,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(PaymentAddressMessage__storage_, pkD),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "paymentAddress",
                .dataTypeSpecific.clazz = Nil,
                .number = PaymentAddressMessage_FieldNumber_PaymentAddress,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(PaymentAddressMessage__storage_, paymentAddress),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeString,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(PaymentAddressMessage)
                                   messageName:@"PaymentAddressMessage"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PaymentAddressMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        static const char *extraTextFormatInfo =
        "\001\002\003\000";
        [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - ShieldedAddressInfo

@implementation ShieldedAddressInfo

@dynamic sk;
@dynamic ask;
@dynamic nsk;
@dynamic ovk;
@dynamic ak;
@dynamic nk;
@dynamic ivk;
@dynamic d;
@dynamic pkD;
@dynamic paymentAddress;

typedef struct ShieldedAddressInfo__storage_ {
    uint32_t _has_storage_[1];
    NSData *sk;
    NSData *ask;
    NSData *nsk;
    NSData *ovk;
    NSData *ak;
    NSData *nk;
    NSData *ivk;
    NSData *d;
    NSData *pkD;
    NSString *paymentAddress;
} ShieldedAddressInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "sk",
                .dataTypeSpecific.clazz = Nil,
                .number = ShieldedAddressInfo_FieldNumber_Sk,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(ShieldedAddressInfo__storage_, sk),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "ask",
                .dataTypeSpecific.clazz = Nil,
                .number = ShieldedAddressInfo_FieldNumber_Ask,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(ShieldedAddressInfo__storage_, ask),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "nsk",
                .dataTypeSpecific.clazz = Nil,
                .number = ShieldedAddressInfo_FieldNumber_Nsk,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(ShieldedAddressInfo__storage_, nsk),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "ovk",
                .dataTypeSpecific.clazz = Nil,
                .number = ShieldedAddressInfo_FieldNumber_Ovk,
                .hasIndex = 3,
                .offset = (uint32_t)offsetof(ShieldedAddressInfo__storage_, ovk),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "ak",
                .dataTypeSpecific.clazz = Nil,
                .number = ShieldedAddressInfo_FieldNumber_Ak,
                .hasIndex = 4,
                .offset = (uint32_t)offsetof(ShieldedAddressInfo__storage_, ak),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "nk",
                .dataTypeSpecific.clazz = Nil,
                .number = ShieldedAddressInfo_FieldNumber_Nk,
                .hasIndex = 5,
                .offset = (uint32_t)offsetof(ShieldedAddressInfo__storage_, nk),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "ivk",
                .dataTypeSpecific.clazz = Nil,
                .number = ShieldedAddressInfo_FieldNumber_Ivk,
                .hasIndex = 6,
                .offset = (uint32_t)offsetof(ShieldedAddressInfo__storage_, ivk),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "d",
                .dataTypeSpecific.clazz = Nil,
                .number = ShieldedAddressInfo_FieldNumber_D,
                .hasIndex = 7,
                .offset = (uint32_t)offsetof(ShieldedAddressInfo__storage_, d),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "pkD",
                .dataTypeSpecific.clazz = Nil,
                .number = ShieldedAddressInfo_FieldNumber_PkD,
                .hasIndex = 8,
                .offset = (uint32_t)offsetof(ShieldedAddressInfo__storage_, pkD),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "paymentAddress",
                .dataTypeSpecific.clazz = Nil,
                .number = ShieldedAddressInfo_FieldNumber_PaymentAddress,
                .hasIndex = 9,
                .offset = (uint32_t)offsetof(ShieldedAddressInfo__storage_, paymentAddress),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeString,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ShieldedAddressInfo)
                                   messageName:@"ShieldedAddressInfo"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ShieldedAddressInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        static const char *extraTextFormatInfo =
        "\001\t\003\000";
        [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - NoteParameters

@implementation NoteParameters

@dynamic ak;
@dynamic nk;
@dynamic hasNote, note;
@dynamic txid;
@dynamic index;

typedef struct NoteParameters__storage_ {
    uint32_t _has_storage_[1];
    int32_t index;
    NSData *ak;
    NSData *nk;
    Note *note;
    NSData *txid;
} NoteParameters__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "ak",
                .dataTypeSpecific.clazz = Nil,
                .number = NoteParameters_FieldNumber_Ak,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(NoteParameters__storage_, ak),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "nk",
                .dataTypeSpecific.clazz = Nil,
                .number = NoteParameters_FieldNumber_Nk,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(NoteParameters__storage_, nk),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "note",
                .dataTypeSpecific.clazz = GPBObjCClass(Note),
                .number = NoteParameters_FieldNumber_Note,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(NoteParameters__storage_, note),
                .flags = GPBFieldOptional,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "txid",
                .dataTypeSpecific.clazz = Nil,
                .number = NoteParameters_FieldNumber_Txid,
                .hasIndex = 3,
                .offset = (uint32_t)offsetof(NoteParameters__storage_, txid),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "index",
                .dataTypeSpecific.clazz = Nil,
                .number = NoteParameters_FieldNumber_Index,
                .hasIndex = 4,
                .offset = (uint32_t)offsetof(NoteParameters__storage_, index),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(NoteParameters)
                                   messageName:@"NoteParameters"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NoteParameters__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - SpendResult

@implementation SpendResult

@dynamic result;
@dynamic message;

typedef struct SpendResult__storage_ {
    uint32_t _has_storage_[1];
    NSString *message;
} SpendResult__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "result",
                .dataTypeSpecific.clazz = Nil,
                .number = SpendResult_FieldNumber_Result,
                .hasIndex = 0,
                .offset = 1,  // Stored in _has_storage_ to save space.
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBool,
            },
            {
                .name = "message",
                .dataTypeSpecific.clazz = Nil,
                .number = SpendResult_FieldNumber_Message,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(SpendResult__storage_, message),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeString,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SpendResult)
                                   messageName:@"SpendResult"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SpendResult__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - TransactionInfoList

@implementation TransactionInfoList

@dynamic transactionInfoArray, transactionInfoArray_Count;

typedef struct TransactionInfoList__storage_ {
    uint32_t _has_storage_[1];
    NSMutableArray *transactionInfoArray;
} TransactionInfoList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "transactionInfoArray",
                .dataTypeSpecific.clazz = GPBObjCClass(TransactionInfo),
                .number = TransactionInfoList_FieldNumber_TransactionInfoArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(TransactionInfoList__storage_, transactionInfoArray),
                .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
                .dataType = GPBDataTypeMessage,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(TransactionInfoList)
                                   messageName:@"TransactionInfoList"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransactionInfoList__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        static const char *extraTextFormatInfo =
        "\001\001\000transactionInfo\000";
        [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - SpendNoteTRC20

@implementation SpendNoteTRC20

@dynamic hasNote, note;
@dynamic alpha;
@dynamic root;
@dynamic path;
@dynamic pos;

typedef struct SpendNoteTRC20__storage_ {
    uint32_t _has_storage_[1];
    Note *note;
    NSData *alpha;
    NSData *root;
    NSData *path;
    int64_t pos;
} SpendNoteTRC20__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "note",
                .dataTypeSpecific.clazz = GPBObjCClass(Note),
                .number = SpendNoteTRC20_FieldNumber_Note,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(SpendNoteTRC20__storage_, note),
                .flags = GPBFieldOptional,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "alpha",
                .dataTypeSpecific.clazz = Nil,
                .number = SpendNoteTRC20_FieldNumber_Alpha,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(SpendNoteTRC20__storage_, alpha),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "root",
                .dataTypeSpecific.clazz = Nil,
                .number = SpendNoteTRC20_FieldNumber_Root,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(SpendNoteTRC20__storage_, root),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "path",
                .dataTypeSpecific.clazz = Nil,
                .number = SpendNoteTRC20_FieldNumber_Path,
                .hasIndex = 3,
                .offset = (uint32_t)offsetof(SpendNoteTRC20__storage_, path),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "pos",
                .dataTypeSpecific.clazz = Nil,
                .number = SpendNoteTRC20_FieldNumber_Pos,
                .hasIndex = 4,
                .offset = (uint32_t)offsetof(SpendNoteTRC20__storage_, pos),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SpendNoteTRC20)
                                   messageName:@"SpendNoteTRC20"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SpendNoteTRC20__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - PrivateShieldedTRC20Parameters

@implementation PrivateShieldedTRC20Parameters

@dynamic ask;
@dynamic nsk;
@dynamic ovk;
@dynamic fromAmount;
@dynamic shieldedSpendsArray, shieldedSpendsArray_Count;
@dynamic shieldedReceivesArray, shieldedReceivesArray_Count;
@dynamic transparentToAddress;
@dynamic toAmount;
@dynamic shieldedTrc20ContractAddress;

typedef struct PrivateShieldedTRC20Parameters__storage_ {
    uint32_t _has_storage_[1];
    NSData *ask;
    NSData *nsk;
    NSData *ovk;
    NSString *fromAmount;
    NSMutableArray *shieldedSpendsArray;
    NSMutableArray *shieldedReceivesArray;
    NSData *transparentToAddress;
    NSString *toAmount;
    NSData *shieldedTrc20ContractAddress;
} PrivateShieldedTRC20Parameters__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "ask",
                .dataTypeSpecific.clazz = Nil,
                .number = PrivateShieldedTRC20Parameters_FieldNumber_Ask,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(PrivateShieldedTRC20Parameters__storage_, ask),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "nsk",
                .dataTypeSpecific.clazz = Nil,
                .number = PrivateShieldedTRC20Parameters_FieldNumber_Nsk,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(PrivateShieldedTRC20Parameters__storage_, nsk),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "ovk",
                .dataTypeSpecific.clazz = Nil,
                .number = PrivateShieldedTRC20Parameters_FieldNumber_Ovk,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(PrivateShieldedTRC20Parameters__storage_, ovk),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "fromAmount",
                .dataTypeSpecific.clazz = Nil,
                .number = PrivateShieldedTRC20Parameters_FieldNumber_FromAmount,
                .hasIndex = 3,
                .offset = (uint32_t)offsetof(PrivateShieldedTRC20Parameters__storage_, fromAmount),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeString,
            },
            {
                .name = "shieldedSpendsArray",
                .dataTypeSpecific.clazz = GPBObjCClass(SpendNoteTRC20),
                .number = PrivateShieldedTRC20Parameters_FieldNumber_ShieldedSpendsArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(PrivateShieldedTRC20Parameters__storage_, shieldedSpendsArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "shieldedReceivesArray",
                .dataTypeSpecific.clazz = GPBObjCClass(ReceiveNote),
                .number = PrivateShieldedTRC20Parameters_FieldNumber_ShieldedReceivesArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(PrivateShieldedTRC20Parameters__storage_, shieldedReceivesArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "transparentToAddress",
                .dataTypeSpecific.clazz = Nil,
                .number = PrivateShieldedTRC20Parameters_FieldNumber_TransparentToAddress,
                .hasIndex = 4,
                .offset = (uint32_t)offsetof(PrivateShieldedTRC20Parameters__storage_, transparentToAddress),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "toAmount",
                .dataTypeSpecific.clazz = Nil,
                .number = PrivateShieldedTRC20Parameters_FieldNumber_ToAmount,
                .hasIndex = 5,
                .offset = (uint32_t)offsetof(PrivateShieldedTRC20Parameters__storage_, toAmount),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeString,
            },
            {
                .name = "shieldedTrc20ContractAddress",
                .dataTypeSpecific.clazz = Nil,
                .number = PrivateShieldedTRC20Parameters_FieldNumber_ShieldedTrc20ContractAddress,
                .hasIndex = 6,
                .offset = (uint32_t)offsetof(PrivateShieldedTRC20Parameters__storage_, shieldedTrc20ContractAddress),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(PrivateShieldedTRC20Parameters)
                                   messageName:@"PrivateShieldedTRC20Parameters"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PrivateShieldedTRC20Parameters__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        static const char *extraTextFormatInfo =
        "\001\t\010\343\002\250\247\000";
        [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - PrivateShieldedTRC20ParametersWithoutAsk

@implementation PrivateShieldedTRC20ParametersWithoutAsk

@dynamic ak;
@dynamic nsk;
@dynamic ovk;
@dynamic fromAmount;
@dynamic shieldedSpendsArray, shieldedSpendsArray_Count;
@dynamic shieldedReceivesArray, shieldedReceivesArray_Count;
@dynamic transparentToAddress;
@dynamic toAmount;
@dynamic shieldedTrc20ContractAddress;

typedef struct PrivateShieldedTRC20ParametersWithoutAsk__storage_ {
    uint32_t _has_storage_[1];
    NSData *ak;
    NSData *nsk;
    NSData *ovk;
    NSString *fromAmount;
    NSMutableArray *shieldedSpendsArray;
    NSMutableArray *shieldedReceivesArray;
    NSData *transparentToAddress;
    NSString *toAmount;
    NSData *shieldedTrc20ContractAddress;
} PrivateShieldedTRC20ParametersWithoutAsk__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "ak",
                .dataTypeSpecific.clazz = Nil,
                .number = PrivateShieldedTRC20ParametersWithoutAsk_FieldNumber_Ak,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(PrivateShieldedTRC20ParametersWithoutAsk__storage_, ak),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "nsk",
                .dataTypeSpecific.clazz = Nil,
                .number = PrivateShieldedTRC20ParametersWithoutAsk_FieldNumber_Nsk,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(PrivateShieldedTRC20ParametersWithoutAsk__storage_, nsk),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "ovk",
                .dataTypeSpecific.clazz = Nil,
                .number = PrivateShieldedTRC20ParametersWithoutAsk_FieldNumber_Ovk,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(PrivateShieldedTRC20ParametersWithoutAsk__storage_, ovk),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "fromAmount",
                .dataTypeSpecific.clazz = Nil,
                .number = PrivateShieldedTRC20ParametersWithoutAsk_FieldNumber_FromAmount,
                .hasIndex = 3,
                .offset = (uint32_t)offsetof(PrivateShieldedTRC20ParametersWithoutAsk__storage_, fromAmount),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeString,
            },
            {
                .name = "shieldedSpendsArray",
                .dataTypeSpecific.clazz = GPBObjCClass(SpendNoteTRC20),
                .number = PrivateShieldedTRC20ParametersWithoutAsk_FieldNumber_ShieldedSpendsArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(PrivateShieldedTRC20ParametersWithoutAsk__storage_, shieldedSpendsArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "shieldedReceivesArray",
                .dataTypeSpecific.clazz = GPBObjCClass(ReceiveNote),
                .number = PrivateShieldedTRC20ParametersWithoutAsk_FieldNumber_ShieldedReceivesArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(PrivateShieldedTRC20ParametersWithoutAsk__storage_, shieldedReceivesArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "transparentToAddress",
                .dataTypeSpecific.clazz = Nil,
                .number = PrivateShieldedTRC20ParametersWithoutAsk_FieldNumber_TransparentToAddress,
                .hasIndex = 4,
                .offset = (uint32_t)offsetof(PrivateShieldedTRC20ParametersWithoutAsk__storage_, transparentToAddress),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "toAmount",
                .dataTypeSpecific.clazz = Nil,
                .number = PrivateShieldedTRC20ParametersWithoutAsk_FieldNumber_ToAmount,
                .hasIndex = 5,
                .offset = (uint32_t)offsetof(PrivateShieldedTRC20ParametersWithoutAsk__storage_, toAmount),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeString,
            },
            {
                .name = "shieldedTrc20ContractAddress",
                .dataTypeSpecific.clazz = Nil,
                .number = PrivateShieldedTRC20ParametersWithoutAsk_FieldNumber_ShieldedTrc20ContractAddress,
                .hasIndex = 6,
                .offset = (uint32_t)offsetof(PrivateShieldedTRC20ParametersWithoutAsk__storage_, shieldedTrc20ContractAddress),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(PrivateShieldedTRC20ParametersWithoutAsk)
                                   messageName:@"PrivateShieldedTRC20ParametersWithoutAsk"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PrivateShieldedTRC20ParametersWithoutAsk__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        static const char *extraTextFormatInfo =
        "\001\t\010\343\002\250\247\000";
        [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - ShieldedTRC20Parameters

@implementation ShieldedTRC20Parameters

@dynamic spendDescriptionArray, spendDescriptionArray_Count;
@dynamic receiveDescriptionArray, receiveDescriptionArray_Count;
@dynamic bindingSignature;
@dynamic messageHash;
@dynamic triggerContractInput;
@dynamic parameterType;

typedef struct ShieldedTRC20Parameters__storage_ {
    uint32_t _has_storage_[1];
    NSMutableArray *spendDescriptionArray;
    NSMutableArray *receiveDescriptionArray;
    NSData *bindingSignature;
    NSData *messageHash;
    NSString *triggerContractInput;
    NSString *parameterType;
} ShieldedTRC20Parameters__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "spendDescriptionArray",
                .dataTypeSpecific.clazz = GPBObjCClass(SpendDescription),
                .number = ShieldedTRC20Parameters_FieldNumber_SpendDescriptionArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(ShieldedTRC20Parameters__storage_, spendDescriptionArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "receiveDescriptionArray",
                .dataTypeSpecific.clazz = GPBObjCClass(ReceiveDescription),
                .number = ShieldedTRC20Parameters_FieldNumber_ReceiveDescriptionArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(ShieldedTRC20Parameters__storage_, receiveDescriptionArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "bindingSignature",
                .dataTypeSpecific.clazz = Nil,
                .number = ShieldedTRC20Parameters_FieldNumber_BindingSignature,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(ShieldedTRC20Parameters__storage_, bindingSignature),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "messageHash",
                .dataTypeSpecific.clazz = Nil,
                .number = ShieldedTRC20Parameters_FieldNumber_MessageHash,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(ShieldedTRC20Parameters__storage_, messageHash),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "triggerContractInput",
                .dataTypeSpecific.clazz = Nil,
                .number = ShieldedTRC20Parameters_FieldNumber_TriggerContractInput,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(ShieldedTRC20Parameters__storage_, triggerContractInput),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeString,
            },
            {
                .name = "parameterType",
                .dataTypeSpecific.clazz = Nil,
                .number = ShieldedTRC20Parameters_FieldNumber_ParameterType,
                .hasIndex = 3,
                .offset = (uint32_t)offsetof(ShieldedTRC20Parameters__storage_, parameterType),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeString,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ShieldedTRC20Parameters)
                                   messageName:@"ShieldedTRC20Parameters"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ShieldedTRC20Parameters__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - IvkDecryptTRC20Parameters

@implementation IvkDecryptTRC20Parameters

@dynamic startBlockIndex;
@dynamic endBlockIndex;
@dynamic shieldedTrc20ContractAddress;
@dynamic ivk;
@dynamic ak;
@dynamic nk;
@dynamic eventsArray, eventsArray_Count;

typedef struct IvkDecryptTRC20Parameters__storage_ {
    uint32_t _has_storage_[1];
    NSData *shieldedTrc20ContractAddress;
    NSData *ivk;
    NSData *ak;
    NSData *nk;
    NSMutableArray *eventsArray;
    int64_t startBlockIndex;
    int64_t endBlockIndex;
} IvkDecryptTRC20Parameters__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "startBlockIndex",
                .dataTypeSpecific.clazz = Nil,
                .number = IvkDecryptTRC20Parameters_FieldNumber_StartBlockIndex,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(IvkDecryptTRC20Parameters__storage_, startBlockIndex),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "endBlockIndex",
                .dataTypeSpecific.clazz = Nil,
                .number = IvkDecryptTRC20Parameters_FieldNumber_EndBlockIndex,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(IvkDecryptTRC20Parameters__storage_, endBlockIndex),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "shieldedTrc20ContractAddress",
                .dataTypeSpecific.clazz = Nil,
                .number = IvkDecryptTRC20Parameters_FieldNumber_ShieldedTrc20ContractAddress,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(IvkDecryptTRC20Parameters__storage_, shieldedTrc20ContractAddress),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "ivk",
                .dataTypeSpecific.clazz = Nil,
                .number = IvkDecryptTRC20Parameters_FieldNumber_Ivk,
                .hasIndex = 3,
                .offset = (uint32_t)offsetof(IvkDecryptTRC20Parameters__storage_, ivk),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "ak",
                .dataTypeSpecific.clazz = Nil,
                .number = IvkDecryptTRC20Parameters_FieldNumber_Ak,
                .hasIndex = 4,
                .offset = (uint32_t)offsetof(IvkDecryptTRC20Parameters__storage_, ak),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "nk",
                .dataTypeSpecific.clazz = Nil,
                .number = IvkDecryptTRC20Parameters_FieldNumber_Nk,
                .hasIndex = 5,
                .offset = (uint32_t)offsetof(IvkDecryptTRC20Parameters__storage_, nk),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "eventsArray",
                .dataTypeSpecific.clazz = Nil,
                .number = IvkDecryptTRC20Parameters_FieldNumber_EventsArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(IvkDecryptTRC20Parameters__storage_, eventsArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeString,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(IvkDecryptTRC20Parameters)
                                   messageName:@"IvkDecryptTRC20Parameters"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IvkDecryptTRC20Parameters__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        static const char *extraTextFormatInfo =
        "\001\003\010\343\002\250\247\000";
        [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - OvkDecryptTRC20Parameters

@implementation OvkDecryptTRC20Parameters

@dynamic startBlockIndex;
@dynamic endBlockIndex;
@dynamic ovk;
@dynamic shieldedTrc20ContractAddress;
@dynamic eventsArray, eventsArray_Count;

typedef struct OvkDecryptTRC20Parameters__storage_ {
    uint32_t _has_storage_[1];
    NSData *ovk;
    NSData *shieldedTrc20ContractAddress;
    NSMutableArray *eventsArray;
    int64_t startBlockIndex;
    int64_t endBlockIndex;
} OvkDecryptTRC20Parameters__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "startBlockIndex",
                .dataTypeSpecific.clazz = Nil,
                .number = OvkDecryptTRC20Parameters_FieldNumber_StartBlockIndex,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(OvkDecryptTRC20Parameters__storage_, startBlockIndex),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "endBlockIndex",
                .dataTypeSpecific.clazz = Nil,
                .number = OvkDecryptTRC20Parameters_FieldNumber_EndBlockIndex,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(OvkDecryptTRC20Parameters__storage_, endBlockIndex),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "ovk",
                .dataTypeSpecific.clazz = Nil,
                .number = OvkDecryptTRC20Parameters_FieldNumber_Ovk,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(OvkDecryptTRC20Parameters__storage_, ovk),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "shieldedTrc20ContractAddress",
                .dataTypeSpecific.clazz = Nil,
                .number = OvkDecryptTRC20Parameters_FieldNumber_ShieldedTrc20ContractAddress,
                .hasIndex = 3,
                .offset = (uint32_t)offsetof(OvkDecryptTRC20Parameters__storage_, shieldedTrc20ContractAddress),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "eventsArray",
                .dataTypeSpecific.clazz = Nil,
                .number = OvkDecryptTRC20Parameters_FieldNumber_EventsArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(OvkDecryptTRC20Parameters__storage_, eventsArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeString,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(OvkDecryptTRC20Parameters)
                                   messageName:@"OvkDecryptTRC20Parameters"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OvkDecryptTRC20Parameters__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        static const char *extraTextFormatInfo =
        "\001\004\010\343\002\250\247\000";
        [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - DecryptNotesTRC20

@implementation DecryptNotesTRC20

@dynamic noteTxsArray, noteTxsArray_Count;

typedef struct DecryptNotesTRC20__storage_ {
    uint32_t _has_storage_[1];
    NSMutableArray *noteTxsArray;
} DecryptNotesTRC20__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "noteTxsArray",
                .dataTypeSpecific.clazz = GPBObjCClass(DecryptNotesTRC20_NoteTx),
                .number = DecryptNotesTRC20_FieldNumber_NoteTxsArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(DecryptNotesTRC20__storage_, noteTxsArray),
                .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
                .dataType = GPBDataTypeMessage,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(DecryptNotesTRC20)
                                   messageName:@"DecryptNotesTRC20"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DecryptNotesTRC20__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        static const char *extraTextFormatInfo =
        "\001\001\000noteTxs\000";
        [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - DecryptNotesTRC20_NoteTx

@implementation DecryptNotesTRC20_NoteTx

@dynamic hasNote, note;
@dynamic position;
@dynamic isSpent;
@dynamic txid;
@dynamic index;
@dynamic toAmount;
@dynamic transparentToAddress;

typedef struct DecryptNotesTRC20_NoteTx__storage_ {
    uint32_t _has_storage_[1];
    int32_t index;
    Note *note;
    NSData *txid;
    NSString *toAmount;
    NSData *transparentToAddress;
    int64_t position;
} DecryptNotesTRC20_NoteTx__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "note",
                .dataTypeSpecific.clazz = GPBObjCClass(Note),
                .number = DecryptNotesTRC20_NoteTx_FieldNumber_Note,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(DecryptNotesTRC20_NoteTx__storage_, note),
                .flags = GPBFieldOptional,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "position",
                .dataTypeSpecific.clazz = Nil,
                .number = DecryptNotesTRC20_NoteTx_FieldNumber_Position,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(DecryptNotesTRC20_NoteTx__storage_, position),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "isSpent",
                .dataTypeSpecific.clazz = Nil,
                .number = DecryptNotesTRC20_NoteTx_FieldNumber_IsSpent,
                .hasIndex = 2,
                .offset = 3,  // Stored in _has_storage_ to save space.
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBool,
            },
            {
                .name = "txid",
                .dataTypeSpecific.clazz = Nil,
                .number = DecryptNotesTRC20_NoteTx_FieldNumber_Txid,
                .hasIndex = 4,
                .offset = (uint32_t)offsetof(DecryptNotesTRC20_NoteTx__storage_, txid),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "index",
                .dataTypeSpecific.clazz = Nil,
                .number = DecryptNotesTRC20_NoteTx_FieldNumber_Index,
                .hasIndex = 5,
                .offset = (uint32_t)offsetof(DecryptNotesTRC20_NoteTx__storage_, index),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt32,
            },
            {
                .name = "toAmount",
                .dataTypeSpecific.clazz = Nil,
                .number = DecryptNotesTRC20_NoteTx_FieldNumber_ToAmount,
                .hasIndex = 6,
                .offset = (uint32_t)offsetof(DecryptNotesTRC20_NoteTx__storage_, toAmount),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeString,
            },
            {
                .name = "transparentToAddress",
                .dataTypeSpecific.clazz = Nil,
                .number = DecryptNotesTRC20_NoteTx_FieldNumber_TransparentToAddress,
                .hasIndex = 7,
                .offset = (uint32_t)offsetof(DecryptNotesTRC20_NoteTx__storage_, transparentToAddress),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(DecryptNotesTRC20_NoteTx)
                                   messageName:@"NoteTx"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DecryptNotesTRC20_NoteTx__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
        [localDescriptor setupContainingMessageClass:GPBObjCClass(DecryptNotesTRC20)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - NfTRC20Parameters

@implementation NfTRC20Parameters

@dynamic hasNote, note;
@dynamic ak;
@dynamic nk;
@dynamic position;
@dynamic shieldedTrc20ContractAddress;

typedef struct NfTRC20Parameters__storage_ {
    uint32_t _has_storage_[1];
    Note *note;
    NSData *ak;
    NSData *nk;
    NSData *shieldedTrc20ContractAddress;
    int64_t position;
} NfTRC20Parameters__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "note",
                .dataTypeSpecific.clazz = GPBObjCClass(Note),
                .number = NfTRC20Parameters_FieldNumber_Note,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(NfTRC20Parameters__storage_, note),
                .flags = GPBFieldOptional,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "ak",
                .dataTypeSpecific.clazz = Nil,
                .number = NfTRC20Parameters_FieldNumber_Ak,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(NfTRC20Parameters__storage_, ak),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "nk",
                .dataTypeSpecific.clazz = Nil,
                .number = NfTRC20Parameters_FieldNumber_Nk,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(NfTRC20Parameters__storage_, nk),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
            {
                .name = "position",
                .dataTypeSpecific.clazz = Nil,
                .number = NfTRC20Parameters_FieldNumber_Position,
                .hasIndex = 3,
                .offset = (uint32_t)offsetof(NfTRC20Parameters__storage_, position),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeInt64,
            },
            {
                .name = "shieldedTrc20ContractAddress",
                .dataTypeSpecific.clazz = Nil,
                .number = NfTRC20Parameters_FieldNumber_ShieldedTrc20ContractAddress,
                .hasIndex = 4,
                .offset = (uint32_t)offsetof(NfTRC20Parameters__storage_, shieldedTrc20ContractAddress),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(NfTRC20Parameters)
                                   messageName:@"NfTRC20Parameters"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NfTRC20Parameters__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        static const char *extraTextFormatInfo =
        "\001\005\010\343\002\250\247\000";
        [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - NullifierResult

@implementation NullifierResult

@dynamic isSpent;

typedef struct NullifierResult__storage_ {
    uint32_t _has_storage_[1];
} NullifierResult__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "isSpent",
                .dataTypeSpecific.clazz = Nil,
                .number = NullifierResult_FieldNumber_IsSpent,
                .hasIndex = 0,
                .offset = 1,  // Stored in _has_storage_ to save space.
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBool,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(NullifierResult)
                                   messageName:@"NullifierResult"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NullifierResult__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end

#pragma mark - ShieldedTRC20TriggerContractParameters

@implementation ShieldedTRC20TriggerContractParameters

@dynamic hasShieldedTrc20Parameters, shieldedTrc20Parameters;
@dynamic spendAuthoritySignatureArray, spendAuthoritySignatureArray_Count;
@dynamic amount;
@dynamic transparentToAddress;

typedef struct ShieldedTRC20TriggerContractParameters__storage_ {
    uint32_t _has_storage_[1];
    ShieldedTRC20Parameters *shieldedTrc20Parameters;
    NSMutableArray *spendAuthoritySignatureArray;
    NSString *amount;
    NSData *transparentToAddress;
} ShieldedTRC20TriggerContractParameters__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
    static GPBDescriptor *descriptor = nil;
    if (!descriptor) {
        GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
        static GPBMessageFieldDescription fields[] = {
            {
                .name = "shieldedTrc20Parameters",
                .dataTypeSpecific.clazz = GPBObjCClass(ShieldedTRC20Parameters),
                .number = ShieldedTRC20TriggerContractParameters_FieldNumber_ShieldedTrc20Parameters,
                .hasIndex = 0,
                .offset = (uint32_t)offsetof(ShieldedTRC20TriggerContractParameters__storage_, shieldedTrc20Parameters),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "spendAuthoritySignatureArray",
                .dataTypeSpecific.clazz = GPBObjCClass(BytesMessage),
                .number = ShieldedTRC20TriggerContractParameters_FieldNumber_SpendAuthoritySignatureArray,
                .hasIndex = GPBNoHasBit,
                .offset = (uint32_t)offsetof(ShieldedTRC20TriggerContractParameters__storage_, spendAuthoritySignatureArray),
                .flags = GPBFieldRepeated,
                .dataType = GPBDataTypeMessage,
            },
            {
                .name = "amount",
                .dataTypeSpecific.clazz = Nil,
                .number = ShieldedTRC20TriggerContractParameters_FieldNumber_Amount,
                .hasIndex = 1,
                .offset = (uint32_t)offsetof(ShieldedTRC20TriggerContractParameters__storage_, amount),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeString,
            },
            {
                .name = "transparentToAddress",
                .dataTypeSpecific.clazz = Nil,
                .number = ShieldedTRC20TriggerContractParameters_FieldNumber_TransparentToAddress,
                .hasIndex = 2,
                .offset = (uint32_t)offsetof(ShieldedTRC20TriggerContractParameters__storage_, transparentToAddress),
                .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
                .dataType = GPBDataTypeBytes,
            },
        };
        GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ShieldedTRC20TriggerContractParameters)
                                   messageName:@"ShieldedTRC20TriggerContractParameters"
                               fileDescription:&ApiRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ShieldedTRC20TriggerContractParameters__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
        static const char *extraTextFormatInfo =
        "\001\001\010\343\002\212\000";
        [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
#if defined(DEBUG) && DEBUG
        NSAssert(descriptor == nil, @"Startup recursed!");
#endif  // DEBUG
        descriptor = localDescriptor;
    }
    return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)

// clang-format on
